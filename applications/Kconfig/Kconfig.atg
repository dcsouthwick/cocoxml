SECTION license
/*-------------------------------------------------------------------------
Kconfig.atg
Copyright (C) 2008, Charles Wang
Author: Charles Wang  <charlesw123456@gmail.com>
License: LGPLv2
-------------------------------------------------------------------------*/
END.

SCHEME c Kc

SECTION hIncludes
#ifndef  COCO_KCDATA_H
#include "KcData.h"
#endif
END.

SECTION cIncludes
END.

COMPILER Kconfig

MEMBERS
    KcSymbolTable_t * symtab;

CONSTRUCTOR
    if (!(self->symtab = KcSymbolTable())) goto ERRQUIT;

DESTRUCTOR
    KcSymbolTable_Destruct(self->symtab);

INDENTATIONS

CHARACTERS
    letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
    digit     = "0123456789".
    cr        = '\r'.
    lf        = '\n'.
    tab       = '\t'.
    stringCh  = ANY - '"' - '\\' - cr - lf.
    printable = '\x20' .. '\x7e'.

TOKENS
    ident     = letter { letter | digit }.
    string    = '"' { stringCh | '\\' printable } '"'.
    eol       = (cr lf) | lf.

COMMENTS FROM "#" TO lf

IGNORE tab

PRODUCTIONS

Kconfig =
  { ConfigDecl }
.

ConfigDecl           (. CcsBool_t menuOrNot;
		     	char * symname = NULL;
			KcSymbolType_t symtype = KcstNone;
			KcProperty_t * propFirst = NULL, * propLast = NULL, * propNew = NULL;
		     	CcsPosition_t * helpmsg = NULL; .)
 = ("config"         (. menuOrNot = FALSE; .)
    | "menuconfig"   (. menuOrNot = TRUE; .)
  ) ident            (. symname = CcsStrdup(self->t->val); .)
  eol IndentIn { ConfigProperty<&symtype, &propNew>
                     (. if (propLast) {
      	       	 	    propLast->next = propNew; propLast = propNew;
			} else {
			    propFirst = propLast = propNew;
			} .)
  } [ Help<&helpmsg> ] IndentOut
      		     (. KcSymbolTable_AppendSymbol(self->symtab, symname, menuOrNot, propFirst, helpmsg);
		     	CcsFree(symname); .)
.

ConfigProperty<KcSymbolType_t * symtype, KcProperty_t ** prop> =
  TypeDefine<symtype, prop>
  | InputPrompt<prop>
  | Default<prop>
  | TypeWithDefault<symtype, prop>
  | DependsOn<prop>
  | Select<prop>
  | Ranges<prop>
.

TypeDefine<KcSymbolType_t * symtype, KcProperty_t ** prop> =
  ("bool"          (. *symtype = KcstBool; .)
  | "tristate"     (. *symtype = KcstTristate; .)
  | "string"       (. *symtype = KcstString; .)
  | "hex"          (. *symtype = KcstHex; .)
  | "int"          (. *symtype = KcstInt; .)
  ) [string        (. KcProperty_AppendPrompt(prop, self->t->val, NULL); .)
  ] eol
.

InputPrompt<KcProperty_t ** prop>
                         (. char * prompt; KcExpr_t * expr = NULL; .) =
  "prompt" string        (. prompt = CcsStrdup(self->t->val); .)
 ["if" Expr<&expr>] eol  (. KcProperty_AppendPrompt(prop, prompt, expr); .)
.

Default<KcProperty_t ** prop> (. KcExpr_t * expr0, * expr1 = NULL; .) =
  "default" Expr<&expr0> ["if" Expr<&expr1>] eol
                              (. KcProperty_AppendDefault(prop, expr0, expr1); .)
.

TypeWithDefault<KcSymbolType_t * symtype, KcProperty_t ** prop>
                      (. KcExpr_t * expr0, * expr1  = NULL; .) =
  ("def_bool"         (. *symtype = KcstBool; .)
   | "def_tristate"   (. *symtype = KcstTristate; .)
  ) Expr<&expr0> ["if" Expr<&expr1>] eol
                      (. KcProperty_AppendDefault(prop, expr0, expr1); .)
.

DependsOn<KcProperty_t ** prop>  (. KcExpr_t * expr; .) =
  "depends" "on" Expr<&expr> eol (. KcProperty_AppendDepends(prop, expr); .)
.

Select<KcProperty_t ** prop>   (. KcSymbol_t * sym; KcExpr_t * expr = NULL; .) =
  "select" Symbol<&sym> ["if" Expr<&expr> ] eol
                               (. KcProperty_AppendSelect(prop, sym, expr); .)
.

Ranges<KcProperty_t ** prop>    (. KcSymbol_t * sym0, * sym1; KcExpr_t * expr = NULL; .) =
  "ranges" Symbol<&sym0> Symbol<&sym1> ["if" Expr<&expr>] eol
                                (. KcProperty_AppendRanges(prop, sym0, sym1, expr); .)
.

Help<CcsPosition_t ** pos>              (. CcsToken_t * beg; .) =
  ("help" | "---help---") eol IndentIn  (. KcScanner_IncRef(&self->scanner, beg = self->la); .)
  { ANY } IndentOut                     (. *pos = KcScanner_GetPosition(&self->scanner, beg, self->t);
    	  			           KcScanner_DecRef(&self->scanner, beg); .)
.

Expr<KcExpr_t ** expr> =            (. KcExpr_t * expr0; .)
  Expr0<expr> { "||" Expr0<&expr0>  (. *expr = KcExpr(KcetExprOr, NULL, NULL, *expr, expr0); .)
  }
.

Expr0<KcExpr_t ** expr> =           (. KcExpr_t * expr0; .)
  Expr1<expr> { "&&" Expr1<&expr0>  (. *expr = KcExpr(KcetExprAnd, NULL, NULL, *expr, expr0); .)
  }
.

Expr1<KcExpr_t ** expr> = (. KcExpr_t * expr0; .)
  '!' Expr2<&expr0>       (. *expr = KcExpr(KcetNotExpr, NULL, NULL, expr0, NULL); .)
.

Expr2<KcExpr_t ** expr> =
  '(' Expr3<expr> ')'
.

Expr3<KcExpr_t ** expr> = (. char op = 0; KcSymbol_t * sym0 = NULL, * sym1 = NULL; .)
  (Symbol<&sym0> [ ("="   (. op = '='; .)
                 | "!="   (. op = '!'; .)
  ) Symbol<&sym1> ])      (. switch (op) {
    			     case 0: *expr = KcExpr(KcetSymbol, sym0, NULL, NULL, NULL); break;
			     case '=': *expr = KcExpr(KcetSymbolEqual, sym0, sym1, NULL, NULL); break;
			     case '!': *expr = KcExpr(KcetSymbolNotEqual, sym0, sym1, NULL, NULL); break;
			     } .)
  | Expr<expr>
.

Symbol<KcSymbol_t ** sym> = ident
        (. *sym = KcSymbolTable_Get(self->symtab, self->t->val); .)
.

END Kconfig.
