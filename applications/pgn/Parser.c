/*---- license ----*/
/*-------------------------------------------------------------------------
 Coco.ATG -- Attributed Grammar
 Compiler Generator Coco/R,
 Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
 extended by M. Loeberbauer & A. Woess, Univ. of Linz
 with improvements by Pat Terry, Rhodes University.
 ported to C by Charles Wang <charlesw123456@gmail.com>

 This program is free software; you can redistribute it and/or modify it 
 under the terms of the GNU General Public License as published by the 
 Free Software Foundation; either version 2, or (at your option) any 
 later version.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 for more details.

 You should have received a copy of the GNU General Public License along 
 with this program; if not, write to the Free Software Foundation, Inc., 
 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

 As an exception, it is allowed to write an extension of Coco/R that is
 used as a plugin in non-free software.

 If not otherwise stated, any source code generated by Coco/R (other than 
 Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*---- enable ----*/
#include  "Parser.h"
#include  "c/Token.h"

/*---- cIncludes ----*/
#include  <ctype.h>
#include  "Globals.h"
#include  "lexical/CharSet.h"
#include  "lexical/CharClass.h"
#include  "lexical/Nodes.h"
#include  "syntax/Nodes.h"
static const int PgnParser_id = 0;
static const int PgnParser_str = 1;
static const char * noString = "~none~";
/*---- enable ----*/

static void PgnParser_SynErr(PgnParser_t * self, int n);
static const char * set[];

static void
PgnParser_Get(PgnParser_t * self)
{
    self->t = self->la;
    for (;;) {
	self->la = PgnScanner_Scan(&self->scanner);
	if (self->la->kind <= self->maxT) { /*++self->errDist;*/ break; }
	/*---- Pragmas ----*/
	if (self->la->kind == 49) {
	    
	}
	/*---- enable ----*/
    }
}

static CcsBool_t
PgnParser_StartOf(PgnParser_t * self, int s)
{
    return set[s][self->la->kind] == '*';
}

static void
PgnParser_Expect(PgnParser_t * self, int n)
{
    if (self->la->kind == n) PgnParser_Get(self);
    else PgnParser_SynErr(self, n);
}

static void
PgnParser_ExpectWeak(PgnParser_t * self, int n, int follow)
{
    if (self->la->kind == n) PgnParser_Get(self);
    else {
	PgnParser_SynErr(self, n);
	while (!PgnParser_StartOf(self, follow)) PgnParser_Get(self);
    }
}

static CcsBool_t
PgnParser_WeakSeparator(PgnParser_t * self, int n, int syFol, int repFol)
{
    if (self->la->kind == n) { PgnParser_Get(self); return TRUE; }
    else if (PgnParser_StartOf(self, repFol)) { return FALSE; }
    PgnParser_SynErr(self, n);
    while (!(PgnParser_StartOf(self, syFol) ||
	     PgnParser_StartOf(self, repFol) ||
	     PgnParser_StartOf(self, 0)))
	PgnParser_Get(self);
    return PgnParser_StartOf(self, syFol);
}

/*---- ProductionsHeader ----*/
static void PgnParser_Coco(PgnParser_t * self);
static void PgnParser_SchemeDecl(PgnParser_t * self);
static void PgnParser_SectionDecl(PgnParser_t * self);
static void PgnParser_UpdateDecl(PgnParser_t * self);
static void PgnParser_SetDecl(PgnParser_t * self);
static void PgnParser_TokenDecl(PgnParser_t * self, const CcObjectType_t * typ);
static void PgnParser_TokenExpr(PgnParser_t * self, CcGraph_t ** g);
static void PgnParser_Set(PgnParser_t * self, CcCharSet_t ** s);
static void PgnParser_AttrDecl(PgnParser_t * self, CcSymbolNT_t * sym);
static void PgnParser_SemText(PgnParser_t * self, CcsPosition_t ** pos);
static void PgnParser_Expression(PgnParser_t * self, CcGraph_t ** g);
static void PgnParser_SimSet(PgnParser_t * self, CcCharSet_t ** s);
static void PgnParser_Char(PgnParser_t * self, int * n);
static void PgnParser_Sym(PgnParser_t * self, char ** name, int * kind);
static void PgnParser_Term(PgnParser_t * self, CcGraph_t ** g);
static void PgnParser_Resolver(PgnParser_t * self, CcsPosition_t ** pos);
static void PgnParser_Factor(PgnParser_t * self, CcGraph_t ** g);
static void PgnParser_Attribs(PgnParser_t * self, CcNode_t * p);
static void PgnParser_Condition(PgnParser_t * self);
static void PgnParser_TokenTerm(PgnParser_t * self, CcGraph_t ** g);
static void PgnParser_TokenFactor(PgnParser_t * self, CcGraph_t ** g);
/*---- enable ----*/

void
PgnParser_Parse(PgnParser_t * self)
{
    self->t = NULL;
    self->la = PgnScanner_GetDummy(&self->scanner);
    PgnParser_Get(self);
    /*---- ParseRoot ----*/
    PgnParser_Coco(self);
    /*---- enable ----*/
    PgnParser_Expect(self, 0);
}

void
PgnParser_SemErr(PgnParser_t * self, const CcsToken_t * token,
		 const char * format, ...)
{
    va_list ap;
    va_start(ap, format);
    CcsErrorPool_VError(&self->errpool, token->line, token->col,
			format, ap);
    va_end(ap);
}

void
PgnParser_SemErrT(PgnParser_t * self, const char * format, ...)
{
    va_list ap;
    va_start(ap, format);
    CcsErrorPool_VError(&self->errpool, self->t->line, self->t->col,
			format, ap);
    va_end(ap);
}

PgnParser_t *
PgnParser(PgnParser_t * self, const char * fname, FILE * errfp)
{
    if (!CcsErrorPool(&self->errpool, errfp)) goto errquit0;
    if (!PgnScanner(&self->scanner, &self->errpool, fname)) goto errquit1;
    self->t = self->la = NULL;
    /*---- constructor ----*/
    self->maxT = 48;
    if (!CcGlobals(&self->globals, &self->errpool)) goto ERRQUIT;
    self->tokenString = NULL;
    self->genScanner = FALSE;
    self->schemeName = NULL;
    self->prefix = NULL;
    self->members = NULL;
    self->constructor = NULL;
    self->destructor = NULL;
    self->symtab = &self->globals.symtab;
    self->lexical = self->globals.lexical;
    self->syntax = &self->globals.syntax;
    /*---- enable ----*/
    return self;
 ERRQUIT:
 errquit1:
    CcsErrorPool_Destruct(&self->errpool);
 errquit0:
    return NULL;
}

void
PgnParser_Destruct(PgnParser_t * self)
{
    /*---- destructor ----*/
    if (self->destructor) CcsPosition_Destruct(self->destructor);
    if (self->constructor) CcsPosition_Destruct(self->constructor);
    if (self->members) CcsPosition_Destruct(self->members);
    if (self->prefix) CcFree(self->prefix);
    if (self->schemeName) CcFree(self->schemeName);
    if (self->tokenString && self->tokenString != noString)
	CcFree(self->tokenString);
    CcGlobals_Destruct(&self->globals);
    /*---- enable ----*/
    PgnScanner_Destruct(&self->scanner);
    CcsErrorPool_Destruct(&self->errpool);
}

/*---- ProductionsBody ----*/
static void
PgnParser_Coco(PgnParser_t * self)
{
    CcSymbol_t  * sym;
    CcGraph_t   * g, * g1, * g2;
    char        * gramName = NULL;
    CcCharSet_t * s; 
    CcsToken_t  * beg;
    self->tokenString = NULL; 
    while (self->la->kind == 24 || self->la->kind == 25 || self->la->kind == 26) {
	if (self->la->kind == 24) {
	    PgnParser_SchemeDecl(self);
	} else if (self->la->kind == 25) {
	    PgnParser_SectionDecl(self);
	} else {
	    PgnParser_UpdateDecl(self);
	}
    }
    PgnParser_Expect(self, 6);
    self->genScanner = TRUE; 
    PgnParser_Expect(self, 1);
    gramName = CcStrdup(self->t->val); 
    if (self->la->kind == 7) {
	PgnParser_Get(self);
	PgnScanner_IncRef(&self->scanner, beg = self->la); 
	while (PgnParser_StartOf(self, 1)) {
	    PgnParser_Get(self);
	}
	self->members = PgnScanner_GetPosition(&self->scanner, beg, self->la);
	PgnScanner_DecRef(&self->scanner, beg); 
    }
    if (self->la->kind == 8) {
	PgnParser_Get(self);
	PgnScanner_IncRef(&self->scanner, beg = self->la); 
	while (PgnParser_StartOf(self, 2)) {
	    PgnParser_Get(self);
	}
	self->constructor = PgnScanner_GetPosition(&self->scanner, beg, self->la);
	PgnScanner_DecRef(&self->scanner, beg); 
    }
    if (self->la->kind == 9) {
	PgnParser_Get(self);
	PgnScanner_IncRef(&self->scanner, beg = self->la); 
	while (PgnParser_StartOf(self, 3)) {
	    PgnParser_Get(self);
	}
	self->destructor = PgnScanner_GetPosition(&self->scanner, beg, self->la);
	PgnScanner_DecRef(&self->scanner, beg); 
    }
    if (self->la->kind == 10) {
	PgnParser_Get(self);
	self->lexical->ignoreCase = TRUE; 
    }
    if (self->la->kind == 11) {
	PgnParser_Get(self);
	self->lexical->indentUsed = TRUE;
	sym = CcSymbolTable_NewTerminal(self->symtab, "IndentIn", 0);
	self->lexical->indentIn = sym->kind;
	sym = CcSymbolTable_NewTerminal(self->symtab, "IndentOut", 0);
	self->lexical->indentOut = sym->kind;
	sym = CcSymbolTable_NewTerminal(self->symtab, "IndentErr", 0);
	self->lexical->indentErr = sym->kind; 
    }
    if (self->la->kind == 12) {
	PgnParser_Get(self);
	while (self->la->kind == 1) {
	    PgnParser_SetDecl(self);
	}
    }
    if (self->la->kind == 13) {
	PgnParser_Get(self);
	while (self->la->kind == 1 || self->la->kind == 3 || self->la->kind == 5) {
	    PgnParser_TokenDecl(self, symbol_t);
	}
    }
    if (self->la->kind == 14) {
	PgnParser_Get(self);
	while (self->la->kind == 1 || self->la->kind == 3 || self->la->kind == 5) {
	    PgnParser_TokenDecl(self, symbol_pr);
	}
    }
    while (self->la->kind == 15) {
	PgnParser_Get(self);
	CcsBool_t nested = FALSE; 
	PgnParser_Expect(self, 16);
	PgnParser_TokenExpr(self, &g1);
	PgnParser_Expect(self, 17);
	PgnParser_TokenExpr(self, &g2);
	if (self->la->kind == 18) {
	    PgnParser_Get(self);
	    nested = TRUE; 
	}
	CcLexical_NewComment(self->lexical, self->t,
			     g1->head, g2->head, nested);
	CcGraph_Destruct(g1); CcGraph_Destruct(g2); 
    }
    while (self->la->kind == 19) {
	PgnParser_Get(self);
	PgnParser_Set(self, &s);
	CcCharSet_Or(self->lexical->ignored, s);
	CcCharSet_Destruct(s); 
    }
    while (!(self->la->kind == 0 || self->la->kind == 20)) {
	PgnParser_SynErr(self, 49); PgnParser_Get(self);
    }
    PgnParser_Expect(self, 20);
    if (self->genScanner) CcLexical_MakeDeterministic(self->lexical);
    CcEBNF_Clear(&self->lexical->base);
    CcEBNF_Clear(&self->syntax->base); 
    while (self->la->kind == 1) {
	PgnParser_Get(self);
	sym = CcSymbolTable_FindSym(self->symtab, self->t->val);
	CcsBool_t undef = (sym == NULL);
	if (undef) {
	    sym = CcSymbolTable_NewNonTerminal(self->symtab,
					       self->t->val, self->t->line);
	} else {
	    if (sym->base.type == symbol_nt) {
		if (((CcSymbolNT_t *)sym)->graph != NULL)
		    PgnParser_SemErrT(self, "name declared twice");
	    } else {
		PgnParser_SemErrT(self, "this symbol kind not allowed on left side of production");
	    }
	    sym->line = self->t->line;
	}
	CcsAssert(sym->base.type == symbol_nt);
	CcsBool_t noAttrs = (((CcSymbolNT_t *)sym)->attrPos == NULL);
	if (!noAttrs) {
	    CcsPosition_Destruct(((CcSymbolNT_t *)sym)->attrPos);
	    ((CcSymbolNT_t *)sym)->attrPos = NULL; 
	} 
	if (self->la->kind == 31 || self->la->kind == 33) {
	    PgnParser_AttrDecl(self, (CcSymbolNT_t *)sym);
	}
	if (!undef && noAttrs != (((CcSymbolNT_t *)sym)->attrPos == NULL))
	    PgnParser_SemErrT(self, "attribute mismatch between declaration and use of this symbol"); 
	if (self->la->kind == 46) {
	    PgnParser_SemText(self, &((CcSymbolNT_t *)sym)->semPos);
	}
	PgnParser_ExpectWeak(self, 21, 4);
	PgnParser_Expression(self, &g);
	((CcSymbolNT_t *)sym)->graph = g->head;
	CcGraph_Finish(g);
	CcGraph_Destruct(g); 
	PgnParser_ExpectWeak(self, 22, 5);
    }
    PgnParser_Expect(self, 23);
    PgnParser_Expect(self, 1);
    if (strcmp(gramName, self->t->val))
	PgnParser_SemErrT(self, "name does not match grammar name");
    self->syntax->gramSy = CcSymbolTable_FindSym(self->symtab, gramName);
    CcFree(gramName);
    if (self->syntax->gramSy == NULL) {
	PgnParser_SemErrT(self, "missing production for grammar name");
    } else {
	sym = self->syntax->gramSy;
	if (((CcSymbolNT_t *)sym)->attrPos != NULL)
	    PgnParser_SemErrT(self, "grammar symbol must not have attributes");
    }
    /* noSym gets highest number */
    self->syntax->noSy = CcSymbolTable_NewTerminal(self->symtab, "???", 0);
    CcSyntax_SetupAnys(self->syntax); 
    PgnParser_Expect(self, 22);
}

static void
PgnParser_SchemeDecl(PgnParser_t * self)
{
    PgnParser_Expect(self, 24);
    PgnParser_Expect(self, 1);
    if (self->schemeName) CcFree(self->schemeName);
    self->schemeName = CcStrdup(self->t->val); 
    PgnParser_Expect(self, 1);
    if (self->prefix) CcFree(self->prefix);
    self->prefix = CcStrdup(self->t->val); 
}

static void
PgnParser_SectionDecl(PgnParser_t * self)
{
    char * secname; CcsToken_t * beg; 
    PgnParser_Expect(self, 25);
    PgnParser_Expect(self, 1);
    secname = CcStrdup(self->t->val);
    PgnScanner_IncRef(&self->scanner, beg = self->t); 
    while (PgnParser_StartOf(self, 6)) {
	PgnParser_Get(self);
    }
    CcGlobals_NewSection(&self->globals, secname,
			 PgnScanner_GetPositionBetween(&self->scanner, beg, self->la));
    PgnScanner_DecRef(&self->scanner, beg);
    CcFree(secname); 
    PgnParser_Expect(self, 23);
    PgnParser_Expect(self, 22);
}

static void
PgnParser_UpdateDecl(PgnParser_t * self)
{
    PgnParser_Expect(self, 26);
    while (self->la->kind == 3) {
	PgnParser_Get(self);
	CcGlobals_AddUpdate(&self->globals, self->t->val); 
    }
    PgnParser_Expect(self, 23);
    PgnParser_Expect(self, 22);
}

static void
PgnParser_SetDecl(PgnParser_t * self)
{
    CcCharSet_t * s; 
    PgnParser_Expect(self, 1);
    const char * name = self->t->val;
    CcCharClass_t * c = CcLexical_FindCharClassN(self->lexical, name);
    if (c != NULL)
	PgnParser_SemErrT(self, "name '%s' declared twice", name); 
    PgnParser_Expect(self, 21);
    PgnParser_Set(self, &s);
    if (CcCharSet_Elements(s) == 0)
	PgnParser_SemErrT(self, "character set must not be empty");
    CcLexical_NewCharClass(self->lexical, name, s); 
    PgnParser_Expect(self, 22);
}

static void
PgnParser_TokenDecl(PgnParser_t * self, const CcObjectType_t * typ)
{
    char * name = NULL; int kind; CcSymbol_t * sym; CcGraph_t * g; 
    PgnParser_Sym(self, &name, &kind);
    sym = CcSymbolTable_FindSym(self->symtab, name);
    if (sym != NULL) {
	PgnParser_SemErrT(self, "name '%s' declared twice", name);
    } else if (typ == symbol_t) {
	sym = CcSymbolTable_NewTerminal(self->symtab, name, self->t->line);
	((CcSymbolT_t *)sym)->tokenKind = symbol_fixedToken;
    } else if (typ == symbol_pr) {
	sym = CcSymbolTable_NewPragma(self->symtab, name, self->t->line);
	((CcSymbolPR_t *)sym)->tokenKind = symbol_fixedToken;
	((CcSymbolPR_t *)sym)->semPos = NULL;
    }
    if (self->tokenString && self->tokenString != noString)
	CcFree(self->tokenString);
    self->tokenString = NULL;
    CcFree(name); 
    while (!(PgnParser_StartOf(self, 0))) {
	PgnParser_SynErr(self, 50); PgnParser_Get(self);
    }
    if (self->la->kind == 21) {
	PgnParser_Get(self);
	PgnParser_TokenExpr(self, &g);
	PgnParser_Expect(self, 22);
	if (kind == PgnParser_str)
	    PgnParser_SemErrT(self, "a literal must not be declared with a structure");
	CcGraph_Finish(g);
	if (self->tokenString == NULL || self->tokenString == noString) {
	    CcLexical_ConvertToStates(self->lexical, g->head, sym);
	} else { /* PgnParser_TokenExpr is a single string */
	    if (CcHashTable_Get(&self->lexical->literals,
				self->tokenString) != NULL)
		PgnParser_SemErrT(self, "token string '%s' declared twice", self->tokenString);
	    CcHashTable_Set(&self->lexical->literals,
			    self->tokenString, (CcObject_t *)sym);
	    CcLexical_MatchLiteral(self->lexical, self->t,
				   self->tokenString, sym);
	    CcFree(self->tokenString);
	}
	self->tokenString = NULL;
	CcGraph_Destruct(g); 
    } else if (PgnParser_StartOf(self, 7)) {
	if (kind == PgnParser_id) self->genScanner = FALSE;
	else CcLexical_MatchLiteral(self->lexical, self->t, sym->name, sym); 
    } else PgnParser_SynErr(self, 51);
    if (self->la->kind == 46) {
	PgnParser_SemText(self, &((CcSymbolPR_t *)sym)->semPos);
	if (typ != symbol_pr)
	    PgnParser_SemErrT(self, "semantic action not allowed here"); 
    }
}

static void
PgnParser_TokenExpr(PgnParser_t * self, CcGraph_t ** g)
{
    CcGraph_t * g2; 
    PgnParser_TokenTerm(self, g);
    CcsBool_t first = TRUE; 
    while (PgnParser_WeakSeparator(self, 35, 9, 8)) {
	PgnParser_TokenTerm(self, &g2);
	if (first) { CcEBNF_MakeFirstAlt(&self->lexical->base, *g); first = FALSE; }
	CcEBNF_MakeAlternative(&self->lexical->base, *g, g2);
	CcGraph_Destruct(g2); 
    }
}

static void
PgnParser_Set(PgnParser_t * self, CcCharSet_t ** s)
{
    CcCharSet_t * s2; 
    PgnParser_SimSet(self, s);
    while (self->la->kind == 27 || self->la->kind == 28) {
	if (self->la->kind == 27) {
	    PgnParser_Get(self);
	    PgnParser_SimSet(self, &s2);
	    CcCharSet_Or(*s, s2);
	    CcCharSet_Destruct(s2); 
	} else {
	    PgnParser_Get(self);
	    PgnParser_SimSet(self, &s2);
	    CcCharSet_Subtract(*s, s2);
	    CcCharSet_Destruct(s2); 
	}
    }
}

static void
PgnParser_AttrDecl(PgnParser_t * self, CcSymbolNT_t * sym)
{
    if (self->la->kind == 31) {
	PgnParser_Get(self);
	CcsToken_t * beg;
	PgnScanner_IncRef(&self->scanner, beg = self->la); 
	while (PgnParser_StartOf(self, 10)) {
	    if (PgnParser_StartOf(self, 11)) {
		PgnParser_Get(self);
	    } else {
		PgnParser_Get(self);
		PgnParser_SemErrT(self, "bad string in attributes"); 
	    }
	}
	PgnParser_Expect(self, 32);
	sym->attrPos = PgnScanner_GetPosition(&self->scanner, beg, self->t);
	PgnScanner_DecRef(&self->scanner, beg); 
    } else if (self->la->kind == 33) {
	PgnParser_Get(self);
	CcsToken_t * beg;
	PgnScanner_IncRef(&self->scanner, beg = self->la); 
	while (PgnParser_StartOf(self, 12)) {
	    if (PgnParser_StartOf(self, 13)) {
		PgnParser_Get(self);
	    } else {
		PgnParser_Get(self);
		PgnParser_SemErrT(self, "bad string in attributes"); 
	    }
	}
	PgnParser_Expect(self, 34);
	sym->attrPos = PgnScanner_GetPosition(&self->scanner, beg, self->t);
	PgnScanner_DecRef(&self->scanner, beg); 
    } else PgnParser_SynErr(self, 52);
}

static void
PgnParser_SemText(PgnParser_t * self, CcsPosition_t ** pos)
{
    PgnParser_Expect(self, 46);
    CcsToken_t * beg;
    PgnScanner_IncRef(&self->scanner, beg = self->la); 
    while (PgnParser_StartOf(self, 14)) {
	if (PgnParser_StartOf(self, 15)) {
	    PgnParser_Get(self);
	} else if (self->la->kind == 4) {
	    PgnParser_Get(self);
	    PgnParser_SemErrT(self, "bad string in semantic action"); 
	} else {
	    PgnParser_Get(self);
	    PgnParser_SemErrT(self, "missing end of previous semantic action"); 
	}
    }
    PgnParser_Expect(self, 47);
    *pos = PgnScanner_GetPosition(&self->scanner, beg, self->t);
    PgnScanner_DecRef(&self->scanner, beg); 
}

static void
PgnParser_Expression(PgnParser_t * self, CcGraph_t ** g)
{
    CcGraph_t * g2; 
    PgnParser_Term(self, g);
    CcsBool_t first = TRUE; 
    while (PgnParser_WeakSeparator(self, 35, 17, 16)) {
	PgnParser_Term(self, &g2);
	if (first) { CcEBNF_MakeFirstAlt(&self->syntax->base, *g); first = FALSE; }
	CcEBNF_MakeAlternative(&self->syntax->base, *g, g2);
	CcGraph_Destruct(g2); 
    }
}

static void
PgnParser_SimSet(PgnParser_t * self, CcCharSet_t ** s)
{
    int n1, n2; 
    *s = CcCharSet(); 
    if (self->la->kind == 1) {
	PgnParser_Get(self);
	CcCharClass_t * c = CcLexical_FindCharClassN(self->lexical, self->t->val);
	if (c != NULL) CcCharSet_Or(*s, c->set);
	else PgnParser_SemErrT(self, "undefined name"); 
    } else if (self->la->kind == 3) {
	PgnParser_Get(self);
	const char * cur0; int ch;
	char * cur, * name = CcUnescape(self->t->val);
	if (self->lexical->ignoreCase) {
	    for (cur = name; *cur; ++cur) *cur = tolower(*cur);
	}
	cur0 = name;
	while (*cur0) {
	    ch = CcsUTF8GetCh(&cur0, name + strlen(name));
	    CcsAssert(ch >= 0);
	    CcCharSet_Set(*s, ch);
	}
	CcFree(name); 
    } else if (self->la->kind == 5) {
	PgnParser_Char(self, &n1);
	CcCharSet_Set(*s, n1); 
	if (self->la->kind == 29) {
	    PgnParser_Get(self);
	    PgnParser_Char(self, &n2);
	    int idx;
	    for (idx = n1; idx <= n2; ++idx) CcCharSet_Set(*s, idx); 
	}
    } else if (self->la->kind == 30) {
	PgnParser_Get(self);
	CcCharSet_Fill(*s, COCO_WCHAR_MAX); 
    } else PgnParser_SynErr(self, 53);
}

static void
PgnParser_Char(PgnParser_t * self, int * n)
{
    char * name; const char * cur; 
    PgnParser_Expect(self, 5);
    *n = 0;
    cur = name = CcUnescape(self->t->val);
    *n = CcsUTF8GetCh(&cur, name + strlen(name));
    if (*cur != 0)
	PgnParser_SemErrT(self, "unacceptable character value: '%s'", self->t->val);
    CcFree(name);
    if (self->lexical->ignoreCase) *n = tolower(*n); 
}

static void
PgnParser_Sym(PgnParser_t * self, char ** name, int * kind)
{
    *name = CcStrdup("???"); *kind = PgnParser_id; 
    if (self->la->kind == 1) {
	PgnParser_Get(self);
	*kind = PgnParser_id; CcFree(*name); *name = CcStrdup(self->t->val); 
    } else if (self->la->kind == 3 || self->la->kind == 5) {
	if (self->la->kind == 3) {
	    PgnParser_Get(self);
	    CcFree(*name); *name = CcStrdup(self->t->val); 
	} else {
	    PgnParser_Get(self);
	    CcFree(*name); *name = CcStrdup(self->t->val); 
	}
	*kind = PgnParser_str;
	if (self->lexical->ignoreCase) {
	    char * cur;
	    for (cur = *name; *cur; ++cur) *cur = tolower(*cur);
	}
	if (strchr(*name, ' '))
	    PgnParser_SemErrT(self, "literal tokens \"%s\" can not contain blanks", *name); 
    } else PgnParser_SynErr(self, 54);
}

static void
PgnParser_Term(PgnParser_t * self, CcGraph_t ** g)
{
    CcGraph_t * g2; CcsPosition_t * pos; CcNode_t * rslv = NULL;
    *g = NULL; 
    if (PgnParser_StartOf(self, 18)) {
	if (self->la->kind == 44) {
	    PgnParser_Resolver(self, &pos);
	    rslv = CcEBNF_NewNode(&self->syntax->base,
				  CcNodeRslvP(self->la->line, pos));
	    *g = CcGraphP(rslv); 
	}
	PgnParser_Factor(self, &g2);
	if (rslv == NULL) *g = g2;
	else {
	    CcEBNF_MakeSequence(&self->syntax->base, *g, g2);
	    CcGraph_Destruct(g2);
	} 
	while (PgnParser_StartOf(self, 19)) {
	    PgnParser_Factor(self, &g2);
	    CcEBNF_MakeSequence(&self->syntax->base, *g, g2);
	    CcGraph_Destruct(g2); 
	}
    } else if (PgnParser_StartOf(self, 20)) {
	*g = CcGraphP(CcEBNF_NewNode(&self->syntax->base, CcNodeEps(0))); 
    } else PgnParser_SynErr(self, 55);
    if (*g == NULL) /* invalid start of Term */
	*g = CcGraphP(CcEBNF_NewNode(&self->syntax->base, CcNodeEps(0))); 
}

static void
PgnParser_Resolver(PgnParser_t * self, CcsPosition_t ** pos)
{
    PgnParser_Expect(self, 44);
    PgnParser_Expect(self, 37);
    CcsToken_t * beg;
    PgnScanner_IncRef(&self->scanner, beg = self->la); 
    PgnParser_Condition(self);
    *pos = PgnScanner_GetPosition(&self->scanner, beg, self->t);
    PgnScanner_DecRef(&self->scanner, beg); 
}

static void
PgnParser_Factor(PgnParser_t * self, CcGraph_t ** g)
{
    char * name = NULL; int kind; CcsPosition_t * pos; CcsBool_t weak = FALSE; 
    *g = NULL; 
    switch (self->la->kind) {
    case 1: case 3: case 5: case 36: {
	if (self->la->kind == 36) {
	    PgnParser_Get(self);
	    weak = TRUE; 
	}
	PgnParser_Sym(self, &name, &kind);
	CcSymbol_t * sym = CcSymbolTable_FindSym(self->symtab, name);
	if (sym == NULL && kind == PgnParser_str)
	    sym = (CcSymbol_t *)CcHashTable_Get(&self->lexical->literals, name);
	CcsBool_t undef = (sym == NULL);
	if (undef) {
	    if (kind == PgnParser_id) {
		/* forward nt */
		sym = CcSymbolTable_NewNonTerminal(self->symtab, name, 0);
	    } else if (self->genScanner) {
		sym = CcSymbolTable_NewTerminal(self->symtab, name, self->t->line);
		CcLexical_MatchLiteral(self->lexical, self->t, sym->name, sym);
	    } else {  /* undefined string in production */
		PgnParser_SemErrT(self, "undefined string in production");
		sym = self->syntax->eofSy;  /* dummy */
	    }
	}
	CcFree(name);
	if (sym->base.type != symbol_t && sym->base.type != symbol_nt)
	    PgnParser_SemErrT(self, "this symbol kind is not allowed in a production");
	if (weak) {
	    if (sym->base.type != symbol_t)
		PgnParser_SemErrT(self, "only terminals may be weak");
	}
	CcNode_t * p = CcSyntax_NodeFromSymbol(self->syntax, sym, self->t->line, weak);
	*g = CcGraphP(p); 
	if (self->la->kind == 31 || self->la->kind == 33) {
	    PgnParser_Attribs(self, p);
	    if (kind != PgnParser_id)
		PgnParser_SemErrT(self, "a literal must not have attributes"); 
	}
	if (undef) {
	    if (sym->base.type == symbol_nt)
		((CcSymbolNT_t *)sym)->attrPos = CcsPosition_Clone(((CcNodeNT_t *)p)->pos);
	} else if (sym->base.type == symbol_nt &&
		   (((CcNodeNT_t *)p)->pos == NULL) !=
		   (((CcSymbolNT_t *)sym)->attrPos == NULL))
	    PgnParser_SemErrT(self, "attribute mismatch between declaration and use of this symbol"); 
	break;
    }
    case 37: {
	PgnParser_Get(self);
	PgnParser_Expression(self, g);
	PgnParser_Expect(self, 38);
	break;
    }
    case 39: {
	PgnParser_Get(self);
	PgnParser_Expression(self, g);
	PgnParser_Expect(self, 40);
	CcEBNF_MakeOption(&self->syntax->base, *g); 
	break;
    }
    case 41: {
	PgnParser_Get(self);
	PgnParser_Expression(self, g);
	PgnParser_Expect(self, 42);
	CcEBNF_MakeIteration(&self->syntax->base, *g); 
	break;
    }
    case 46: {
	PgnParser_SemText(self, &pos);
	CcNode_t * p = CcEBNF_NewNode(&self->syntax->base, CcNodeSem(0));
	((CcNodeSEM_t *)p)->pos = pos;
	*g = CcGraphP(p); 
	break;
    }
    case 30: {
	PgnParser_Get(self);
	CcNode_t * p = CcEBNF_NewNode(&self->syntax->base, CcNodeAny(0));
	*g = CcGraphP(p); 
	break;
    }
    case 43: {
	PgnParser_Get(self);
	CcNode_t * p = CcEBNF_NewNode(&self->syntax->base, CcNodeSync(0));
	*g = CcGraphP(p);
	break;
    }
    default: PgnParser_SynErr(self, 56); break;
    }
    if (*g == NULL) /* invalid start of Factor */
	*g = CcGraphP(CcEBNF_NewNode(&self->syntax->base, CcNodeEps(0))); 
}

static void
PgnParser_Attribs(PgnParser_t * self, CcNode_t * p)
{
    if (self->la->kind == 31) {
	PgnParser_Get(self);
	CcsToken_t * beg;
	PgnScanner_IncRef(&self->scanner, beg = self->la); 
	while (PgnParser_StartOf(self, 10)) {
	    if (PgnParser_StartOf(self, 11)) {
		PgnParser_Get(self);
	    } else {
		PgnParser_Get(self);
		PgnParser_SemErrT(self, "bad string in attributes"); 
	    }
	}
	PgnParser_Expect(self, 32);
	CcNode_SetPosition(p, PgnScanner_GetPosition(&self->scanner,
						     beg, self->t));
	PgnScanner_DecRef(&self->scanner, beg); 
    } else if (self->la->kind == 33) {
	PgnParser_Get(self);
	CcsToken_t * beg;
	PgnScanner_IncRef(&self->scanner, beg = self->la); 
	while (PgnParser_StartOf(self, 12)) {
	    if (PgnParser_StartOf(self, 13)) {
		PgnParser_Get(self);
	    } else {
		PgnParser_Get(self);
		PgnParser_SemErrT(self, "bad string in attributes"); 
	    }
	}
	PgnParser_Expect(self, 34);
	CcNode_SetPosition(p, PgnScanner_GetPosition(&self->scanner,
						     beg, self->t));
	PgnScanner_DecRef(&self->scanner, beg); 
    } else PgnParser_SynErr(self, 57);
}

static void
PgnParser_Condition(PgnParser_t * self)
{
    while (PgnParser_StartOf(self, 21)) {
	if (self->la->kind == 37) {
	    PgnParser_Get(self);
	    PgnParser_Condition(self);
	} else {
	    PgnParser_Get(self);
	}
    }
    PgnParser_Expect(self, 38);
}

static void
PgnParser_TokenTerm(PgnParser_t * self, CcGraph_t ** g)
{
    CcGraph_t * g2; 
    PgnParser_TokenFactor(self, g);
    while (PgnParser_StartOf(self, 9)) {
	PgnParser_TokenFactor(self, &g2);
	CcEBNF_MakeSequence(&self->lexical->base, *g, g2);
	CcGraph_Destruct(g2); 
    }
    if (self->la->kind == 45) {
	PgnParser_Get(self);
	PgnParser_Expect(self, 37);
	PgnParser_TokenExpr(self, &g2);
	CcLexical_SetContextTrans(self->lexical, g2->head);
	self->lexical->hasCtxMoves = TRUE;
	CcEBNF_MakeSequence(&self->lexical->base, *g, g2); 
	PgnParser_Expect(self, 38);
    }
}

static void
PgnParser_TokenFactor(PgnParser_t * self, CcGraph_t ** g)
{
    char * name = NULL; int kind; CcTransition_t trans; 
    *g = NULL; 
    if (self->la->kind == 1 || self->la->kind == 3 || self->la->kind == 5) {
	PgnParser_Sym(self, &name, &kind);
	if (kind == PgnParser_id) {
	    CcCharClass_t * c = CcLexical_FindCharClassN(self->lexical, name);
	    if (c == NULL) {
		PgnParser_SemErrT(self, "undefined name");
		c = CcLexical_NewCharClass(self->lexical, name, CcCharSet());
	    }
	    CcTransition_FromCharSet(&trans, c->set, trans_normal,
				     &self->lexical->classes);
	    *g = CcGraphP(CcEBNF_NewNode(&self->lexical->base,
					 CcNodeTrans(0, &trans)));
	    CcTransition_Destruct(&trans);
	    if (self->tokenString && self->tokenString != noString)
		CcFree(self->tokenString);
	    self->tokenString = (char *)noString;
	} else { /* PgnParser_str */
	    *g = CcLexical_StrToGraph(self->lexical, name, self->t);
	    if (self->tokenString == NULL) self->tokenString = CcStrdup(name);
	    else {
		if (self->tokenString != noString) CcFree(self->tokenString);
		self->tokenString = (char *)noString;
	    }
	}
	CcFree(name); 
    } else if (self->la->kind == 37) {
	PgnParser_Get(self);
	PgnParser_TokenExpr(self, g);
	PgnParser_Expect(self, 38);
    } else if (self->la->kind == 39) {
	PgnParser_Get(self);
	PgnParser_TokenExpr(self, g);
	PgnParser_Expect(self, 40);
	CcEBNF_MakeOption(&self->lexical->base, *g); 
    } else if (self->la->kind == 41) {
	PgnParser_Get(self);
	PgnParser_TokenExpr(self, g);
	PgnParser_Expect(self, 42);
	CcEBNF_MakeIteration(&self->lexical->base, *g); 
    } else PgnParser_SynErr(self, 58);
    if (*g == NULL) /* invalid start of TokenFactor */
      *g = CcGraphP(CcEBNF_NewNode(&self->lexical->base, CcNodeEps(0))); 
}

/*---- enable ----*/

static void
PgnParser_SynErr(PgnParser_t * self, int n)
{
    const char * s; char format[20];
    switch (n) {
    /*---- SynErrors ----*/
    case 0: s = "\"" "EOF" "\" expected"; break;
    case 1: s = "\"" "ident" "\" expected"; break;
    case 2: s = "\"" "number" "\" expected"; break;
    case 3: s = "\"" "string" "\" expected"; break;
    case 4: s = "\"" "badString" "\" expected"; break;
    case 5: s = "\"" "char" "\" expected"; break;
    case 6: s = "\"" "COMPILER" "\" expected"; break;
    case 7: s = "\"" "MEMBERS" "\" expected"; break;
    case 8: s = "\"" "CONSTRUCTOR" "\" expected"; break;
    case 9: s = "\"" "DESTRUCTOR" "\" expected"; break;
    case 10: s = "\"" "IGNORECASE" "\" expected"; break;
    case 11: s = "\"" "INDENTATIONS" "\" expected"; break;
    case 12: s = "\"" "CHARACTERS" "\" expected"; break;
    case 13: s = "\"" "TOKENS" "\" expected"; break;
    case 14: s = "\"" "PRAGMAS" "\" expected"; break;
    case 15: s = "\"" "COMMENTS" "\" expected"; break;
    case 16: s = "\"" "FROM" "\" expected"; break;
    case 17: s = "\"" "TO" "\" expected"; break;
    case 18: s = "\"" "NESTED" "\" expected"; break;
    case 19: s = "\"" "IGNORE" "\" expected"; break;
    case 20: s = "\"" "PRODUCTIONS" "\" expected"; break;
    case 21: s = "\"" "=" "\" expected"; break;
    case 22: s = "\"" "." "\" expected"; break;
    case 23: s = "\"" "END" "\" expected"; break;
    case 24: s = "\"" "SCHEME" "\" expected"; break;
    case 25: s = "\"" "SECTION" "\" expected"; break;
    case 26: s = "\"" "UPDATES" "\" expected"; break;
    case 27: s = "\"" "+" "\" expected"; break;
    case 28: s = "\"" "-" "\" expected"; break;
    case 29: s = "\"" ".." "\" expected"; break;
    case 30: s = "\"" "ANY" "\" expected"; break;
    case 31: s = "\"" "<" "\" expected"; break;
    case 32: s = "\"" ">" "\" expected"; break;
    case 33: s = "\"" "<." "\" expected"; break;
    case 34: s = "\"" ".>" "\" expected"; break;
    case 35: s = "\"" "|" "\" expected"; break;
    case 36: s = "\"" "WEAK" "\" expected"; break;
    case 37: s = "\"" "(" "\" expected"; break;
    case 38: s = "\"" ")" "\" expected"; break;
    case 39: s = "\"" "[" "\" expected"; break;
    case 40: s = "\"" "]" "\" expected"; break;
    case 41: s = "\"" "{" "\" expected"; break;
    case 42: s = "\"" "}" "\" expected"; break;
    case 43: s = "\"" "SYNC" "\" expected"; break;
    case 44: s = "\"" "IF" "\" expected"; break;
    case 45: s = "\"" "CONTEXT" "\" expected"; break;
    case 46: s = "\"" "(." "\" expected"; break;
    case 47: s = "\"" ".)" "\" expected"; break;
    case 48: s = "\"" "???" "\" expected"; break;
    case 49: s = "invalid \"" "Coco" "\""; break;
    case 50: s = "invalid \"" "TokenDecl" "\""; break;
    case 51: s = "this symbol not expected in \"" "TokenDecl" "\""; break;
    case 52: s = "this symbol not expected in \"" "AttrDecl" "\""; break;
    case 53: s = "this symbol not expected in \"" "SimSet" "\""; break;
    case 54: s = "this symbol not expected in \"" "Sym" "\""; break;
    case 55: s = "this symbol not expected in \"" "Term" "\""; break;
    case 56: s = "this symbol not expected in \"" "Factor" "\""; break;
    case 57: s = "this symbol not expected in \"" "Attribs" "\""; break;
    case 58: s = "this symbol not expected in \"" "TokenFactor" "\""; break;
    /*---- enable ----*/
    default:
	snprintf(format, sizeof(format), "error %d", n);
	s = format;
	break;
    }
    PgnParser_SemErr(self, self->la, "%s", s);
}

static const char * set[] = {
    /*---- InitSet ----*/
    /*    5    0    5    0    5    0    5    0    5    */
    "**.*.*........**...***........................*...", /* 0 */
    ".*******........***..****************************.", /* 1 */
    ".********.......***..****************************.", /* 2 */
    ".*********......***..****************************.", /* 3 */
    "**.*.*........**...****.......*....***.*.*.**.*...", /* 4 */
    "**.*.*........**...***.*......................*...", /* 5 */
    ".**********************.*************************.", /* 6 */
    ".*.*.*........**...**.........................*...", /* 7 */
    "...............*.****.*...............*.*.*.......", /* 8 */
    ".*.*.*...............................*.*.*........", /* 9 */
    ".*******************************.****************.", /* 10 */
    ".***.***************************.****************.", /* 11 */
    ".*********************************.**************.", /* 12 */
    ".***.*****************************.**************.", /* 13 */
    ".**********************************************.*.", /* 14 */
    ".***.*****************************************..*.", /* 15 */
    "......................*...............*.*.*.......", /* 16 */
    ".*.*.*................*.......*....**********.*...", /* 17 */
    ".*.*.*........................*.....**.*.*.**.*...", /* 18 */
    ".*.*.*........................*.....**.*.*.*..*...", /* 19 */
    "......................*............*..*.*.*.......", /* 20 */
    ".*************************************.**********."  /* 21 */
    /*---- enable ----*/
};
