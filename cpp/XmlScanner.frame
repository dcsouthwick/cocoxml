/*----------------------------------------------------------------------
Compiler Generator CocoXml/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

/*---- Begin ----*/
#if !defined(COCOXML_SCANNER_H__)
#define COCOXML_SCANNER_H__

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <vector>
#include <map>
#include <stack>

#include <expat.h>

using namespace std;

// io.h and fcntl are used to ensure binary read from streams on windows
#if _MSC_VER >= 1300
#include <io.h>
#include <fcntl.h>
#endif

#if _MSC_VER >= 1400
#define coco_swprintf swprintf_s
#elif _MSC_VER >= 1300
#define coco_swprintf _snwprintf
#elif defined __GNUC__
#define coco_swprintf swprintf
#else 
#error unknown compiler!
#endif 

#define COCO_WCHAR_MAX 65535
#define MIN_BUFFER_LENGTH 1024
#define MAX_BUFFER_LENGTH (64*MIN_BUFFER_LENGTH)
#define HEAP_BLOCK_SIZE (64*1024)
#define COCO_CPP_NAMESPACE_SEPARATOR L':'

// string handling, wide character
wchar_t* coco_string_create(const wchar_t *value);
wchar_t* coco_string_create(const wchar_t *value, int startIndex, int length);
wchar_t* coco_string_create_upper(const wchar_t* data);
wchar_t* coco_string_create_lower(const wchar_t* data);
wchar_t* coco_string_create_lower(const wchar_t* data, int startIndex, int dataLen);
wchar_t* coco_string_create_append(const wchar_t* data1, const wchar_t* data2);
wchar_t* coco_string_create_append(const wchar_t* data, const wchar_t value);
void  coco_string_delete(wchar_t* &data);
int   coco_string_length(const wchar_t* data);
bool  coco_string_endswith(const wchar_t* data, const wchar_t *value);
int   coco_string_indexof(const wchar_t* data, const wchar_t value);
int   coco_string_lastindexof(const wchar_t* data, const wchar_t value);
void  coco_string_merge(wchar_t* &data, const wchar_t* value);
bool  coco_string_equal(const wchar_t* data1, const wchar_t* data2);
int   coco_string_compareto(const wchar_t* data1, const wchar_t* data2);
int   coco_string_hash(const wchar_t* data);

// string handling, ascii character
wchar_t* coco_string_create(const char *value);
char* coco_string_create_char(const wchar_t *value);
void  coco_string_delete(char* &data);


/*---- Namespace Begin ----*/

struct wcharCmp {
	bool operator()(const wchar_t* s1, const wchar_t* s2 ) const{
        return coco_string_compareto(s1, s2) < 0;
	}
};

class Token  
{
/*---- Options ----*/
public:
    int kind;     // token kind
    int col;      // token column (starting at 1)
    int line;     // token line (starting at 1)
    wchar_t* val; // token value

    Token();
    ~Token();
};

class TagInfo {
public:
    int startToken;
    int endToken;
};

class XmlLangDefinition {
    vector<bool>            useVector;
    map<wchar_t*, TagInfo*, wcharCmp> Tags;
    map<wchar_t*, int, wcharCmp>      Attrs;
    map<wchar_t*, int, wcharCmp>      PInstructions;

    XmlLangDefinition();
    ~XmlLangDefinition();

    void AddTag(const wchar_t* Name, int StartToken, int EndToken);
    void AddAttr(const wchar_t* Name, int AttrToken);
    void AddProcessingInstruction(wchar_t* PIName, int PIToken);
};

class tagStackEle {
public:
    bool unknownNamespace;
    bool unknownTag;
    XmlLangDefinition *xldef;
};

class XmlScanner {
public:
    int eof;
/*---- Declarations ----*/
    map<const wchar_t*, XmlLangDefinition*, wcharCmp> XmlLangMap;
    stack<tagStackEle*>                    tagStack;
    vector<Token*>                         tokens;
    int                                    peek;
    FILE*                                  xmlstream;                                   
    XML_Parser                             xmlparser;
    
    XmlScanner (const wchar_t* fileName);
    void Init();
    int StartElement2Kind(wchar_t* NamespaceURI, wchar_t* TagName);
    int EndElement2Kind(wchar_t* NamespaceURI, wchar_t* TagName);
    int Attribute2Kind(wchar_t* NamespaceURI, wchar_t* AttrName);
    int ProcessingInstruction2Kind(wchar_t* PIName);

    /* expat callback function definition */
    void XMLCALL startElement(void *userData, const char *name, const char **atts);
    void XMLCALL endElementHandler(void *userData, const char *name, const char **atts);
    void XMLCALL charDataHandler(void *userData, const XML_Char *s, int len);
    void XMLCALL processingInstructionHandler(void *userData, const XML_Char *target, const XML_Char *data);
    void XMLCALL commentHandler(void *userData, const XML_Char *data);
    void XMLCALL cdataHandler(void *userData);

    void AppendToken(int kind, int linenumber, int lineposition, wchar_t* value);
    void AppendTokens();
    Token* Scan ();
    Token* Peek ();
    void ResetPeek();
}; // end Scanner

/*---- Namespace End ----*/

#endif // !defined(COCO_SCANNER_H__)

/*---- Implementation ----*/
/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*---- Begin ----*/

#include <memory.h>
#include <string.h>
#include "XmlScanner.hxx"


using namespace std;

// string handling, wide character

wchar_t* coco_string_create(const wchar_t* value) {
    wchar_t* data;
    int len = 0;
    if (value) { len = wcslen(value); }
    data = new wchar_t[len + 1];
    wcsncpy(data, value, len);
    data[len] = 0;
    return data;
}

wchar_t* coco_string_create(const wchar_t *value , int startIndex, int length) {
    int len = 0;
    wchar_t* data;

    if (value) { len = length; }
    data = new wchar_t[len + 1];
    wcsncpy(data, &(value[startIndex]), len);
    data[len] = 0;

    return data;
}

wchar_t* coco_string_create_upper(const wchar_t* data) {
    if (!data) { return NULL; }

    int dataLen = 0;
    if (data) { dataLen = wcslen(data); }

    wchar_t *newData = new wchar_t[dataLen + 1];

    for (int i = 0; i <= dataLen; i++) {
        if ((L'a' <= data[i]) && (data[i] <= L'z')) {
            newData[i] = data[i] + (L'A' - L'a');
        }
        else { newData[i] = data[i]; }
    }

    newData[dataLen] = L'\0';
    return newData;
}

wchar_t* coco_string_create_lower(const wchar_t* data) {
    if (!data) { return NULL; }
    int dataLen = wcslen(data);
    return coco_string_create_lower(data, 0, dataLen);
}

wchar_t* coco_string_create_lower(const wchar_t* data, int startIndex, int dataLen) {
    if (!data) { return NULL; }

    wchar_t* newData = new wchar_t[dataLen + 1];

    for (int i = 0; i <= dataLen; i++) {
        wchar_t ch = data[startIndex + i];
        if ((L'A' <= ch) && (ch <= L'Z')) {
            newData[i] = ch - (L'A' - L'a');
        }
        else { newData[i] = ch; }
    }
    newData[dataLen] = L'\0';
    return newData;
}

wchar_t* coco_string_create_append(const wchar_t* data1, const wchar_t* data2) {
    wchar_t* data;
    int data1Len = 0;
    int data2Len = 0;

    if (data1) { data1Len = wcslen(data1); }
    if (data2) {data2Len = wcslen(data2); }

    data = new wchar_t[data1Len + data2Len + 1];

    if (data1) { wcscpy(data, data1); }
    if (data2) { wcscpy(data + data1Len, data2); }

    data[data1Len + data2Len] = 0;

    return data;
}

wchar_t* coco_string_create_append(const wchar_t *target, const wchar_t appendix) {
    int targetLen = coco_string_length(target);
    wchar_t* data = new wchar_t[targetLen + 2];
    wcsncpy(data, target, targetLen);
    data[targetLen] = appendix;
    data[targetLen + 1] = 0;
    return data;
}

void coco_string_delete(wchar_t* &data) {
    delete [] data;
    data = NULL;
}

int coco_string_length(const wchar_t* data) {
    if (data) { return wcslen(data); }
    return 0;
}

bool coco_string_endswith(const wchar_t* data, const wchar_t *end) {
    int dataLen = wcslen(data);
    int endLen = wcslen(end);
    return (endLen <= dataLen) && (wcscmp(data + dataLen - endLen, end) == 0);
}

int coco_string_indexof(const wchar_t* data, const wchar_t value) {
    const wchar_t* chr = wcschr(data, value);

    if (chr) { return (chr-data); }
    return -1;
}

int coco_string_lastindexof(const wchar_t* data, const wchar_t value) {
    const wchar_t* chr = wcsrchr(data, value);

    if (chr) { return (chr-data); }
    return -1;
}

void coco_string_merge(wchar_t* &target, const wchar_t* appendix) {
    if (!appendix) { return; }
    wchar_t* data = coco_string_create_append(target, appendix);
    delete [] target;
    target = data;
}

bool coco_string_equal(const wchar_t* data1, const wchar_t* data2) {
    return wcscmp( data1, data2 ) == 0;
}

int coco_string_compareto(const wchar_t* data1, const wchar_t* data2) {
    return wcscmp(data1, data2);
}

int coco_string_hash(const wchar_t *data) {
    int h = 0;
    if (!data) { return 0; }
    while (*data != 0) {
        h = (h * 7) ^ *data;
        ++data;
    }
    if (h < 0) { h = -h; }
    return h;
}

// string handling, ascii character

wchar_t* coco_string_create(const char* value) {
    int len = 0;
    if (value) { len = strlen(value); }
    wchar_t* data = new wchar_t[len + 1];
    for (int i = 0; i < len; ++i) { data[i] = (wchar_t) value[i]; }
    data[len] = 0;
    return data;
}

char* coco_string_create_char(const wchar_t *value) {
    int len = coco_string_length(value);
    char *res = new char[len + 1];
    for (int i = 0; i < len; ++i) { res[i] = (char) value[i]; }
    res[len] = 0;
    return res;
}

void coco_string_delete(char* &data) {
    delete [] data;
    data = NULL;
}


/*---- Namespace Begin ----*/

Token::Token() {
    kind = 0;
    col  = 0;
    line = 0;
    val  = NULL;
}

Token::~Token() {
    coco_string_delete(val);
}

XmlLangDefinition::XmlLangDefinition() {
    useVector.resize(Token.numOptions);
}

void XmlLangDefinition::AddTag(const wchar_t* Name, int StartToken, int EndToken) {
    TagInfo *tinfo = new TagInfo();
    tinfo->startToken = StartToken;
    tinfo->endToken = EndToken;
    Tags.insert(make_pair(Name, tinfo));
}

void XmlLangDefinition::AddAttr(const wchar_t* Name, int AttrToken) {
    Attrs.insert(make_pair(Name, AttrToken));
}

void XmlLangDefinition::AddProcessingInstruction(const wchar_t* PIName, int PIToken) {
    PInstructions.insert(make_pair(PIName, PIToken));
}

XmlScanner::XmlScanner (const wchar_t* fileName) {
    char *chFileName = coco_string_create_char(fileName);
    xmlstream = fopen(chFileName, "r");
    if(xmlstream){
       Init();
    }else{
       throw new FatalError("Can not open file " + fileName);
    }
}

XmlScanner::~XmlScanner() {
    XML_ParserFree(xmlparser);
    if(xmlstream) fclose(xmlstream);
}

void XmlScanner::Init() {
    xmlparser = XML_ParserCreate(NULL);
    XML_SetUserData(parser, this);

    XML_SetElementHandler(xmlparser, startElementHandler, endElementHandler);

    XML_SetCharacterDataHandler(parser, charDataHandler);

    XML_SetProcessingInstructionHandler(parser, processingInstructionHandler);
    
    XML_SetCommentHandler(parser, commentHandler);

    XML_SetStartCdataSectionHandler(parser, cdataHandler);

    eof = 0;
    peek = 0;

/*---- Initialization ----*/
    tagStackEle *tsEle = new tagStackEle();
    tsEle->unknownNamespace = false;
    tsEle->unknownTag = false;
    tsEle->xldef = XmlLangMap[coco_string_create("")];
    tagStack.push(tsEle);
}

int XmlScanner::StartElement2Kind(const wchar_t* NamespaceURI, const wchar_t* TagName) {
    tagStackEle *curEle = tagStack.top();
    tagStackEle *newEle = new tagStackEle();

    if (!XmlLangMap.find(NamespaceURI)) {
        newEle->unknownNamespace = true;
        newEle->unknownTag = false;
        newEle->xldef = curEle->xldef;
        tagStack.push(newEle);
        return useKindVector[(int)Token.Options.UNKNOWN_NAMESPACE];
    }
    newEle->unknownNamespace = false;
    newEle->xldef = XmlLangMap[NamespaceURI];
    if (!newEle.xldef->Tags.find(TagName)) {
        newEle->unknownTag = true;
        tagStack.push(newEle);
        return useKindVector[(int)Token.Options.UNKNOWN_TAG];
    }
    newEle->unknownTag = false;
    tagStack.push(newEle);
    return newEle->xldef->Tags[TagName].startToken;
}

int XmlScanner::EndElement2Kind(const wchar_t* NamespaceURI, const wchar_t* TagName) {
    tagStackEle* curEle = tagStack.pop();

    if (curEle->unknownNamespace) {
        return useKindVector[(int)Token.Options.END_UNKNOWN_NAMESPACE];
    }
    if (curEle->unknownTag)
        return useKindVector[(int)Token.Options.END_UNKNOWN_TAG];
    return curEle->xldef->Tags[TagName].endToken;
}

int XmlScanner::Attribute2Kind(const wchar_t* NamespaceURI, const wchar_t* AttrName) {
    XmlLangDefinition *xldef;
    tagStackEle *curEle = tagStack.top();

    if (NamespaceURI == "") xldef = curEle->xldef;
    else if (!XmlLangMap.find(NamespaceURI))
        return useKindVector[(int)Token.Options.UNKNOWN_ATTR_NAMESPACE];
    else xldef = XmlLangMap[NamespaceURI];
    if (!xldef->Attrs.find(AttrName))
        return useKindVector[(int)Token.Options.UNKNOWN_ATTR];
    return xldef->Attrs[AttrName];
}

int XmlScanner::ProcessingInstruction2Kind(const wchar_t* PIName) {
    tagStackEle *curEle = tagStack.top();

    if (!curEle->xldef->PInstructions.find(PIName))
        return useKindVector[(int)Token.Options.UNKNOWN_PROCESSING_INSTRUCTION];
    return curEle->xldef->PInstructions[PIName];
}

void XMLCALL XmlScanner::startElement(void *userData, const char *name, const char **atts)
{
    wchar_t *wname = coco_string_create(name);
    wchar_t *namespace=NULL, *elename=NULL;
    inx = coco_string_indexof(name, L':');
    if(inx>0){
        /* have namespace indication */
        namespace = coco_string_create(wname, 0, inx+1);
        elename = coco_string_create(wname, inx+1, strlen(name)-(inx+1));
    }
    fwprintf("get namespace:%ls, start elename:%ls\n", namespace, elename);
    kind = StartElement2Kind(namespace, elename);
    AppendToken(kind, 0, 0, elename);
    
    inx = 0;
    while(*(attrs+inx)){
        wchar_t *wkey=0, wchar_t *wvalue=0;

        wkey = coco_string_create(attrs+0);
        wvalue = coco_string_create(attrs+1);
            fwprintf("\t key:%ls, value:%ls\n", wkey, wvalue);
        inx += 2;
        
        kind = Attribute2Kind(namespace, wkey);

        AppendToken(kind, 0/*line number*/, 0/*line position*/, wvalue);
        coco_string_delete(wkey);
        coco_string_delete(wvalue);        
    }
    
    coco_string_delete(wname);
    coco_string_delete(namespace);
    coco_string_delete(elename);
}

void XMLCALL XmlScanner::endElementHandler(void *userData, const char *name, const char **atts)
{
    wchar_t *wname = coco_string_create(name);
    wchar_t *namespace=NULL, *elename=NULL;
    inx = coco_string_indexof(name, L':');
    if(inx>0){
        /* have namespace indication */
        namespace = coco_string_create(wname, 0, inx+1);
        elename = coco_string_create(wname, inx+1, strlen(name)-(inx+1));
    }
    fwprintf("get namespace:%ls, end elename:%ls\n", namespace, elename);
    kind = EndElement2Kind(namespace, elename);
    AppendToken(kind, 0, 0, elename);

    coco_string_delete(wname);
    coco_string_delete(namespace);
    coco_string_delete(elename);
}

void XMLCALL XmlScanner::charDataHandler(void *userData, const XML_Char *s, int len)
{
    int opt;
    tagStackEle* curEle = tagStack->top();
    char *buf;
    wchar_t *value;
    
    buf = malloc(len+1);
    snprintf(buf, len, "%s", s);
    value = coco_string_create(data);

    if (curEle->unknownNamespace) opt = Token.Options.UNS_TEXT;
    else if (curEle->unknownTag) opt = Token.Options.UT_TEXT;
    else opt = Token.Options.TEXT;
    
    kind = curEle->xldef->useVector[(int)opt] ? useKindVector[(int)opt] : -1;

    AppendToken(kind, 0, 0, vlaue);
    
    coco_string_delete(value);
}

void XMLCALL XmlScanner::processingInstructionHandler(void *userData, const XML_Char *target, const XML_Char *data)
{
    wchar_t *wtarget, *wdata;
    
    wtarget = coco_string_create(target);
    wdata = coco_string_create(data);
    
    kind = ProcessingInstruction2Kind(target)
    AppendToken(kind, 0, 0, wdata);

    coco_string_delete(wtarget);
    coco_string_delete(wdata);
}

void XMLCALL XmlScanner::commentHandler(void *userData, const XML_Char *data)
{
    int opt;
    tagStackEle* curEle = tagStack->top();
    wchar_t *value = coco_string_create(data);

    if (curEle->unknownNamespace) opt = Token.Options.UNS_CDATA;
    else if (curEle->unknownTag) opt = Token.Options.UT_CDATA;
    else opt = Token.Options.CDATA;
    
    kind = curEle->xldef->useVector[(int)opt] ? useKindVector[(int)opt] : -1;
    
    AppendToken(kind, 0, 0, vlaue);
    
    coco_string_delete(value);
}

void XMLCALL XmlScanner::cdataHandler(void *userData)
{
    int opt;
    tagStackEle* curEle = tagStack->top();
    wchar_t *value = coco_string_create(data);

    if (curEle->unknownNamespace) opt = Token.Options.UNS_CDATA;
    else if (curEle->unknownTag) opt = Token.Options.UT_CDATA;
    else opt = Token.Options.CDATA;

    kind = curEle->xldef->useVector[(int)opt] ? useKindVector[(int)opt] : -1;
    
    AppendToken(kind, 0, 0, vlaue);
    
    coco_string_delete(value);
}

void XmlScanner::AppendToken(int line, int linenumber, int lineposition, wchar_t* value)
{    
    Token* new_token = NULL;

    new_token = new Token();
    new_token->kind = kind;
    new_token->line = linenumber;
    new_token->col = lineposition;
    new_token->val = value?coco_string_create(value):NULL;
    tokens.push_back(new_token);
}

void XmlScanner::AppendTokens() {
    if(eof) return;

    for (;;) {
        int bytes_read;
        void *buff = XML_GetBuffer(p, BUFF_SIZE);
        if (buff == NULL) {
            /* handle error */
        }

        bytes_read = fread(buff, 1, BUFF_SIZE, xmlstream);
        if (bytes_read < 0) {
            /* handle error */
        }

        if (! XML_ParseBuffer(p, bytes_read, bytes_read == 0)) {
            /* handle parse error */
        }

        if (bytes_read == 0)
            break;
        }
    }

    AppendToken(eofSym, 0, 0, NULL);
    eof = 1;
}

Token XmlScanner::Scan () {
    Token* token;
    if (tokens->size() == 0) AppendTokens();
    token = tokens.front();
    Tokens.Pop_front();
    return token;
}

Token XmlScanner::Peek () {
    if (peek == tokens.size()) AppendTokens();
    return tokens[peek ++];
}

void XmlScanner::ResetPeek () { peek = 0; }

/*---- Namespace End ----*/

/*---- $$$ ----*/
