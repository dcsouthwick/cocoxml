/*-------------------------------------------------------------------------
 Coco.ATG -- Attributed Grammar
 Compiler Generator Coco/R,
 Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
 extended by M. Loeberbauer & A. Woess, Univ. of Linz
 with improvements by Pat Terry, Rhodes University.
 ported to C by Charles Wang <charlesw123456@gmail.com>

 This program is free software; you can redistribute it and/or modify it 
 under the terms of the GNU General Public License as published by the 
 Free Software Foundation; either version 2, or (at your option) any 
 later version.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 for more details.

 You should have received a copy of the GNU General Public License along 
 with this program; if not, write to the Free Software Foundation, Inc., 
 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

 As an exception, it is allowed to write an extension of Coco/R that is
 used as a plugin in non-free software.

 If not otherwise stated, any source code generated by Coco/R (other than 
 Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------
 compile with:
   Coco Coco.ATG -namespace Coco
-------------------------------------------------------------------------*/

#include "Tab.h"
#include "DFA.h"
#include "ParserGen.h"

COMPILER Coco

    int           id;
    int           str;

    FILE        * trace;   // other Coco objects referenced in this ATG
    Tab_t       * tab;
    DFA_t       * dfa;
    ParserGen_t * pgen;

    Bool_t        genScanner;
    const char  * tokenString;  // used in declarations of literal tokens
    const char  * noString;     // used in declarations of literal tokens

    void Parser_InitDeclarations(Parser_t * self) {
	self->id  = 0;
	self->str = 1;
	self->tokenString = NULL;
	self->noString = CocoStrdup(L"-none-");
    }

/*-------------------------------------------------------------------------*/

CHARACTERS
    letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
    digit     = "0123456789".
    cr        = '\r'.
    lf        = '\n'.
    tab       = '\t'.
    stringCh  = ANY - '"' - '\\' - cr - lf.
    charCh    = ANY - '\'' - '\\' - cr - lf.
    printable =  '\x20' .. '\x7e'.
    hex       = "0123456789abcdef".

TOKENS
    ident     = letter { letter | digit }.
    number    = digit { digit }.
    string    = '"' { stringCh | '\\' printable } '"'.
    badString = '"' { stringCh | '\\' printable } (cr | lf).
    char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
    ddtSym    = '$' { digit | letter }.  (. tab->SetDDT(la->val); .)

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

Coco                            (. Symbol_t  * sym;
				   Graph_t   * g, * g1, * g2;
				   char      * gramName = NULL;
				   CharSet_t * s; 
                                   Parser_InitDeclarations(self); .)
=
                                (. int beg = self->la->pos; .)
  { // this section can be used
    // for #include statements
    ANY
  }                             (. if (self->la->pos != self->beg) {
	                               self->pgen->usingPos = Position(NULL, beg, self->t->pos - beg + strlen(self->t->val), 0);
                                   }
                                .)

  "COMPILER"                    (. self->genScanner = TRUE;
                                   self->tab->ignored = CharSet(NULL); .)
  ident                         (. gramName = strdupa(self->t->val);
                                   beg = self->la->pos;
                                 .)
  { ANY }                       (. self->tab->semDeclPos = Position(NULL, beg, self->la->pos-beg, 0); .)
  [ "IGNORECASE"                (. self->dfa->ignoreCase = TRUE; .) ]   /* pdt */
  [ "CHARACTERS" { SetDecl }]
  [ "TOKENS"  { TokenDecl<node_t> }]
  [ "PRAGMAS" { TokenDecl<node_pr> }]
  { "COMMENTS"                  (. Bool_t nested = FALSE; .)
    "FROM" TokenExpr<&g1> 
    "TO" TokenExpr<&g2>
    [ "NESTED"                  (. nested = TRUE; .)
    ]                           (. DFA_NewComment(self->dfa, g1->l, g2->l, nested); .)
  }
  { "IGNORE" Set<&s>            (. BitArray_Or(self->tab->ignored, s); .)
  }

  SYNC 
  "PRODUCTIONS"                 (. if (self->genScanner) DFA_MakeDeterministic(self->dfa);
                                       Tab_DeleteNodes(self->tab);
                                 .)
  { ident                       (. sym = Tab_FindSym(self->tab, self->t->val);
                                   Bool_t undef = (sym == NULL);
				   if (undef) {
				       sym = Tab_NewSym(self->tab, node_nt, self->t->val, self->t->line);
                                   } else {
				       if (sym->typ == node_nt) {
					   if (sym->graph != NULL) Parser_SemErr(self, "name declared twice");
				       } else {
					   Parser_SemErr(self, "this symbol kind not allowed on left side of production");
				       }
				       sym->line = self->t->line;
                                   }
                                   Bool_t noAttrs = (sym->attrPos == NULL);
                                   sym->attrPos = NULL;
                                 .)
    [ AttrDecl<sym> ]           (. if (!undef)
                                       if (noAttrs != (sym->attrPos == NULL))
                                           Parser_SemErr(self, "attribute mismatch between declaration and use of this symbol");
                                 .)
    [ SemText<.&sym->semPos.> ] WEAK
    '='
    Expression<&g>              (. sym->graph = g->l;
				   Tab_Finish(self, g);
                                .)
                                WEAK
    '.'
  }
  "END" ident                   (. if (!strcmp(gramName, self->t->val))
				       Parser_SemErr(self, "name does not match grammar name");
				   self->tab->gramSy = Tab_FindSym(self->tag, gramName);
				   if (self->tab->gramSy == NULL) {
                                       Parser_SemErr(self, "missing production for grammar name");
                                   } else {
                                       sym = self->tab->gramSy;
                                       if (sym->attrPos != NULL)
					   Parser_SemErr(self, "grammar symbol must not have attributes");
                                   }
				   self->tab->noSym = Tab_NewSym(self->tab, node_t, "???", 0); // noSym gets highest number
                                   Tab_SetupAnys(self->tab);
                                   Tab_RenumberPragmas(self->tab);
                                   if (self->tab->ddt[2]) Tab_PrintNodes(self->tab);
                                   if (self->errors->count == 0) {
                                       fprintf(stderr, "checking\n");
				       Tab_CompSymbolSets(self->tab);
				       if (self->tab->ddt[7]) Tab_XRef(self->tab);
				       if (Tab_GrammarOk(self->tab)) {
					   fprintf(stderr, "parser");
					   ParserGen_WriteParser(self->pgen);
					   if (self->genScanner) {
					       fprintf(stderr, " + scanner");
					       DFA_WriteScanner(self->dfa);
					       if (self->tab->ddt[0]) DFA_PrintStates(self->dfa);
					   }
					   fprintf(stderr, " generated\n");
					   if (self->tab->ddt[8]) ParserGen_WriteStatistics(self->pgen);
				       }
                                   }
                                   if (self->tab->ddt[6]) Tab_PrintSymbolTable(self->tab);
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

SetDecl                         (. CharSet_t * s; .)
=
  ident                         (. char * name = CocoStrdup(self->t->val);
				   CharClass_t * c = Tab_FindCharClass(self->tab, name);
				   if (c != NULL) Parser_SemErr(self, "name declared twice");
                                 .)
  '=' Set<&s>                   (. if (CharSet_Elements(s) == 0)
				       Parser_SemErr(self, "character set must not be empty");
				   Tab_NewCharClass(self->tab, name, s);
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

Set<CharSet_t ** s>             (. CharSet_t * s2; .)
=
  SimSet<&s>
  { '+' SimSet<&s2>             (. CharSet_Or(*s, s2); .)
  | '-' SimSet<&s2>             (. CharSet_Subtract(*s, s2); .)
  }
.

/*------------------------------------------------------------------------------------*/

SimSet<CharSet ** s>            (. int n1, n2; .)
=                               (. *s = CharSet(NULL); .)
( ident                         (. CharClass_t * c = Tab_FindCharClass(self, t->val);
				   if (c == NULL) Parser_SemErr(self, "undefined name");
				   else CharSet_Or(*s, c->set);
                                .)
| string                        (.
                                   int ch;
				   char * cur, * name;
				   cur = name = Unescape(self->t->val);
				   while (*cur) {
				       ch = UTF8Get(&cur, EoF);
				       if (self->dfa->ignoreCase) {
					   ch = tolower(ch);
				       }
				       CharSet_Set(*s, ch);
                                   }
				   CocoFree(name);
                                .)
| Char<&n1>                     (. CharSet_Set(*s, n1); .)
  [ ".." Char<&n2>              (. int idx;
				   for (idx = n1; idx <= n2; ++idx)
				       CharSet_Set(*s, i);
				.)
  ]
| "ANY"                         (. *s = CharSet();
                                   CharSet_Fill(*s, COCO_WCHAR_MAX);
			        .)
)
.

/*--------------------------------------------------------------------------------------*/

Char<int * n>
=
  char                          (. *n = 0;
  				   char * cur, * name;
				   cur = name = Unescape(self->t->val);
				   *n = UTF8Get(&cur, EoF);
				   if (*cur != 0)
				       Parser_SemErr(self, "unacceptable character value: %s", self->t->val);
				   CocoFree(name);
				   if (self->dfa->ignoreCase) *n = tolower(*n);
                                .)
.

/*------------------------------------------------------------------------------------*/

TokenDecl<int typ>              (. char * name = NULL;
				   int kind;
				   Symbol_t * sym;
				   Graph_t * g; .)
=
  Sym<&name, &kind>             (. sym = Tab_FindSym(self->tab, name);
				   if (sym != NULL) {
				       Parser_SemErr(self->parser, "name %s declared twice", name);
                                   } else {
				       sym = Tab_NewSym(self->tab, typ, name, t->line);
				       sym->tokenKind = symbol_fixedToken;
                                   }
                                   self->tokenString = NULL;
                                .)
  SYNC
  ( '=' TokenExpr<&g> '.'       (. if (kind == self->str)
				       Parser_SemErr(self->parser, "a literal must not be declared with a structure");
				   Tab_Finish(self->tab, g);
				   if (self->tokenString == NULL || !strcmp(self->tokenString, self->noString)) {
				       DFA_ConvertToStates(self->dfa, g->l, sym);
                                   } else { // TokenExpr is a single string
				       if (HashTable_Get(&self->tab->literals, self->tokenString) != NULL)
					   Parser_SemErr(self->parser, "token string %s declared twice", self->tokenString);
				       HashTable_Set(&self->tab->literals, self->tokenString, sym);
				       DFA_MatchLiteral(self->dfa, self->tokenString, sym);
                                   }
                                .)
  |                             (. if (kind == self->id) self->genScanner = false;
				   else DFA_MatchLiteral(self->dfa, sym->name, sym);
                                .)
  )
  [ SemText<.&sym->semPos.>     (. if (typ != node_pr) Parser_SemErr(self, "semantic action not allowed here"); .)
  ]
.

/*------------------------------------------------------------------------------------*/

AttrDecl<Symbol_t * sym>
=
  '<'                           (. int beg = self->la->pos; int col = self->la->col; .)
  { ANY
  | badString                   (. Parser_SemErr(self, "bad string in attributes"); .)
  }
  '>'                           (. if (self->t->pos > beg)
				       sym->attrPos = Position(NULL, beg, self->t->pos - beg, col); .)
| "<."                          (. int beg = self->la->pos; int col = self->la->col; .)
  { ANY
  | badString                   (. Parser_SemErr(self, "bad string in attributes"); .)
  }
  ".>"                          (. if (self->t->pos > beg)
                                     sym->attrPos = Position(NULL, beg, self->t->pos - beg, col); .)
.

/*------------------------------------------------------------------------------------*/

Expression<Graph_t ** g>        (. Graph_t * g2; .)
= 
  Term<&g>                      (. Bool_t first = TRUE; .)
  {                             WEAK
    '|'
  Term<&g2>                     (. if (first) { Tab_MakeFirstAlt(self->tab, *g); first = false; }
                                   Tab_MakeAlternative(self->tab, *g, g2);
                                .)
  }
.

/*------------------------------------------------------------------------------------*/

Term<Graph_t ** g>              (. Graph_t * g2; Node_t * rslv = NULL; *g = NULL; .)
=
  ( [                           (. rslv = Tab_NewNode(self->tab, node_rslv, NULL, self->la->line); .)
  Resolver<.&rslv->pos.>        (. *g = Graph(NULL, rslv); .)
  ]
  Factor<&g2>                   (. if (rslv != NULL) Tab_MakeSequence(self->tab, *g, g2);
                                   else *g = g2; .)
  { Factor<&g2>                 (. Tab_MakeSequence(self->tab, *g, g2); .)
  }
|                               (. *g = GraphTSL(NULL, Tab_NewNode(self->tab, node_eps, NULL, 0)); .)
)                               (. if (g == NULL) // invalid start of Term
				     *g = GraphTSL(NULL, Tab_NewNode(self->tab, node_eps, NULL, 0)); .)
.

/*------------------------------------------------------------------------------------*/

Factor<Graph_t ** g>            (. char * name = NULL;
				   int kind;
				   Position_t * pos;
				   Bool_t weak = FALSE; 
                                   *g = NULL;
                                .)
=
( [ "WEAK"                      (. weak = TRUE; .)
  ]
  Sym<&name, &kind>             (. Symbol_t * sym = Tab_FindSym(self->tab, name);
                                   if (sym == NULL && kind == str)
                                       sym = (Symbol*)HashTable_Get(&self->tab->literals, name);
                                   Bool_t undef = (sym == NULL);
                                   if (undef) {
                                       if (kind == id) {
                                           sym = Tab_NewSym(self->tab, node_nt, name, 0);  /* forward nt */
				       } else if (self->genScanner) {
					   sym = Tab_NewSym(self->tab, node_t, name, self->t->line);
					   DFA_MatchLiteral(self->dfa, sym->name, sym);
				       } else {  /* undefined string in production */
					   Parser_SemErr(self, "undefined string in production");
					   sym = tab->eofSy;  /* dummy */
				       }
                                   }
                                   int typ = sym->typ;
                                   if (typ != node_t && typ != node_nt)
                                       Parser_SemErr(self, "this symbol kind is not allowed in a production");
                                   if (weak)
				       if (typ == node_t) typ = node_wt;
				       else Parser_SemErr(self, "only terminals may be weak");
				   Node_t * p = Tab_NewNode(self->tab, typ, sym, t->line);
				   *g = GraphP(NULL, p);
                                .)
  [ Attribs<p>                  (. if (kind != self->id) Parser_SemErr(self, "a literal must not have attributes"); .)
  ]                             (. if (undef)
                                       sym->attrPos = p->pos;  /* dummy */
                                   else if ((p->pos == NULL) != (sym->attrPos == NULL))
                                       Parser_SemErr(self, "attribute mismatch between declaration and use of this symbol");
                                .)
| '(' Expression<&g> ')'
| '[' Expression<&g> ']'        (. Tab_MakeOption(self->tab, g); .)
| '{' Expression<&g> '}'        (. Tab_MakeIteration(self->tab, g); .)
| SemText<&pos>                 (. Node_t * p = Tab_NewNodeTSL(self->tab, node_sem, NULL, 0);
                                   p->pos = pos;
				   *g = GraphP(NULL, p);
                                .)
| "ANY"                         (. Node_t * p = Tab_NewNodeTSL(self->tab, node_any, NULL, 0);  /* p.set is set in Tab_SetupAnys */
				   *g = GraphP(NULL, p);
                                .)
| "SYNC"                        (. Node_t * p = Tab_NewNodeTSL(self->tab, node_sync, NULL, 0);
				   *g = GraphP(NULL, p);
                                .)
)                               (. if (g == NULL) // invalid start of Factor
				   *g = GraphP(NULL, Tab_NewNode(self->tab, node_eps, NULL, 0));
                                .)
.

/*------------------------------------------------------------------------------------*/

Resolver<Position_t ** pos>   
=
  "IF" "("                       (. int beg = self->la->pos; int col = self->la->col; .)
  Condition                      (. *pos = Position(NULL, beg, self->t->pos - beg, col); .)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

TokenExpr<Graph_t ** g>         (. Graph_t * g2; .)
=
  TokenTerm<&g>                 (. Bool first = TRUE; .)
  {                             WEAK
    '|'
    TokenTerm<&g2>              (. if (first) { Tab_MakeFirstAlt(self->tab, *g); first = false; }
                                   Tab_MakeAlternative(self->tab, *g, g2);
                                .)
  }
.

/*------------------------------------------------------------------------------------*/

TokenTerm<Graph_t ** g>         (. Graph_t * g2; .)
=
  TokenFactor<&g>
  { TokenFactor<&g2>            (. Tab_MakeSequence(self->tab, *g, g2); .)
  }
  [ "CONTEXT"
    '(' TokenExpr<&g2>          (. Tab_SetContextTrans(self->tab, g2->l);
				   self->dfa->hasCtxMoves = TRUE;
				   Tab_MakeSequence(self->tab, *g, g2); .)
    ')'
  ]
.

/*------------------------------------------------------------------------------------*/

TokenFactor<Graph_t ** g>       (. char * name = NULL; int kind; .)
=
                                (. *g = NULL; .)
( Sym<&name, &kind>             (. if (kind == self->id) {
	                               CharClass_t * c = Tab_FindCharClass(self->tab, name);
                                       if (c == NULL) {
					   Parser_SemErr(self, "undefined name");
					   c = Tab_NewCharClass(self->tab, name, CharSet(NULL));
				       }
				       Node_t * p = Tab_NewNodeTSL(self->tab, node_clas, NULL, 0);
				       p->val = c->n;
				       *g = GraphP(NULL, p);
				       self->tokenString = CocoStrdup(self->noString);
                                   } else { /* str */
	                               *g = Tab_StrToGraph(self->tab, name);
				       if (self->tokenString == NULL) self->tokenString = CocoStrdup(name);
				       else self->tokenString = CocoStrdup(self->noString);
                                   }
                                .)
| '(' TokenExpr<&g> ')'
| '[' TokenExpr<&g> ']'         (. Tab_MakeOption(self->tab, *g); .)
| '{' TokenExpr<&g> '}'         (. Tab_MakeIteration(self->tab, *g); .)
)                               (. if (*g == NULL) /* invalid start of TokenFactor */
                                     *g = GraphP(NULL, Tab_NewNodeTSL(self->tab, node_eps, NULL, 0)); .)
.

/*------------------------------------------------------------------------------------*/

Sym<char ** name, int * kind>
=                               (. *name = CocoStrdup("???"); *kind = id; .)
( ident                         (. *kind = id; CocoFree(*name); *name = CocoStrdup(self->t->val); .)
| (string                       (. CocoFree(*name); *name = CocoStrdup(self->t->val); .)
  | char                        (. *name = Unescape(self->t->val); .)
  )                             (. *kind = self->str;
                                   if (self->dfa->ignoreCase) {
				       for (idx = 0; idx < strlen(*name); ++idx)
					   *name[idx] = tolower(*name[idx]);
				       if (strchr(name, ' '))
					   Parser_SemErr(self, "literal tokens \"%s\" must not contain blanks", name);
				.)
)
.

/*------------------------------------------------------------------------------------*/

Attribs<Node_t * p>
=
  '<'                           (. int beg = self->la->pos; int col = self->la->col; .)
  { ANY 
  | badString                   (. Parser_SemErr(self, "bad string in attributes"); .)
  }
  '>'                           (. if (self->t->pos > beg) p->pos = Position(NULL, beg, self->t->pos - beg, col); .)
| "<."                          (. int beg = self->la->pos; int col = self->la->col; .)
  { ANY 
  | badString                   (. Parser_SemErr(self, "bad string in attributes"); .)
  }
  ".>"                          (. if (self->t->pos > beg) p->pos = Position(NULL, beg, t->pos - beg, col); .)
.

/*------------------------------------------------------------------------------------*/

SemText<Position_t ** pos>
=
  "(."                          (. int beg = self->la->pos; int col = self->la->col; .)
  { ANY
  | badString                   (. Parser_SemErr(self, "bad string in semantic action"); .)
  | "(."                        (. Parser_SemErr(self, "missing end of previous semantic action"); .)
  }
  ".)"                          (. *pos = Position(NULL, beg, t->pos - beg, col); .)
.

/*------------------------------------------------------------------------------------*/
  
END Coco.
