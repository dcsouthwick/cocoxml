/*-------------------------------------------------------------------------
 Coco.ATG -- Attributed Grammar
 Compiler Generator Coco/R,
 Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
 extended by M. Loeberbauer & A. Woess, Univ. of Linz
 with improvements by Pat Terry, Rhodes University.
 ported to C by Charles Wang <charlesw123456@gmail.com>

 This program is free software; you can redistribute it and/or modify it 
 under the terms of the GNU General Public License as published by the 
 Free Software Foundation; either version 2, or (at your option) any 
 later version.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 for more details.

 You should have received a copy of the GNU General Public License along 
 with this program; if not, write to the Free Software Foundation, Inc., 
 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

 As an exception, it is allowed to write an extension of Coco/R that is
 used as a plugin in non-free software.

 If not otherwise stated, any source code generated by Coco/R (other than 
 Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------
 compile with:
   Coco Coco.ATG -namespace Coco
-------------------------------------------------------------------------*/

#include "Tab.h"
#include "DFA.h"
#include "ParserGen.h"

COMPILER Coco

    int           id;
    int           str;

    FILE        * trace;   // other Coco objects referenced in this ATG
    Tab_t       * tab;
    DFA_t       * dfa;
    ParserGen_t * pgen;

    Bool_t        genScanner;
    const char  * tokenString;  // used in declarations of literal tokens
    const char  * noString;     // used in declarations of literal tokens

    void Parser_InitDeclarations(Parser_t * self) {
	self->id  = 0;
	self->str = 1;
	self->tokenString = NULL;
	self->noString = CocoStrdup(L"-none-");
    }

/*-------------------------------------------------------------------------*/

CHARACTERS
    letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
    digit     = "0123456789".
    cr        = '\r'.
    lf        = '\n'.
    tab       = '\t'.
    stringCh  = ANY - '"' - '\\' - cr - lf.
    charCh    = ANY - '\'' - '\\' - cr - lf.
    printable =  '\x20' .. '\x7e'.
    hex       = "0123456789abcdef".

TOKENS
    ident     = letter { letter | digit }.
    number    = digit { digit }.
    string    = '"' { stringCh | '\\' printable } '"'.
    badString = '"' { stringCh | '\\' printable } (cr | lf).
    char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
    ddtSym    = '$' { digit | letter }.  (. .)

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

Coco                            (. Symbol_t  * sym;
				   Graph_t   * g, * g1, * g2;
				   char      * gramName = NULL;
				   CharSet_t * s; 
                                   Parser_InitDeclarations(self); .)
=
                                (. int beg = self->la->pos; .)
  { // this section can be used
    // for #include statements
    ANY
  }                             (. if (self->la->pos != self->beg) {
	                               self->pgen->usingPos = Position(NULL, beg, self->t->pos - beg + strlen(self->t->val), 0);
                                   }
                                .)

  "COMPILER"                    (. self->genScanner = TRUE;
                                   self->tab->ignored = CharSet(NULL); .)
  ident                         (. gramName = strdupa(self->t->val);
                                   beg = self->la->pos;
                                 .)
  { ANY }                       (. self->tab->semDeclPos = Position(NULL, beg, self->la->pos-beg, 0); .)
  [ "IGNORECASE"                (. self->dfa->ignoreCase = TRUE; .) ]   /* pdt */
  [ "CHARACTERS" { SetDecl }]
  [ "TOKENS"  { TokenDecl<node_t> }]
  [ "PRAGMAS" { TokenDecl<node_pr> }]
  { "COMMENTS"                  (. Bool_t nested = FALSE; .)
    "FROM" TokenExpr<&g1> 
    "TO" TokenExpr<&g2>
    [ "NESTED"                  (. nested = TRUE; .)
    ]                           (. DFA_NewComment(self->dfa, g1->l, g2->l, nested); .)
  }
  { "IGNORE" Set<&s>            (. BitArray_Or(self->tab->ignored, s); .)
  }

  SYNC 
  "PRODUCTIONS"                 (. if (self->genScanner) DFA_MakeDeterministic(self->dfa);
                                       Tab_DeleteNodes(self->tab);
                                 .)
  { ident                       (. sym = Tab_FindSym(self->tab, self->t->val);
                                   Bool_t undef = (sym == NULL);
				   if (undef) {
				       sym = Tab_NewSym(self->tab, node_nt, self->t->val, self->t->line);
                                   } else {
				       if (sym->typ == node_nt) {
					   if (sym->graph != NULL) Parser_SemErr(self, "name declared twice");
				       } else {
					   Parser_SemErr(self, "this symbol kind not allowed on left side of production");
				       }
				       sym->line = self->t->line;
                                   }
                                   Bool_t noAttrs = (sym->attrPos == NULL);
                                   sym->attrPos = NULL;
                                 .)
    [ AttrDecl<sym> ]           (. if (!undef)
                                       if (noAttrs != (sym->attrPos == NULL))
                                           Parser_SemErr(self, "attribute mismatch between declaration and use of this symbol");
                                 .)
    [ SemText<.&sym->semPos.> ] WEAK
    '='
    Expression<&g>              (. sym->graph = g->l;
				   Tab_Finish(self, g);
                                .)
                                WEAK
    '.'
  }
  "END" ident                   (. if (!strcmp(gramName, self->t->val))
				       Parser_SemErr(self, "name does not match grammar name");
				   self->tab->gramSy = Tab_FindSym(self->tag, gramName);
				   if (self->tab->gramSy == NULL) {
                                       Parser_SemErr(self, "missing production for grammar name");
                                   } else {
                                       sym = self->tab->gramSy;
                                       if (sym->attrPos != NULL)
					   Parser_SemErr(self, "grammar symbol must not have attributes");
                                   }
				   self->tab->noSym = Tab_NewSym(self->tab, node_t, "???", 0); // noSym gets highest number
                                   Tab_SetupAnys(self->tab);
                                   Tab_RenumberPragmas(self->tab);
                                   if (self->tab->ddt[2]) Tab_PrintNodes(self->tab);
                                   if (self->errors->count == 0) {
                                       fprintf(stderr, "checking\n");
				       Tab_CompSymbolSets(self->tab);
				       if (self->tab->ddt[7]) Tab_XRef(self->tab);
				       if (Tab_GrammarOk(self->tab)) {
					   fprintf(stderr, "parser");
					   ParserGen_WriteParser(self->pgen);
					   if (self->genScanner) {
					       fprintf(stderr, " + scanner");
					       DFA_WriteScanner(self->dfa);
					       if (self->tab->ddt[0]) DFA_PrintStates(self->dfa);
					   }
					   fprintf(stderr, " generated\n");
					   if (self->tab->ddt[8]) ParserGen_WriteStatistics(self->pgen);
				       }
                                   }
                                   if (self->tab->ddt[6]) Tab_PrintSymbolTable(self->tab);
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

SetDecl                         (. CcCharSet_t * s; .)
=
  ident                         (. const char * name = self->t->val;
				   CCCharClass_t * c = CcLexical_FindCharClassN(self->lexical, name);
				   if (c != NULL)
				       CcsGlobals_SemErr(self->globals, self->t,
				                         "name '%s' declared twice", name); .)
  '=' Set<&s>                   (. if (CcCharSet_Elements(s) == 0)
				       CcsGlobals_SemErr(self->globals, self->t,
				                         "character set must not be empty");
				   CcLexical_NewCharClass(self->lexical, name, s); .)
  '.'
.

/*------------------------------------------------------------------------------------*/

Set<CcCharSet_t ** s>           (. CcCharSet_t * s2; .)
=
  SimSet<s>
  { '+' SimSet<&s2>             (. CcCharSet_Or(*s, s2);
    				   CcCharSet_Desturct(s2); .)
  | '-' SimSet<&s2>             (. CcCharSet_Subtract(*s, s2);
    				   CcCharSet_Destruct(s2); .)
  }
.

/*------------------------------------------------------------------------------------*/

SimSet<CcCharSet ** s>          (. int n1, n2; .)
=                               (. *s = CcCharSet(); .)
( ident                         (. CcCharClass_t * c = CcLexical_FindCharClassN(self->lexical, self->t->val);
				   if (c != NULL) CcCharSet_Or(*s, c->set);
				   else CcsGlobals_SemErr(self->globals, self->t, "undefined name"); .)
| string                        (. const char * cur0; int ch;
  				   char * cur, * name = CcUnescape(self->t->val);
				   if (self->lexical->ignoreCase) {
				       for (cur = name; *cur; ++cur) *cur = tolower(*cur);
				   }
				   cur0 = name;
				   while (*cur0) {
				       ch = CcsUTF8GetCh(&cur0, name + strlen(name));
				       CcsAssert(ch >= 0);
				       CcCharSet_Set(*s, ch);
				       ch = UTF8Get(&cur, EoF);
                                   }
				   CcFree(name); .)
| Char<&n1>                     (. CcCharSet_Set(*s, n1); .)
  [ ".." Char<&n2>              (. int idx;
				   for (idx = n1; idx <= n2; ++idx) CcCharSet_Set(*s, idx); .)
  ]
| "ANY"                         (. CcCharSet_Fill(*s, COCO_WCHAR_MAX); .)
)
.

/*--------------------------------------------------------------------------------------*/

Char<int * n>          (. char * name; const char * cur; .)
=
  char                 (. *n = 0;
		          cur = name = CcUnescape(self->t->val);
			  *n = CcsUTF8GetCh(&cur, name + strlen(name));
			  if (*cur != 0)
			      CcsGlobals_SemErr(self->globals, self->t,
			          "unacceptable character value: %s", self->t->val);
			  CcFree(name);
			  if (self->lexical->ignoreCase) *n = tolower(*n); .)
.

/*------------------------------------------------------------------------------------*/

TokenDecl<const CcObjectType_t * typ> (. char * name = NULL; int kind; CcSymbol_t * sym; CcGraph_t * g; .)
=
  Sym<&name, &kind>             (. sym = CcSymbolTable_FindSym(self->symtab, name);
				   if (sym != NULL) {
				       CcsGlobals_SemErr(self->globals, self->t, "name %s declared twice", name);
                                   } else if (type == symbol_t) {
				       sym = CcSymbolTable_NewTerminal(self->symtab, name, self->t->line);
				       ((CcSymbolT_t *)sym)->tokenKind = symbol_fixedToken;
				   } else if (type == symbol_pr) {
				       sym = CcSymbolTable_NewPragma(self->symtab, name, self->t->line);
				       ((CcSymbolPR_t *)sym)->tokenKind = symbol_fixedToken;
				       ((CcSymbolPR_t *)sym)->semPos = NULL;
                                   }
				   if (self->tokenString && self->tokenString != noString)
				       CcFree(self->tokenString);
				   self->tokenString = NULL;
				   CcFree(name); .)
  SYNC
  ( '=' TokenExpr<&g> '.'       (. if (kind == CcsParser_str)
				       CcsGlobals_SemErr(self->globals, self->t,
				       			 "a literal must not be declared with a structure");
				   CcGraph_Finish(g);
				   if (self->tokenString == NULL || self->tokenString == noString)) {
				       CcLexical_ConvertToStates(self->lexical, g->head, sym);
                                   } else { /* TokenExpr is a single string */
				       if (CcHashTable_Get(&self->lexical->literals,
							   self->tokenString) != NULL)
					   CcsGlobals_SemErr(self->globals, self->t,
					   		     "token string %s declared twice", self->tokenString);
				       CcHashTable_Set(&self->lexical->literals,
				                       self->tokenString, (CcObject_t *)sym);
				       CcLexical_MatchLiteral(self->lexical, self->t,
				                              self->tokenString, sym);
				       CcFree(self->tokenString);
                                   }
				   self->tokenString = NULL;
				   CcGraph_Destruct(g); .)
  |                             (. if (kind == CcsParser_id) self->genScanner = FALSE;
				   else CcLexical_MatchLiteral(self->lexical, self->t, sym->name, sym); .)
  )
  [ SemText<.&((CcSymbolPR_t *)sym)->semPos.> (. if (typ != symbol_pr)
    			     		      	     CcsGlobals_SemErr(self->globals, self->t,
						     		       "semantic action not allowed here"); .)
  ]
.

/*------------------------------------------------------------------------------------*/

AttrDecl<CcSymbolNT_t * sym>
=
  '<'                           (. CcsToken_t * beg;
  				   CcsScanner_IncRef(self->scanner, beg = self->la); .)
  { ANY
  | badString                   (. CcsGlobals_SemErr(self->globals, self->t,
    				   		     "bad string in attributes"); .)
  }
  '>'                           (. sym->attrPos = CcsScanner_GetPosition(self->scanner, beg, self->t);
  				   CcsScanner_DecRef(self->scanner, beg); .)
| "<."                          (. CcsToken_t * beg;
  				   CcsScanner_IncRef(self->scanner, beg = self->la); .)
  { ANY
  | badString                   (. CcsGlobals_SemErr(self->globals, self->t,
    				   		     "bad string in attributes"); .)
  }
  ".>"                          (. sym->attrPos = CcsScanner_GetPosition(self->scanner, beg, self->t);
     				   CcsScanner_DecRef(self->scanner, beg); .)
.

/*------------------------------------------------------------------------------------*/

Expression<CcGraph_t ** g>      (. CcGraph_t * g2; .)
= 
  Term<g>                       (. CcsBool_t first = TRUE; .)
  {                             WEAK
    '|'
  Term<&g2>                     (. if (first) { CcEBNF_MakeFirstAlt(&self->syntax->base, *g); first = false; }
                                   CcEBNF_MakeAlternative(&self->syntab->base, *g, g2);
				   CcGraph_Destruct(g2); .)
  }
.

/*------------------------------------------------------------------------------------*/

Term<CcGraph_t ** g>            (. CcGraph_t * g2; CcsPosition_t * pos; CcNode_t * rslv = NULL;
                                   *g = NULL; .)
=
  ( [
  Resolver<.&pos.>              (. rslv = CcEBNF_NewNode(&self->syntax->base,
							 CcNodeRslvP(self->la->line, pos);
                                   *g = CcGraphP(rslv); .)
  ]
  Factor<&g2>                   (. if (rslv == NULL) *g = g2;
   				   else {
				       CcEBNF_MakeSequence(&self->syntax->base, *g, g2);
				       CcGraph_Destruct(g2);
				   } .)
  { Factor<&g2>                 (. CcEBNF_MakeSequence(&self->syntab->base, *g, g2);
    				   CcGraph_Destruct(g2); .)
  }
|                               (. *g = CcGraphP(CcEBNF_NewNode(&self->syntab->base, CcNodeEps(0))); .)
)                               (. if (*g == NULL) /* invalid start of Term */
				       *g = CcGraphP(CcEBNF_NewNode(&self->syntab->base, CcNodeEps(0))); .)
.

/*------------------------------------------------------------------------------------*/

Factor<CcGraph_t ** g>          (. char * name = NULL; int kind; CcsPosition_t * pos; CcsBool_t weak = FALSE; 
                                   *g = NULL; .)
=
( [ "WEAK"                      (. weak = TRUE; .)
  ]
  Sym<&name, &kind>             (. CcSymbol_t * sym = CcSymbolTable_FindSym(self->symtab, name);
                                   if (sym == NULL && kind == CcsParser_str)
                                       sym = (CcSymbol_t *)CcHashTable_Get(&self->lexical->literals, name);
                                   CcsBool_t undef = (sym == NULL);
                                   if (undef) {
                                       if (kind == CcsParser_id) {
				           /* forward nt */
                                           sym = CcSymbolTable_NewNonTerminal(self->symtab, name, self->t->line);
				       } else if (self->genScanner) {
					   sym = CcSymbolTable_NewTerminal(self->symtab, name, self->t->line);
					   CcLexical_MatchLiteral(self->lexical, self->t, sym->name, sym);
				       } else {  /* undefined string in production */
					   CcsGlobals_SemErr(self->globals, self->t,
					                     "undefined string in production");
					   sym = self->syntax->eofSy;  /* dummy */
				       }
                                   }
				   CcFree(name);
                                   if (sym->base.type != symbol_t && sym->base.type != symbol_nt)
                                       CcsGlobals_SemErr(self->globals, self->t,
				                         "this symbol kind is not allowed in a production");
                                   if (weak) {
				       if (sym->base.type != symbol_t)
				           CcsGlobals_SemErr(self->globals, self->t,
					                     "only terminals may be weak");
				   }

				   CcNode_t * p = CcSyntax_NodeFromSymbol(self->syntax, sym, self->t->line, weak);
				   *g = CcGraphP(p); .)
  [ Attribs<p>                  (. if (kind != CcsParser_id)
                                       CcsGlobals_SemErr(self->globals, self->t,
				                         "a literal must not have attributes"); .)
  ]                             (. if (undef) {
                                       if (sym->base.type == symbol_nt)
				           ((CcSymbolNT_t *)sym)->attrPos = ((CcNodeNT_t *)p)->pos; /* dummy */
                                   } else if (sym->base.type == symbol_nt &&
				              (((CcNodeNT_t *)p)->pos == NULL) !=
					      (((CcSymbolNT_t *)sym)->attrPos == NULL))
				       CcsGlobals_SemErr(self->globals, self->t,
				                         "attribute mismatch between declaration and use of this symbol"); .)
| '(' Expression<&g> ')'
| '[' Expression<&g> ']'        (. CcEBNF_MakeOption(&self->syntax->base, *g); .)
| '{' Expression<&g> '}'        (. CcEBNF_MakeIteration(&self->syntax->base, *g); .)
| SemText<&pos>                 (. CcNode_t * p = CcEBNF_NewNode(&self->syntax->base, CcNodeSem(0));
                                   ((CcNodeSEM_t *)p)->pos = pos;
				   *g = CcGraphP(p); .)
| "ANY"                         (. /* p.set is set in Tab_SetupAnys */
                                   CcNode_t * p = CcEBNF_NewNode(&self->syntab->base, CcNodeAny(0));
				   *g = CcGraphP(p); .)
| "SYNC"                        (. CcNode_t * p = CcEBNF_NewNode(&self->syntab->base, CcNodeSync(0));
				   *g = CcGraphP(p);
                                .)
)                               (. if (*g == NULL) /* invalid start of Factor */
				       *g = CcGraphP(CcEBNF_NewNode(&self->syntab->base, CcNodeEps(0))); .)
.

/*------------------------------------------------------------------------------------*/

Resolver<CcsPosition_t ** pos>   
=
  "IF" "("                       (. CcsToken_t * beg;
                                    CcsScanner_IncRef(self->scanner, beg = self->la); .)
  Condition                      (. *pos = CcsScanner_GetPosition(self->scanner, beg, self->t);
                                    CcsScanner_DecRef(self->scanner, beg); .)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

TokenExpr<CcGraph_t ** g>       (. CcGraph_t * g2; .)
=
  TokenTerm<&g>                 (. CcsBool_t first = TRUE; .)
  {                             WEAK
    '|'
    TokenTerm<&g2>              (. if (first) { CcEBNF_MakeFirstAlt(&self->lexical->base, *g); first = false; }
                                   CcEBNF_MakeAlternative(&self->lexical->base, *g, g2);
				   CcGraph_Destruct(g2); .)
  }
.

/*------------------------------------------------------------------------------------*/

TokenTerm<CcGraph_t ** g>       (. CcGraph_t * g2; .)
=
  TokenFactor<&g>
  { TokenFactor<&g2>            (. CcEBNF_MakeSequence(&self->lexical->base, *g, g2);
                                   CcGraph_Destruct(g2); .)
  }
  [ "CONTEXT"
    '(' TokenExpr<&g2>          (. CcLexical_SetContextTrans(self->lexical, g2->head);
				   self->lexical->hasCtxMoves = TRUE;
				   CcEBNF_MakeSequence(&self->lexical->base, *g, g2); .)
    ')'
  ]
.

/*------------------------------------------------------------------------------------*/

TokenFactor<CcGraph_t ** g>     (. char * name = NULL; int kind; CcTransition_t trans; .)
=
                                (. *g = NULL; .)
( Sym<&name, &kind>             (. if (kind == CcsParser_id) {
	                               CcCharClass_t * c = CcLexical_FindCharClass(self->lexical, name);
                                       if (c == NULL) {
					   CcsGlobals_SemErr(self->globals, self->t, "undefined name");
					   c = CcLexical_NewCharClass(self->lexical, name, CcCharSet());
				       }
				       CcTransition_FromCharSet(&trans, c->set, trans_normal,
				                                &self->lexical->classes);
				       *g = CcGraphP(CcEBNF_NewNode(&self->lexical->base,
				                                    CcNodeTrans(0, &trans)));
				       CcTransition_Destruct(&trans);
				       if (self->tokenString && self->tokenString != noString)
				           CcFree(self->tokenString);
				       self->tokenString = (char *)noString;
                                   } else { /* CcsParser_str */
	                               *g = CcLexical_StrToGraph(self->lexical, name, self->t);
				       if (self->tokenString == NULL) self->tokenString = CcStrdup(name);
				       else {
				           if (self->tokenString != noString) CcFree(self->tokenString);
					   self->tokenString = (char *)noString;
				       }
                                   }
				   CcFree(name); .)
| '(' TokenExpr<&g> ')'
| '[' TokenExpr<&g> ']'         (. CcEBNF_MakeOption(&self->lexical->base, *g); .)
| '{' TokenExpr<&g> '}'         (. CcEBNF_MakeIteration(&self->lexical->base, *g); .)
)                               (. if (*g == NULL) /* invalid start of TokenFactor */
                                     *g = CcGraphP(CcEBNF_NewNode(&self->lexical->base, CcNodeEps(0))); .)
.

/*------------------------------------------------------------------------------------*/

Sym<char ** name, int * kind>
=                               (. *name = CcStrdup("???"); *kind = CcsParser_id; .)
( ident                         (. *kind = CcsParser_id; CcFree(*name); *name = CcStrdup(self->t->val); .)
| (string                       (. CcFree(*name); *name = CcStrdup(self->t->val); .)
  | char                        (. CcFree(*name); *name = CcStrdup(self->t->val); .)
  )                             (. *kind = CcsParser_str;
                                   if (self->lexical->ignoreCase) {
                                       char * cur;
				       for (cur = *name; *cur; ++cur) *cur = tolower(*cur);
				   }
				   if (strchr(*name, ' '))
				       CcsGlobals_SemErr(self->globals, self->t,
				                         "literal tokens \"%s\" can not contain blanks", *name); .)
)
.

/*------------------------------------------------------------------------------------*/

Attribs<CcNode_t * p>
=
  '<'                           (. CcsToken_t * beg;
                                   CcsScanner_IncRef(self->scanner, beg = self->la); .)
  { ANY 
  | badString                   (. CcsGlobals_SemErr(self->globals, self->t,
                                                     "bad string in attributes"); .)
  }
  '>'                           (. CcNode_SetPosition(p CcsScanner_GetPosition(self->scanner,
                                                                               beg, self->t);
                                   CcsScanner_DecRef(self->scanner, beg); .)
| "<."                          (. CcsToken_t * beg
                                   CcsScanner_Incref(self->scanner, beg = self->la); .)
  { ANY 
  | badString                   (. CcsGlobals_SemErr(self->globals, self->t,
                                                     "bad string in attributes"); .)
  }
  ".>"                          (. CcNode_SetPosition(p, CcsScanner_GetPosition(self->scanner,
                                                                                beg, self->t));
                                   CcsScanner_DecRef(self->scanner, beg); .)
.

/*------------------------------------------------------------------------------------*/

SemText<CcsPosition_t ** pos>
=
  "(."                          (. CcsToken_t * beg;
                                   CcsScanner_IncRef(self->scanner, beg = self->la; .)
  { ANY
  | badString                   (. CcsGlobals_SemErr(self->globals, self->t,
                                                     "bad string in semantic action"); .)
  | "(."                        (. CcsGlobals_SemErr(self->globals, self->t,
                                                     "missing end of previous semantic action"); .)
  }
  ".)"                          (. *pos = CcsScanner_GetPosition(self->scanner, beg, self->t);
                                   CcsScanner_DecRef(self->scanner, beg) .)
.

/*------------------------------------------------------------------------------------*/
  
END Coco.
