/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

#include  "DFA.h"
#include  "Tab.h"
#include  "Action.h"
#include  "BitArray.h"
#include  "Comment.h"
#include  "Melted.h"
#include  "Node.h"
#include  "State.h"
#include  "Symbol.h"
#include  "Target.h"

static State_t * DFA_NewState(DFA_t * self);

DFA_t *
DFA(DFA_t * self, Parser_t * parser)
{
    self = AllocObject(self, sizeof(DFA_t));
    self->parser = parser;
    self->tab = parser->tab;
    self->errors = &parser->errors;
    self->trace = parser->trace;
    self->firstState = NULL; self->lastState = NULL; self->lastStateNr = -1;
    self->firstState = DFA_NewState(self);
    self->firstMelted = NULL; self->firstComment = NULL;
    self->ignoreCase = FALSE;
    self->dirtyDFA = FALSE;
    self->hasCtxMoves = FALSE;
    return self;
}

static State_t *
DFA_NewState(DFA_t * self)
{
    State_t * s = State(NULL); s->nr = ++self->lastStateNr;
    if (self->firstState == NULL) self->firstState = s;
    else self->lastState->next = s;
    self->lastState = s;
    return s;
}

static void
DFA_NewTransition(DFA_t * self, State_t * from, State_t * to,
		  int typ, int sym, int tc)
{
    Target_t * t;
    Action_t * a;
    if (to == self->firstState)
	Parser_SemErr(self->parser, "token must not start with an iteration");
    t = Target(NULL, to);
    a = Action(NULL, typ, sym, tc); a->target = t;
    State_AddAction(from, a);
    if (typ == node_clas) self->curSy->tokenKind = symbol_classToken;
}

static void
DFA_CombineShifts(DFA_t * self)
{
    State_t * state;
    Action_t * a, * b, * c;
    CharSet_t * seta, * setb;
    for (state = self->firstState; state != NULL; state = state->next) {
	for (a = state->firstAction; a != NULL; a = a->next) {
	    b = a->next;
	    while (b != NULL)
		if (a->target->state == b->target->state && a->tc == b->tc) {
		    seta = Action_Symbols(a, self->tab);
		    setb = Action_Symbols(b, self->tab);
		    CharSet_Or(seta, setb);
		    Action_ShiftWith(a, seta, self->tab);
		    c = b; b = b->next; State_DetachAction(state, c);
		} else {
		    b = b->next;
		}
	}
    }
}

static void
DFA_FindUsedStates(DFA_t * self, State_t * state, BitArray_t * used)
{
    Action_t * a;
    if (BitArray_Get(used, state->nr)) return;
    BitArray_Set(used, state->nr, TRUE);
    for (a = state->firstAction; a != NULL; a = a->next)
	DFA_FindUsedStates(self, a->target->state, used);
}

static void
DFA_DeleteRedundantStates(DFA_t * self)
{
    State_t * s1, * s2, * state;
    BitArray_t used;
    Action_t * a;
    State_t ** newState = (State_t **)
	CocoMalloc(sizeof(State_t *) * (self->lastStateNr + 1));

    BitArray(&used, self->lastStateNr + 1);

    DFA_FindUsedStates(self, self->firstState, &used);
    for (s1 = self->firstState->next; s1 != NULL; s1 = s1->next)
	if (BitArray_Get(&used, s1->nr) && s1->endOf != NULL &&
	    s1->firstAction == NULL && !(s1->ctx))
	    for (s2 = s1->next; s2 != NULL; s2 = s2->next)
		if (BitArray_Get(&used, s2->nr) && s1->endOf == s2->endOf &&
		    s2->firstAction == NULL && !(s2->ctx)) {
		    BitArray_Set(&used, s2->nr, FALSE);
		    newState[s2->nr] = s1;
		}

    for (state = self->firstState; state != NULL; state = state->next)
	if (BitArray_Get(&used, state->nr))
	    for (a = state->firstAction; a != NULL; a = a->next)
		if (!BitArray_Get(&used, a->target->state->nr))
		    a->target->state = newState[a->target->state->nr];
    /* delete unused states */
    self->lastState = self->firstState; self->lastStateNr = 0;
    for (state = self->firstState->next; state != NULL; state = state->next)
	if (BitArray_Get(&used, state->nr)) {
	    state->nr = ++self->lastStateNr; self->lastState = state;
	} else {
	    self->lastState->next = state->next;
	}
    CocoFree(newState);
    BitArray_Destruct(&used);
}

static State_t *
DFA_TheState(DFA_t * self, Node_t * p)
{
    State_t * state;
    if (p != NULL) return p->state;
    state = DFA_NewState(self);
    state->endOf = self->curSy;
    return state;
}

static void
DFA_Step(DFA_t * self, State_t * from, Node_t * p, BitArray_t * stepped)
{
    BitArray_t newStepped;
    if (p == NULL) return;
    BitArray_Set(stepped, p->n, TRUE);
    if (p->typ == node_clas || p->typ == node_chr) {
	DFA_NewTransition(self, from, DFA_TheState(self, p->next),
			  p->typ, p->val, p->code);
    } else if (p->typ == node_alt) {
	DFA_Step(self, from, p->sub, stepped);
	DFA_Step(self, from, p->down, stepped);
    } else if (p->typ == node_iter || p->typ == node_opt) {
	if (p->next != NULL && BitArray_Get(stepped, p->next->n))
	    DFA_Step(self, from, p->next, stepped);
	DFA_Step(self, from, p->sub, stepped);
	if ((p->typ == node_iter) && (p->state != from)) {
	    BitArray(&newStepped, self->tab->nodes.Count);
	    DFA_Step(self, p->state, p, &newStepped);
	    BitArray_Destruct(&newStepped);
	}
    }
}

static void
DFA_NumberNodes(DFA_t * self, Node_t * p, State_t * state, Bool_t renumIter)
{
    if (p == NULL) return;
    if (p->state != NULL) return;
    if ((state == NULL) || ((p->typ == node_iter) && renumIter))
	state = DFA_NewState(self);
    p->state = state;
    if (Node_DelGraph(p)) state->endOf = self->curSy;

    if (p->typ == node_clas || p->typ == node_chr) {
	DFA_NumberNodes(self, p->next, NULL, FALSE);
    } else if (p->typ == node_opt) {
	DFA_NumberNodes(self, p->next, NULL, FALSE);
	DFA_NumberNodes(self, p->sub, state, TRUE);
    } else if (p->typ == node_iter) {
	DFA_NumberNodes(self, p->next, state, TRUE);
	DFA_NumberNodes(self, p->sub, state, TRUE);
    } else if (p->typ == node_alt) {
	DFA_NumberNodes(self, p->next, NULL, FALSE);
	DFA_NumberNodes(self, p->sub, state, TRUE);
	DFA_NumberNodes(self, p->down, state, renumIter);
    }
}

static void
DFA_FindTrans(DFA_t * self, Node_t * p, Bool_t start, BitArray_t * marked)
{
    BitArray_t stepped;
    if (p == NULL || BitArray_Get(marked, p->n)) return;
    BitArray_Set(marked, p->n, TRUE);
    if (start) {
	BitArray(&stepped, self->tab->nodes.Count);
	/* start of group of equally numbered nodes */
	DFA_Step(self, p->state, p, &stepped);
	BitArray_Destruct(&stepped);
    }

    if (p->typ == node_clas || p->typ == node_chr) {
	DFA_FindTrans(self, p->next, TRUE, marked);
    } else if (p->typ == node_opt) {
	DFA_FindTrans(self, p->next, TRUE, marked);
	DFA_FindTrans(self, p->sub, FALSE, marked);
    } else if (p->typ == node_iter) {
	DFA_FindTrans(self, p->next, FALSE, marked);
	DFA_FindTrans(self, p->sub, FALSE, marked);
    } else if (p->typ == node_alt) {
	DFA_FindTrans(self, p->sub, FALSE, marked);
	DFA_FindTrans(self, p->down, FALSE, marked);
    }
}

void
DFA_ConvertToStates(DFA_t * self, Node_t * p, Symbol_t * sym)
{
    BitArray_t stepped;
    self->curGraph = p; self->curSy = sym;
    if (Node_DelGraph(self->curGraph))
	Parser_SemErr(self->parser, "token might be empty");
    DFA_NumberNodes(self, self->curGraph, self->firstState, TRUE);
    DFA_FindTrans(self, self->curGraph, TRUE,
		  BitArray(NULL, self->tab->nodes.Count));
    if (p->typ == node_iter) {
	BitArray(&stepped, self->tab->nodes.Count);
	DFA_Step(self, self->firstState, p, &stepped);
	BitArray_Destruct(&stepped);
    }
}

/* match string against current automaton; store it either as a
 * fixedToken or as a litToken */
void
DFA_MatchLiteral(DFA_t * self, const char * s, Symbol_t * sym) {
    char * s0 = Unescape(s);
    const char * scur, * snext;
    State_t * to, * state = self->firstState;
    Action_t * a = NULL;
    Symbol_t * matchedSym;

    /* Try to match s against existing DFA. */
    for (scur = s0; *scur; scur = snext) {
	snext = scur;
	a = DFA_FindAction(self, state, UTF8Get(&snext, -1));
	if (a == NULL) break;
	state = a->target->state;
    }

    /* if s was not totally consumed or leads to a non-final state => make
     * new DFA from it */
    if (*scur || state->endOf == NULL) {
	state = self->firstState; scur = s0; a = NULL;
	self->dirtyDFA = TRUE;
    }
    for (;*scur; scur = snext) { /* make new DFA for s0[i..len-1] */
	to = DFA_NewState(self);
	snext = scur;
	DFA_NewTransition(self, state, to, node_chr,
			  UTF8Get(&snext, -1), node_normalTrans);
	state = to;
    }
    CocoFree(s0);

    matchedSym = state->endOf;
    if (state->endOf == NULL) {
	state->endOf = sym;
    } else if (matchedSym->tokenKind == symbol_fixedToken ||
	       (a != NULL && a->tc == node_contextTrans)) {
	/* s matched a token with a fixed definition or a token with
	 * an appendix that will be cut off */
	Parser_SemErr(self->parser,
		      "tokens %ls and %ls cannot be distinguished",
		      sym->name, matchedSym->name);
    } else { /* matchedSym == classToken || classLitToken */
	matchedSym->tokenKind = symbol_classLitToken;
	sym->tokenKind = symbol_litToken;
    }
}

static void
DFA_SplitActions(DFA_t * self, State_t * state, Action_t * a, Action_t * b) {
    Action_t * c; CharSet_t * seta, * setb, * setc;
    seta = Action_Symbols(a, self->tab); setb = Action_Symbols(b, self->tab);
    if (CharSet_Equals(seta, setb)) {
	Action_AddTargets(a, b);
	State_DetachAction(state, b);
    } else if (CharSet_Includes(seta, setb)) {
	setc = CharSet_Clone(NULL, seta); CharSet_Subtract(setc, setb);
	Action_AddTargets(b, a);
	Action_ShiftWith(a, setc, self->tab);
    } else if (CharSet_Includes(setb, seta)) {
	setc = CharSet_Clone(NULL, setb); CharSet_Subtract(setc, seta);
	Action_AddTargets(a, b);
	Action_ShiftWith(b, setc, self->tab);
    } else {
	setc = CharSet_Clone(NULL, seta); CharSet_And(setc, setb);
	CharSet_Subtract(seta, setc);
	CharSet_Subtract(setb, setc);
	Action_ShiftWith(a, seta, self->tab);
	Action_ShiftWith(b, setb, self->tab);
	/* typ and sym are set in ShiftWith */
	c = Action(NULL, 0, 0, node_normalTrans);
	Action_AddTargets(c, a);
	Action_AddTargets(c, b);
	Action_ShiftWith(c, setc, self->tab);
	State_AddAction(state, c);
    }
}

static Bool_t
DFA_Overlap(DFA_t * self, Action_t * a, Action_t * b) {
    CharSet_t * seta, * setb;
    if (a->typ == node_chr) {
	if (b->typ == node_chr) return (a->sym == b->sym);
	setb = Tab_CharClassSet(self->tab, b->sym);
	return CharSet_Get(setb, a->sym);
    } else {
	seta = Tab_CharClassSet(self->tab, a->sym);
	if (b->typ == node_chr) return CharSet_Get(seta, b->sym);
	setb = Tab_CharClassSet(self->tab, b->sym);
	return CharSet_Intersects(seta, setb);
    }
}

/* return true if actions were split */
static Bool_t
DFA_MakeUnique(DFA_t * self, State_t *state) {
    Action_t * a, * b;
    Bool_t changed = FALSE;

    for (a = state->firstAction; a != NULL; a = a->next)
	for (b = a->next; b != NULL; b = b->next)
	    if (DFA_Overlap(self, a, b)) {
		DFA_SplitActions(self, state, a, b);
		changed = TRUE;
	    }
    return changed;
}

static void
DFA_MeltStates(DFA_t * self, State_t * state) {
    Bool_t changed, ctx;
    BitArray_t * targets;
    Symbol_t * endOf;
    Action_t * action;
    Melted_t * melt;
    State_t * s;
    Target_t * targ;

    for (action = state->firstAction; action != NULL; action = action->next) {
	if (action->target->next != NULL) {
	    DFA_GetTargetStates(self, action, &targets, &endOf, &ctx);
	    melt = DFA_StateWithSet(self, targets);
	    if (melt == NULL) {
		s = DFA_NewState(self); s->endOf = endOf; s->ctx = ctx;
		for (targ = action->target; targ != NULL; targ = targ->next)
		    State_MeltWith(s, targ->state);
		do { changed = DFA_MakeUnique(self, s); } while (changed);
		melt = DFA_NewMelted(self, targets, s);
	    }
	    action->target->next = NULL;
	    action->target->state = melt->state;
	}
    }
}

static void
DFA_FindCtxStates(DFA_t * self) {
    State_t * state;
    Action_t * a;

    for (state = self->firstState; state != NULL; state = state->next)
	for (a = state->firstAction; a != NULL; a = a->next)
	    if (a->tc == node_contextTrans) a->target->state->ctx = TRUE;
}

void
DFA_MakeDeterministic(DFA_t * self) {
    State_t * state;
    Bool_t  changed;

    self->lastSimState = self->lastState->nr;
    /* heuristic for set size in Melted.set */
    self->maxStates = 2 * self->lastSimState;
    DFA_FindCtxStates(self);
    for (state = self->firstState; state != NULL; state = state->next)
	do { changed = DFA_MakeUnique(self, state); } while (changed);
    for (state = self->firstState; state != NULL; state = state->next)
	DFA_MeltStates(self, state);
    DFA_DeleteRedundantStates(self);
    DFA_CombineShifts(self);
}

void
DFA_PrintStates(DFA_t * self) {
    /* FIX ME */
}

/* ---------------------------- actions -------------------------------- */

Action_t *
DFA_FindAction(DFA_t * self, State_t *state, int ch) {
    Action_t * a; CharSet_t * s;
    for (a = state->firstAction; a != NULL; a = a->next)
	if (a->typ == node_chr && ch == a->sym) return a;
	else if (a->typ == node_clas) {
	    s  = Tab_CharClassSet(self->tab, a->sym);
	    if (CharSet_Get(s, ch)) return a;
	}
    return NULL;
}

void
DFA_GetTargetStates(DFA_t * self, Action_t *a, BitArray_t ** targets,
		    Symbol_t ** endOf, Bool_t * ctx)
{
    Target_t * t; int stateNr;
    /* compute the set of target states */
    *targets = BitArray(NULL, self->maxStates); *endOf = NULL; *ctx = FALSE;
    for (t = a->target; t != NULL; t = t->next) {
	stateNr = t->state->nr;
	if (stateNr <= self->lastSimState) {
	    BitArray_Set(*targets, stateNr, TRUE);
	} else {
	    BitArray_Or(*targets, DFA_MeltedSet(self, stateNr));
	}
	if (t->state->endOf != NULL) {
	    if (*endOf == NULL || *endOf == t->state->endOf)
		*endOf = t->state->endOf;
	    else {
		fprintf(stderr, "Tokens %s and %s cannot be distinguished\n",
			(*endOf)->name, t->state->endOf->name);
		self->errors->count++;
	    }
	}
	if (t->state->ctx) {
	    *ctx = TRUE;
	    /* The following check seems to be unnecessary. It reported an error
	     * if a symbol + context was the prefix of another symbol, e.g.
	     *   s1 = "a" "b" "c".
	     *   s2 = "a" CONTEXT("b").
	     * But this is ok.
	     * if (t.state.endOf != null) {
	     *   Console.WriteLine("Ambiguous context clause");
	     *	 Errors.count++;
	     * } */
	}
    }
}

/* ------------------------- melted states ------------------------------ */
Melted_t *
DFA_NewMelted(DFA_t * self, BitArray_t * set, State_t * state) {
    Melted_t * m = Melted(NULL, set, state);
    m->next = self->firstMelted; self->firstMelted = m;
    return m;
}

BitArray_t *
DFA_MeltedSet(DFA_t * self, int nr) {
    Melted_t * m = self->firstMelted;
    while (m != NULL) {
	if (m->state->nr == nr) return m->set; else m = m->next;
    }
    //Errors::Exception("-- compiler error in Melted::Set");
    //throw new Exception("-- compiler error in Melted::Set");
    return NULL;
}

Melted_t *
DFA_StateWithSet(DFA_t * self, BitArray_t * s) {
    Melted_t * m;
    for (m = self->firstMelted; m != NULL; m = m->next)
	if (BitArray_Equal(s, m->set)) return m;
    return NULL;
}

/* ------------------------ comments -------------------------------- */

static void
DFA_CommentStr(DFA_t * self, int * output, Node_t * p) {
    CharSet_t * set;
    int * cur = output;
    *cur = 0;
    while (p != NULL) {
	if (p->typ == node_chr) {
	    *cur++ = p->val;
	} else if (p->typ == node_clas) {
	    set = Tab_CharClassSet(self->tab, p->val);
	    if (CharSet_Elements(set) != 1)
		Parser_SemErr(self->parser,
			      "character set contains more than 1 character");
	    *cur++ = CharSet_First(set);
	} else {
	    Parser_SemErr(self->parser,
			  "comment delimiters may not be structured");
	}
	if (cur - output > 2) {
	    Parser_SemErr(self->parser,
			  "comment delimiters must be 1 or 2 characters long");
	    cur = output; *cur++ = '?';
	    break;
	}
	p = p->next;
    }
    *cur = 0;
}

void
DFA_NewComment(DFA_t * self, Node_t * from, Node_t * to, Bool_t nested) {
    int start[3], stop[3];
    Comment_t * c;

    DFA_CommentStr(self, start, from); DFA_CommentStr(self, stop, to);
    c = Comment(NULL, start, stop, nested);
    c->next = self->firstComment; self->firstComment = c;
}
