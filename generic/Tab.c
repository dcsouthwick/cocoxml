/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
#include  <stdio.h>
#include  <stdlib.h>
#include  <string.h>
#include  "Tab.h"
#include  "Graph.h"
#include  "Node.h"
#include  "Symbol.h"

Tab_t *
Tab(Tab_t * self, Parser_t * parser) {
    Bool_t malloced;
    if (!(self = AllocObject(self, sizeof(Tab_t), &malloced))) goto errquit0;
    if (!ArrayList(&self->terminals)) goto errquit1;
    if (!ArrayList(&self->pragmas)) goto errquit2;
    if (!ArrayList(&self->nonterminals)) goto errquit3;
    if (!ArrayList(&self->nodes)) goto errquit4;
    return self;
 errquit4:
    ArrayList_Destruct(&self->nonterminals);
 errquit3:
    ArrayList_Destruct(&self->pragmas);
 errquit2:
    ArrayList_Destruct(&self->terminals);
 errquit1:
    if (malloced) free(self);
 errquit0:
    return NULL;
}

Symbol_t *
Tab_NewSym(Tab_t * self, int typ, const char * name, int line)
{
    Symbol_t * sym;

    if (!strcmp(name, "\"\"")) {
	Parser_SemErr(self->parser, "empty token now allowed");
	name = "???";
    }
    if (!(sym = malloc(sizeof(Symbol_t)))) return NULL;
    if (!(Symbol(sym, typ, name, line))) { free(sym); return NULL; }

    if (typ == node_t) {
	sym->n = self->terminals.Count;
	ArrayList_Add(&self->terminals, sym);
    } else if (typ == node_pr) {
	ArrayList_Add(&self->pragmas, sym);
    } else if (typ == node_nt) {
	sym->n = self->nonterminals.Count;
	ArrayList_Add(&self->nonterminals, sym);
    }
    return sym;
}

Symbol_t *
Tab_FindSym(Tab_t * self, const char * name)
{
    int idx; Symbol_t * sym;
    for (idx = 0; idx < self->terminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->terminals, idx);
	if (!strcmp(sym->name, name)) return sym;
    }
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	if (!strcmp(sym->name, name)) return sym;
    }
    return NULL;
}

void
Tab_PrintSymbolTable(Tab_t * self)
{
    int idx; Symbol_t * sym; HTIterator_t iter;
    DumpBuffer_t dbuf; char buf[128];

    fprintf(self->trace, "Symbol Table:\n");
    fprintf(self->trace, "------------\n\n");
    fprintf(self->trace, " nr name          typ  hasAt graph  del    line tokenKind\n");

    for (idx = 0; idx < self->terminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->terminals, idx);
	DumpBuffer(&dbuf, buf, sizeof(buf));
	Symbol_Dump(sym, &dbuf);
	fprintf(self->trace, "%s\n", buf);
    }

    for (idx = 0; idx < self->pragmas.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->pragmas, idx);
	DumpBuffer(&dbuf, buf, sizeof(buf));
	Symbol_Dump(sym, &dbuf);
	fprintf(self->trace, "%s\n", buf);
    }

    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	DumpBuffer(&dbuf, buf, sizeof(buf));
	Symbol_Dump(sym, &dbuf);
	fprintf(self->trace, "%s\n", buf);
    }

    fprintf(self->trace, "\nLiteral Tokens:\n");
    fprintf(self->trace, "--------------\n");

    HashTable_GetIterator(&self->literals, &iter);
    while (HTIterator_Forward(&iter)) {
	fprintf(self->trace, "_%s =  %s.\n",
		((Symbol_t *)HTIterator_Value(&iter))->name,
		HTIterator_Key(&iter));
    }
    fprintf(self->trace, "\n");
}

void
Tab_PrintSet(Tab_t * self, BitArray_t * s, int indent)
{
    int col, len, idx; Symbol_t * sym;
    col = indent;
    for (idx = 0; idx < self->terminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->terminals, idx);
	if (!BitArray_Get(s, sym->n)) continue;
	len = strlen(sym->name);
	if (col + len >= 80) {
	    fprintf(self->trace, "\n");
	    for (col = 1; col < indent; ++col) fprintf(self->trace, " ");
	}
	fprintf(self->trace, "%s ", sym->name);
	col += len + 1;
    }
    if (col == indent) fprintf(self->trace, "-- empty set --");
    fprintf(self->trace, "\n");
}

Node_t *
Tab_NewNodeTSL(Tab_t * self, int typ, Symbol_t * sym, int line)
{
    Node_t * node;
    if (!(node = Node(NULL, typ, sym, line))) goto errquit0;
    node->n = self->nodes.Count;
    if (!ArrayList_Add(&self->nodes, node)) goto errquit1;
    return node;
 errquit1:
    Node_Destruct(node); free(node);
 errquit0:
    return NULL;
}

Node_t *
Tab_NewNodeTS(Tab_t * self, int typ, Node_t * sub)
{
    Node_t * node;
    if (!(node = Tab_NewNodeTSL(self, typ, NULL, 0))) return NULL;
    node->sub = sub;
    return node;
}

Node_t *
Tab_NewNodeTVL(Tab_t * self, int typ, int val, int line)
{
    Node_t * node;
    if (!(node = Tab_NewNodeTSL(self, typ, NULL, line))) return NULL;
    node->val = val;
    return node;
}

void
Tab_MakeFirstAlt(Tab_t * self, Graph_t * g)
{
    g->l = Tab_NewNodeTS(self, node_alt, g->l);
    g->l->line = g->l->sub->line;
    g->l->next = g->r;
    g->r = g->l;
}

int
Tab_MakeAlternative(Tab_t * self, Graph_t * g1, Graph_t * g2)
{
    Node_t * p;
    if (!(g2->l = Tab_NewNodeTS(self, node_alt, g2->l))) return -1;
    g2->l->line = g2->l->sub->line;
    p = g1->l; while (p->down != NULL) p = p->down;
    p->down = g2->l;
    p = g1->r; while (p->next != NULL) p = p->next;
    p->next = g2->l;
    g2->l->next = g2->r;
    return 0;
}

void
Tab_MakeSequence(Tab_t * self, Graph_t * g1, Graph_t * g2)
{
    Node_t * q, * p = g1->r->next;
    g1->r->next = g2->l;
    while (p != NULL) {
	q = p->next; p->next = g2->l; p->up = TRUE;
	p = q;
    }
    g1->r = g2->r;
}

void
Tab_MakeIteration(Tab_t * self, Graph_t * g)
{
    Node_t * p, * q;
    g->l = Tab_NewNodeTS(self, node_iter, g->l);
    p = g->r;
    g->r = g->l;
    while (p != NULL) {
	q = p->next; p->next = g->l; p->up = TRUE;
	p = q;
    }
}

int
Tab_MakeOption(Tab_t * self, Graph_t * g) {
    if (!(g->l = Tab_NewNodeTS(self, node_opt, g->l))) return -1;
    g->l->next = g->r;
    g->r = g->l;
    return 0;
}

void
Tab_Finish(Tab_t * self, Graph_t * g)
{
    Node_t * q, * p = g->r;
    while (p != NULL) {
	q = p->next; p->next = NULL; p = q;
    }
}

int
Tab_DeleteNodes(Tab_t * self)
{
    ArrayList_Clear(&self->nodes);
    if (!(self->dummyNode = Tab_NewNodeTSL(self, node_eps, NULL, 0)))
	return -1;
    return 0;
}

Graph_t *
Tab_StrToGraph(Tab_t * self, const char * str)
{
    Graph_t * g; Node_t * p;
    DumpBuffer_t dbuf; char buf[128], * cur;
    char * subStr = strndupa(str + 1, strlen(str) - 2);

    DumpBuffer(&dbuf, buf, sizeof(buf));
    Unescape(&dbuf, subStr);
    if (strlen(buf) == 0)
	Parser_SemErr(self->parser, "empty token not allowed");
    g = Graph(NULL);
    g->r = self->dummyNode;
    for (cur = buf; *cur; ++cur) {
	p = Tab_NewNodeTVL(self, node_chr, (int)*cur, 0);
	g->r->next = p; g->r = p;
    }
    g->l = self->dummyNode->next; self->dummyNode->next = NULL;
    return g;
}

void
Tab_SetContextTrans(Tab_t * self, Node_t * p)
{
    while (p != NULL) {
	if (p->typ == node_chr || p->typ == node_clas) {
	    p->code = node_contextTrans;
	} else if (p->typ == node_opt || p->typ == node_iter) {
	    Tab_SetContextTrans(self, p->sub);
	} else if (p->typ == node_alt) {
	    Tab_SetContextTrans(self, p->sub);
	    Tab_SetContextTrans(self, p->down);
	}
	if (p->up) break;
	p = p->next;
    }
}

void
Tab_PrintNodes(Tab_t * self)
{
    Node_t * p; int idx;
    DumpBuffer_t dbuf; char lnbuf[256];
    fprintf(self->trace, "Graph nodes:\n");
    fprintf(self->trace, "----------------------------------------------------\n");
    fprintf(self->trace, "   n type name          next  down   sub   pos  line\n");
    fprintf(self->trace, "                               val  code\n");
    fprintf(self->trace, "----------------------------------------------------\n");

    for (idx = 0; idx < self->nodes.Count; ++idx) {
	p = (Node_t *)ArrayList_Get(&self->nodes, idx);
	DumpBuffer(&dbuf, lnbuf, sizeof(lnbuf));
	Node_Dump(p, &dbuf, self);
	fprintf(self->trace, "%s\n", lnbuf);
    }
    fprintf(self->trace, "\n");
}

CharClass_t *
Tab_NewCharClass(Tab_t * self, const char * name, CharSet_t * s)
{
    CharClass_t * c; char namebuf[8];
    if (!strcmp(name, "#")) {
	snprintf(namebuf, sizeof(namebuf), "#%c", self->dummyName++);
	if (!(c = CharClass(NULL, namebuf, s))) return NULL;
    } else {
	if (!(c = CharClass(NULL, name, s))) return NULL;
    }
    c->n = self->classes.Count;
    ArrayList_Add(&self->classes, c);
    return c;
}

CharClass_t *
Tab_FindCharClass(Tab_t * self, const char * name)
{
    int idx; CharClass_t * c;
    for (idx = 0; idx < self->classes.Count; ++idx) {
	c = (CharClass_t *)ArrayList_Get(&self->classes, idx);
	if (!strcmp(c->name, name)) return c;
    }
    return NULL;
}

CharClass_t *
Tab_FindCharClass(Tab_t * self, CharSet_t * s)
{
    int idx; CharClass_t * c;
    for (idx = 0; idx < self->classes.Count; ++idx) {
	c = (CharClass_t *)ArrayList_Get(&self->classes, idx);
	if (CharSet_Equals(s, c->set)) return c;
    }
    return NULL;
}

CharSet_t *
Tab_CharClassSet(Tab_t * self, int idx)
{
    return ((CharClass_t *)ArrayList_Get(&self->classes, idx))->set;
}

BitArray_t *
Tab_First0(Tab_t * self, Node_t * p, BitArray_t * mark)
{
    BitArray_t * fs, * fs0;
    if (!(fs = BitArray(NULL, self->terminals.Count))) goto errquit0;
    while (p != NULL && !BitArray_Get(mark, p->n)) {
	BitArray_Set(mark, p->n, TRUE);
	if (p->typ == node_nt) {
	    if (p->sym->firstReady) {
		BitArray_Or(fs, p->sym->first);
	    } else {
		if (!(fs0 = Tab_First0(self, p->sym->graph, mark)))
		    goto errquit1;
		BitArray_Or(fs, fs0);
		BitArray_Destruct(fs0); free(fs0);
	    }
	} else if (p->typ == node_t || p->typ == node_wt) {
	    BitArray_Set(fs, p->sym->n, TRUE);
	} else if (p->typ == node_any) {
	    BitArray_Or(fs, p->set);
	} else if (p->typ == node_alt) {
	    if (!(fs0 = Tab_First0(self, p->sub, mark))) goto errquit1;
	    BitArray_Or(fs, fs0);
	    BitArray_Destruct(fs0); free(fs0);
	    if (!(fs0 = Tab_First0(self, p->down, mark))) goto errquit1;
	    BitArray_Or(fs, fs0);
	    BitArray_Destruct(fs0); free(fs0);
	} else if (p->typ == node_iter || p->typ == node_opt) {
	    if (!(fs0 = Tab_First0(self, p->sub, mark))) goto errquit1;
	    BitArray_Or(fs, fs0);
	    BitArray_Destruct(fs0); free(fs0);
	}
	if (!Node_DelNode(p)) break;
	p = p->next;
    }
    return fs;
 errquit1:
    BitArray_Destruct(fs); free(fs);
 errquit0:
    return NULL;
}

BitArray_t *
Tab_First(Tab_t * self, Node_t * p)
{
    BitArray_t * mark, * fs;

    if (!(mark = BitArray(NULL, self->nodes.Count))) return NULL;
    fs = Tab_First0(self, p, mark);
    BitArray_Destruct(mark); free(mark);
    if (!fs) return NULL;
    if (self->ddt[3]) {
	fprintf(self->trace, "\n");
	if (p != NULL) fprintf(self->trace, "First: node = %d\n", p->n);
	else fprintf(self->trace, "First: node = null\n");
	Tab_PrintSet(fs, 0);
    }
    return fs;
}

void
Tab_CompFirstSets(Tab_t * self)
{
    Symbol_t * sym; int idx;
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	sym->first = BitArrary(NULL, self->terminals.Count);
	sym->firstReady = FALSE;
    }
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	sym->first = Tab_First(self, sym->graph);
	sym->firstReady = TRUE;
    }
}

void
Tab_CompFollow(Tab_t * self, Node_t * p)
{
    BitArray * s;
    while (p != NULL && !BitArray_Get(&self->visited, p->n)) {
	BitArray_Set(&self->visited, p->n, TRUE);
	if (p->typ == node_nt) {
	    s = Tab_First(self, p->next);
	    p->sym->follow->Or(s);
	    if (Node_DelGraph(p->next))
		BitArray_Set(p->sym->nts, curSy->n, TRUE);
	} else if (p->typ == node_opt || p->typ == node_iter) {
	    Tab_CompFollow(self, p->sub);
	} else if (p->typ == node_alt) {
	    Tab_CompFollow(self, p->sub); Tab_CompFollow(self, p->down);
	}
	p = p->next;
    }
}

void
Tab_Complete(Tab_t * self, Symbol_t * sym)
{
    int idx; Symbol_t * s;
    if (BitArray_Get(&self->visited, sym->n)) return;
    BitArray_Set(&self->visited, sym->n, TRUE);
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	s = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	if (BitArray_Get(sym->nts, s->n)) {
	    Tab_Complete(self, s);
	    sym->follow->Or(s->follow);
	    if (sym == self->curSy) BitArray_Set(sym->nts, s->n, FALSE);
	}
    }
}

void
Tab_CompFollowSets(Tab_t * self)
{
    int idx; Symbol_t * sym;
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	sym->follow = BitArray(NULL, self->terminals.Count);
	sym->nts = BitArray(NULL, self->nonterminals.Count);
    }
    BitArray_Set(self->gramSy->follow, self->eofSy->n, TRUE);
    BitArray(&self->visited, self->nodes.Count);
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	curSy = sym;
	Tab_CompFollow(self, sym->graph);
    }
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	BitArray(&self->visited, self->nonterminals.Count);
	curSy = sym;
	Tab_Complete(self, sym);
    }
}

Node_t *
Tab_LeadingAny(Tab_t * self, Node_t * p)
{
    Node_t * a = NULL;
    if (p == NULL) return NULL;
    if (p->typ == node_any) a = p;
    else if (p->typ == node_alt) {
	a = Tab_LeadingAny(self, p->sub);
	if (a == NULL) a = Tab_LeadingAny(self, p->down);
    } else if (p->typ == node_opt || p->typ == node_iter) {
	a = Tab_LeadingAny(self, p->sub);
    } else if (Node_DelNode(p) && !p->up) {
	a = Tab_LeadingAny(self, p->next);
    }
    return a;
}

void
Tab_FindAS(Tab_t * self, Node_t * p)
{
    Node_t * a; BitArray_t * s1;
    while (p != NULL) {
	if (p->typ == node_opt || p->typ == node_iter) {
	    Tab_FindAS(self, p->sub);
	    a = Tab_LeadingAny(self, p->sub);
	    if (a != NULL)
		BitArray_Subtract(a->set, Tab_First(self, p->next));
	} else if (p->typ == node_alt) {
	}
    }
    /* NOT FINISH YET */
}

void
Tab_CompAnySets(Tab_t * self)
{
    int idx; Symbol_t * sym;
    for (idx = 0; idx < self->nonterminals.Count; ++i) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	Tab_FindAS(self, sym->graph);
    }
}

BitArray_t *
Tab_Expected(Tab_t * self, Node_t * p, Symbol_t * curSy)
{
    BitArray * s = Tab_First(self, p);
    if (Node_DelGraph(p)) BitArray_Or(s, curSy->follow);
    return s;
}

BitArray_t *
Tab_Expected0(Tab_t * self, Node_t * p, Symbol_t * curSy)
{
    if (p->typ == node_rslv) return BitArray(NULL, self->terminals.Count);
    else return Tab_Expected(self, p, curSy);
}

void
Tab_CompSync(Tab_t * self, Node_t * p)
{
    BitArray_t * s;
    while (p != NULL && !BitArray_Get(&self->visited, p->n)) {
	BitArray_Set(&self->visited, p->n, TRUE);
	if (p->typ == node_sync) {
	    s = Tab_Expected(self, p->next, curSy);
	    BitArray_Set(s, eofSy->n, TRUE);
	    BitArray_Or(self->allSyncSets, s);
	    p->set = s;
	} else if (p->typ == node_alt) {
	    Tab_CompSync(self, p->sub); Tab_CompSync(self, p->down);
	} else if (p->typ == node_opt || p->typ == node_iter) {
	    CompSync(self, p->sub);
	}
	p = p->next;
    }
}

void
Tab_CompSyncSets(Tab_t * self)
{
    int idx; Symbol_t * sym;

    BitArray(&self->allSyncSets, self->terminals.Count);
    BitArray_Set(&self->allSyncSets, self->eofSy->n, TRUE);
    BitArray(&self->visited, self->nodes.Count);

    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	self->curSy = sym;
	Tab_CompSync(self->curSy->graph);
    }
}

void
Tab_SetupAnys(Tab_t * self)
{
    int idx; Node_t * p;
    for (idx = 0; idx < self->nodes.Count; ++idx) {
	p = (Node_t *)ArrayList_Get(&self->nodes, idx);
	if (p->typ == node_any) {
	    p->set = BitArray(NULL, self->terminals.Count, TRUE);
	    BitArray_Set(p->set, eofSy->n, FALSE);
	}
    }
}

void
Tab_CompDeletableSymbols(Tab_t * self)
{
    Bool_t changed; Symbol_t * sym; int idx;
    do {
	changed = FALSE;
	for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	    sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	    if (!sym->deletable && sym->graph != NULL && Node_DelGraph(sym->graph)) {
		sym->deletable = TRUE; changed = TRUE;
	    }
	}
    } while (changed);

    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	if (sym->deletable)
	    fprintf(stderr, "  %s deletable\n", sym->name);
    }
}

void
Tab_RenumberPragmas(Tab_t * self)
{
    int idx, n; Symbol_t * sym;
    n = self->terminals.Count;
    for (idx = 0; idx < self->pragmas.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->pragmas, idx);
	sym->n = n++;
    }
}

void
Tab_CompSymbolSets(Tab_t * self)
{
    int idx; Symbol_t * sym; Node_t * p;
    Tab_CompDeletableSymbols(self);
    Tab_CompFirstSets(self);
    Tab_CompFollowSets(self);
    Tab_CompAnySets(self);
    Tab_CompSyncSets(self);
    if (self->ddt[1]) {
	fprintf(self->trace, "\n");
	fprintf(self->trace, "First & follow symbols:\n");
	fprintf(self->trace, "----------------------\n\n");

	for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	    sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	    fprintf(self->trace, "%s\n", sym->name);
	    fprintf(self->trace, "first:   "); Tab_PrintSet(self, sym->first, 10);
	    fprintf(self->trace, "follow:  "); Tab_PrintSet(self, sym->follow, 10);
	    fprintf(self->trace, "\n");
	}
    }
    if (self->ddt[4]) {
	fprintf(self->trace, "\n");
	fprintf(self->trace, "ANY and SYNC sets:\n");
	fprintf(self->trace, "-----------------\n");

	for (idx = 0; idx < self->nodes.Count; ++idx) {
	    p = (Node_t *)ArrayList_Get(&self->nodes, idx);
	    if (p->typ == node_any || p->typ == node_sync) {
		fprintf(self->trace, "%4d %4s ", p->n, nTyp[p->typ]);
		Tab_PrintSet(self, p->set, 11);
	    }
	}
    }
}

Bool_t
Tab_GrammarOk(Tab_t * self)
{
    Bool_t ok = Tab_NtsComplete(self) && Tab_AllNtReached(self) &&
	Tab_NoCircularProductions(self) && Tab_AllNtToTerm(self);
    if (ok) { Tab_CheckResolvers(self); Tab_CheckLL1(self); }
    return ok;
}

void
Tab_SetDDT(Tab_t * self, const char * s)
{
    while (*s) {
	if (*s >= '0' && *s <= '9') self->ddt[*s - '0'] = TRUE;
	else switch (*s) {
	    case 'A': case 'a': self->ddt[0] = TRUE; break; /* trace automation */
	    case 'F': case 'f': self->ddt[1] = TRUE; break; /* list first/follow sets */
	    case 'G': case 'g': self->ddt[2] = TRUE; break; /* print syntax graph */
	    case 'I': case 'i': self->ddt[3] = TRUE; break; /* trace computation of first sets */
	    case 'J': case 'j': self->ddt[4] = TRUE; break; /* print ANY and SYNC sets */
	    case 'P': case 'p': self->ddt[8] = TRUE; break; /* print statistics */
	    case 'S': case 's': self->ddt[6] = TRUE; break; /* list symbol table */
	    case 'X': case 'x': self->ddt[7] = TRUE; break; /* list cross reference table */
	    default: break;
	    }
	++s;
    }
}
