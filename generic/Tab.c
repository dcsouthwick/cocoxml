/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
#include  <stdio.h>
#include  <stdlib.h>
#include  <string.h>
#include  "Tab.h"
#include  "Graph.h"
#include  "Node.h"
#include  "Symbol.h"
#include  "CharClass.h"
#include  "CharSet.h"
#include  "SortedList.h"
#include  "Position.h"

Tab_t *
Tab(Tab_t * self, Parser_t * parser) {
    self = AllocObject(self, sizeof(Tab_t));
    ArrayList(&self->terminals);
    ArrayList(&self->pragmas);
    ArrayList(&self->nonterminals);
    ArrayList(&self->nodes);
    return self;
}

Symbol_t *
Tab_NewSym(Tab_t * self, int typ, const char * name, int line)
{
    Symbol_t * sym;

    if (!strcmp(name, "\"\"")) {
	Parser_SemErr(self->parser, "empty token now allowed");
	name = "???";
    }
    sym = CocoMalloc(sizeof(Symbol_t));
    Symbol(sym, typ, name, line);

    if (typ == node_t) {
	sym->n = self->terminals.Count;
	ArrayList_Add(&self->terminals, sym);
    } else if (typ == node_pr) {
	ArrayList_Add(&self->pragmas, sym);
    } else if (typ == node_nt) {
	sym->n = self->nonterminals.Count;
	ArrayList_Add(&self->nonterminals, sym);
    }
    return sym;
}

Symbol_t *
Tab_FindSym(Tab_t * self, const char * name)
{
    int idx; Symbol_t * sym;
    for (idx = 0; idx < self->terminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->terminals, idx);
	if (!strcmp(sym->name, name)) return sym;
    }
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	if (!strcmp(sym->name, name)) return sym;
    }
    return NULL;
}

void
Tab_PrintSymbolTable(Tab_t * self)
{
    int idx; Symbol_t * sym; HTIterator_t iter;
    DumpBuffer_t dbuf; char buf[128];

    fprintf(self->trace, "Symbol Table:\n");
    fprintf(self->trace, "------------\n\n");
    fprintf(self->trace, " nr name          typ  hasAt graph  del    line tokenKind\n");

    for (idx = 0; idx < self->terminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->terminals, idx);
	DumpBuffer(&dbuf, buf, sizeof(buf));
	Symbol_Dump(sym, &dbuf);
	fprintf(self->trace, "%s\n", buf);
    }

    for (idx = 0; idx < self->pragmas.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->pragmas, idx);
	DumpBuffer(&dbuf, buf, sizeof(buf));
	Symbol_Dump(sym, &dbuf);
	fprintf(self->trace, "%s\n", buf);
    }

    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	DumpBuffer(&dbuf, buf, sizeof(buf));
	Symbol_Dump(sym, &dbuf);
	fprintf(self->trace, "%s\n", buf);
    }

    fprintf(self->trace, "\nLiteral Tokens:\n");
    fprintf(self->trace, "--------------\n");

    HashTable_GetIterator(&self->literals, &iter);
    while (HTIterator_Forward(&iter)) {
	fprintf(self->trace, "_%s =  %s.\n",
		((Symbol_t *)HTIterator_Value(&iter))->name,
		HTIterator_Key(&iter));
    }
    fprintf(self->trace, "\n");
}

void
Tab_PrintSet(Tab_t * self, BitArray_t * s, int indent)
{
    int col, len, idx; Symbol_t * sym;
    col = indent;
    for (idx = 0; idx < self->terminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->terminals, idx);
	if (!BitArray_Get(s, sym->n)) continue;
	len = strlen(sym->name);
	if (col + len >= 80) {
	    fprintf(self->trace, "\n");
	    for (col = 1; col < indent; ++col) fprintf(self->trace, " ");
	}
	fprintf(self->trace, "%s ", sym->name);
	col += len + 1;
    }
    if (col == indent) fprintf(self->trace, "-- empty set --");
    fprintf(self->trace, "\n");
}

Node_t *
Tab_NewNodeTSL(Tab_t * self, int typ, Symbol_t * sym, int line)
{
    Node_t * node;
    node = Node(NULL, typ, sym, line);
    node->n = self->nodes.Count;
    ArrayList_Add(&self->nodes, node);
    return node;
}

Node_t *
Tab_NewNodeTS(Tab_t * self, int typ, Node_t * sub)
{
    Node_t * node;
    node = Tab_NewNodeTSL(self, typ, NULL, 0);
    node->sub = sub;
    return node;
}

Node_t *
Tab_NewNodeTVL(Tab_t * self, int typ, int val, int line)
{
    Node_t * node;
    node = Tab_NewNodeTSL(self, typ, NULL, line);
    node->val = val;
    return node;
}

void
Tab_MakeFirstAlt(Tab_t * self, Graph_t * g)
{
    g->l = Tab_NewNodeTS(self, node_alt, g->l);
    g->l->line = g->l->sub->line;
    g->l->next = g->r;
    g->r = g->l;
}

void
Tab_MakeAlternative(Tab_t * self, Graph_t * g1, Graph_t * g2)
{
    Node_t * p;
    g2->l = Tab_NewNodeTS(self, node_alt, g2->l);
    g2->l->line = g2->l->sub->line;
    p = g1->l; while (p->down != NULL) p = p->down;
    p->down = g2->l;
    p = g1->r; while (p->next != NULL) p = p->next;
    p->next = g2->l;
    g2->l->next = g2->r;
}

void
Tab_MakeSequence(Tab_t * self, Graph_t * g1, Graph_t * g2)
{
    Node_t * q, * p = g1->r->next;
    g1->r->next = g2->l;
    while (p != NULL) {
	q = p->next; p->next = g2->l; p->up = TRUE;
	p = q;
    }
    g1->r = g2->r;
}

void
Tab_MakeIteration(Tab_t * self, Graph_t * g)
{
    Node_t * p, * q;
    g->l = Tab_NewNodeTS(self, node_iter, g->l);
    p = g->r;
    g->r = g->l;
    while (p != NULL) {
	q = p->next; p->next = g->l; p->up = TRUE;
	p = q;
    }
}

void
Tab_MakeOption(Tab_t * self, Graph_t * g) {
    g->l = Tab_NewNodeTS(self, node_opt, g->l);
    g->l->next = g->r;
    g->r = g->l;
}

void
Tab_Finish(Tab_t * self, Graph_t * g)
{
    Node_t * q, * p = g->r;
    while (p != NULL) {
	q = p->next; p->next = NULL; p = q;
    }
}

void
Tab_DeleteNodes(Tab_t * self)
{
    ArrayList_Clear(&self->nodes);
    self->dummyNode = Tab_NewNodeTSL(self, node_eps, NULL, 0);
}

Graph_t *
Tab_StrToGraph(Tab_t * self, const char * str)
{
    Graph_t * g; Node_t * p;
    char * s, * cur;

    s = Unescape(str);
    if (strlen(s) == 0)	Parser_SemErr(self->parser, "empty token not allowed");
    g = Graph(NULL);
    g->r = self->dummyNode;
    for (cur = s; *cur; ++cur) {
	p = Tab_NewNodeTVL(self, node_chr, (int)*cur, 0);
	g->r->next = p; g->r = p;
    }
    g->l = self->dummyNode->next; self->dummyNode->next = NULL;
    CocoFree(s);
    return g;
}

void
Tab_SetContextTrans(Tab_t * self, Node_t * p)
{
    while (p != NULL) {
	if (p->typ == node_chr || p->typ == node_clas) {
	    p->code = node_contextTrans;
	} else if (p->typ == node_opt || p->typ == node_iter) {
	    Tab_SetContextTrans(self, p->sub);
	} else if (p->typ == node_alt) {
	    Tab_SetContextTrans(self, p->sub);
	    Tab_SetContextTrans(self, p->down);
	}
	if (p->up) break;
	p = p->next;
    }
}

void
Tab_PrintNodes(Tab_t * self)
{
    Node_t * p; int idx;
    DumpBuffer_t dbuf; char lnbuf[256];
    fprintf(self->trace, "Graph nodes:\n");
    fprintf(self->trace, "----------------------------------------------------\n");
    fprintf(self->trace, "   n type name          next  down   sub   pos  line\n");
    fprintf(self->trace, "                               val  code\n");
    fprintf(self->trace, "----------------------------------------------------\n");

    for (idx = 0; idx < self->nodes.Count; ++idx) {
	p = (Node_t *)ArrayList_Get(&self->nodes, idx);
	DumpBuffer(&dbuf, lnbuf, sizeof(lnbuf));
	Node_Dump(p, &dbuf, self);
	fprintf(self->trace, "%s\n", lnbuf);
    }
    fprintf(self->trace, "\n");
}

CharClass_t *
Tab_NewCharClass(Tab_t * self, const char * name, CharSet_t * s)
{
    CharClass_t * c; char namebuf[8];
    if (!strcmp(name, "#")) {
	snprintf(namebuf, sizeof(namebuf), "#%c", self->dummyName++);
	if (!(c = CharClass(NULL, namebuf, s))) return NULL;
    } else {
	if (!(c = CharClass(NULL, name, s))) return NULL;
    }
    c->n = self->classes.Count;
    ArrayList_Add(&self->classes, c);
    return c;
}

CharClass_t *
Tab_FindCharClassS(Tab_t * self, const char * name)
{
    int idx; CharClass_t * c;
    for (idx = 0; idx < self->classes.Count; ++idx) {
	c = (CharClass_t *)ArrayList_Get(&self->classes, idx);
	if (!strcmp(c->name, name)) return c;
    }
    return NULL;
}

CharClass_t *
Tab_FindCharClassC(Tab_t * self, CharSet_t * s)
{
    int idx; CharClass_t * c;
    for (idx = 0; idx < self->classes.Count; ++idx) {
	c = (CharClass_t *)ArrayList_Get(&self->classes, idx);
	if (CharSet_Equals(s, c->set)) return c;
    }
    return NULL;
}

CharSet_t *
Tab_CharClassSet(Tab_t * self, int idx)
{
    return ((CharClass_t *)ArrayList_Get(&self->classes, idx))->set;
}

BitArray_t *
Tab_First0(Tab_t * self, Node_t * p, BitArray_t * mark)
{
    BitArray_t * fs, * fs0;
    fs = BitArray(NULL, self->terminals.Count);
    while (p != NULL && !BitArray_Get(mark, p->n)) {
	BitArray_Set(mark, p->n, TRUE);
	if (p->typ == node_nt) {
	    if (p->sym->firstReady) {
		BitArray_Or(fs, p->sym->first);
	    } else {
		fs0 = Tab_First0(self, p->sym->graph, mark);
		BitArray_Or(fs, fs0);
		BitArray_Destruct(fs0); CocoFree(fs0);
	    }
	} else if (p->typ == node_t || p->typ == node_wt) {
	    BitArray_Set(fs, p->sym->n, TRUE);
	} else if (p->typ == node_any) {
	    BitArray_Or(fs, p->set);
	} else if (p->typ == node_alt) {
	    fs0 = Tab_First0(self, p->sub, mark);
	    BitArray_Or(fs, fs0);
	    BitArray_Destruct(fs0); CocoFree(fs0);
	    fs0 = Tab_First0(self, p->down, mark);
	    BitArray_Or(fs, fs0);
	    BitArray_Destruct(fs0); CocoFree(fs0);
	} else if (p->typ == node_iter || p->typ == node_opt) {
	    fs0 = Tab_First0(self, p->sub, mark);
	    BitArray_Or(fs, fs0);
	    BitArray_Destruct(fs0); CocoFree(fs0);
	}
	if (!Node_DelNode(p)) break;
	p = p->next;
    }
    return fs;
}

BitArray_t *
Tab_First(Tab_t * self, Node_t * p)
{
    BitArray_t * mark, * fs;

    mark = BitArray(NULL, self->nodes.Count);
    fs = Tab_First0(self, p, mark);
    BitArray_Destruct(mark); CocoFree(mark);
    if (self->ddt[3]) {
	fprintf(self->trace, "\n");
	if (p != NULL) fprintf(self->trace, "First: node = %d\n", p->n);
	else fprintf(self->trace, "First: node = null\n");
	Tab_PrintSet(self, fs, 0);
    }
    return fs;
}

void
Tab_CompFirstSets(Tab_t * self)
{
    Symbol_t * sym; int idx;
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	sym->first = BitArray(NULL, self->terminals.Count);
	sym->firstReady = FALSE;
    }
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	sym->first = Tab_First(self, sym->graph);
	sym->firstReady = TRUE;
    }
}

void
Tab_CompFollow(Tab_t * self, Node_t * p)
{
    BitArray_t * s;
    while (p != NULL && !BitArray_Get(&self->visited, p->n)) {
	BitArray_Set(&self->visited, p->n, TRUE);
	if (p->typ == node_nt) {
	    s = Tab_First(self, p->next);
	    BitArray_Or(p->sym->follow, s);
	    if (Node_DelGraph(p->next))
		BitArray_Set(p->sym->nts, self->curSy->n, TRUE);
	} else if (p->typ == node_opt || p->typ == node_iter) {
	    Tab_CompFollow(self, p->sub);
	} else if (p->typ == node_alt) {
	    Tab_CompFollow(self, p->sub); Tab_CompFollow(self, p->down);
	}
	p = p->next;
    }
}

void
Tab_Complete(Tab_t * self, Symbol_t * sym)
{
    int idx; Symbol_t * s;
    if (BitArray_Get(&self->visited, sym->n)) return;
    BitArray_Set(&self->visited, sym->n, TRUE);
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	s = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	if (BitArray_Get(sym->nts, s->n)) {
	    Tab_Complete(self, s);
	    BitArray_Or(sym->follow, s->follow);
	    if (sym == self->curSy) BitArray_Set(sym->nts, s->n, FALSE);
	}
    }
}

void
Tab_CompFollowSets(Tab_t * self)
{
    int idx; Symbol_t * sym;
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	sym->follow = BitArray(NULL, self->terminals.Count);
	sym->nts = BitArray(NULL, self->nonterminals.Count);
    }
    BitArray_Set(self->gramSy->follow, self->eofSy->n, TRUE);
    BitArray(&self->visited, self->nodes.Count);
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	self->curSy = sym;
	Tab_CompFollow(self, sym->graph);
    }
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	BitArray(&self->visited, self->nonterminals.Count);
	self->curSy = sym;
	Tab_Complete(self, sym);
    }
}

Node_t *
Tab_LeadingAny(Tab_t * self, Node_t * p)
{
    Node_t * a = NULL;
    if (p == NULL) return NULL;
    if (p->typ == node_any) a = p;
    else if (p->typ == node_alt) {
	a = Tab_LeadingAny(self, p->sub);
	if (a == NULL) a = Tab_LeadingAny(self, p->down);
    } else if (p->typ == node_opt || p->typ == node_iter) {
	a = Tab_LeadingAny(self, p->sub);
    } else if (Node_DelNode(p) && !p->up) {
	a = Tab_LeadingAny(self, p->next);
    }
    return a;
}

void
Tab_FindAS(Tab_t * self, Node_t * p)
{
    Node_t * a, * q; BitArray_t * s1, * tmp, * f;
    while (p != NULL) {
	if (p->typ == node_opt || p->typ == node_iter) {
	    Tab_FindAS(self, p->sub);
	    a = Tab_LeadingAny(self, p->sub);
	    if (a != NULL)
		BitArray_Subtract(a->set, Tab_First(self, p->next));
	} else if (p->typ == node_alt) {
	    s1 = BitArray(NULL, self->terminals.Count);
	    q = p;
	    while (q != NULL) {
		Tab_FindAS(self, q->sub);
		a = Tab_LeadingAny(self, q->sub);
		if (a != NULL) {
		    tmp = Tab_First(self, q->down);
		    BitArray_Or(tmp, s1);
		    BitArray_Subtract(a->set, tmp);
		} else {
		    f = Tab_First(self, q->sub);
		    BitArray_Or(s1, f);
		    BitArray_Destruct(f); CocoFree(f);
		}
		q = q->down;
	    }
	}
	if (p->up) break;
	p = p->next;
    }
}

void
Tab_CompAnySets(Tab_t * self)
{
    int idx; Symbol_t * sym;
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	Tab_FindAS(self, sym->graph);
    }
}

BitArray_t *
Tab_Expected(Tab_t * self, Node_t * p, Symbol_t * curSy)
{
    BitArray_t * s = Tab_First(self, p);
    if (Node_DelGraph(p)) BitArray_Or(s, curSy->follow);
    return s;
}

BitArray_t *
Tab_Expected0(Tab_t * self, Node_t * p, Symbol_t * curSy)
{
    if (p->typ == node_rslv) return BitArray(NULL, self->terminals.Count);
    else return Tab_Expected(self, p, curSy);
}

void
Tab_CompSync(Tab_t * self, Node_t * p)
{
    BitArray_t * s;
    while (p != NULL && !BitArray_Get(&self->visited, p->n)) {
	BitArray_Set(&self->visited, p->n, TRUE);
	if (p->typ == node_sync) {
	    s = Tab_Expected(self, p->next, self->curSy);
	    BitArray_Set(s, self->eofSy->n, TRUE);
	    BitArray_Or(&self->allSyncSets, s);
	    p->set = s;
	} else if (p->typ == node_alt) {
	    Tab_CompSync(self, p->sub); Tab_CompSync(self, p->down);
	} else if (p->typ == node_opt || p->typ == node_iter) {
	    Tab_CompSync(self, p->sub);
	}
	p = p->next;
    }
}

void
Tab_CompSyncSets(Tab_t * self)
{
    int idx; Symbol_t * sym;

    BitArray(&self->allSyncSets, self->terminals.Count);
    BitArray_Set(&self->allSyncSets, self->eofSy->n, TRUE);
    BitArray(&self->visited, self->nodes.Count);

    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	self->curSy = sym;
	Tab_CompSync(self, self->curSy->graph);
    }
}

void
Tab_SetupAnys(Tab_t * self)
{
    int idx; Node_t * p;
    for (idx = 0; idx < self->nodes.Count; ++idx) {
	p = (Node_t *)ArrayList_Get(&self->nodes, idx);
	if (p->typ == node_any) {
	    p->set = BitArray1(NULL, self->terminals.Count);
	    BitArray_Set(p->set, self->eofSy->n, FALSE);
	}
    }
}

void
Tab_CompDeletableSymbols(Tab_t * self)
{
    Bool_t changed; Symbol_t * sym; int idx;
    do {
	changed = FALSE;
	for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	    sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	    if (!sym->deletable && sym->graph != NULL &&
		Node_DelGraph(sym->graph)) {
		sym->deletable = TRUE; changed = TRUE;
	    }
	}
    } while (changed);

    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	if (sym->deletable)
	    fprintf(stderr, "  %s deletable\n", sym->name);
    }
}

void
Tab_RenumberPragmas(Tab_t * self)
{
    int idx, n; Symbol_t * sym;
    n = self->terminals.Count;
    for (idx = 0; idx < self->pragmas.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->pragmas, idx);
	sym->n = n++;
    }
}

void
Tab_CompSymbolSets(Tab_t * self)
{
    int idx; Symbol_t * sym; Node_t * p;
    Tab_CompDeletableSymbols(self);
    Tab_CompFirstSets(self);
    Tab_CompFollowSets(self);
    Tab_CompAnySets(self);
    Tab_CompSyncSets(self);
    if (self->ddt[1]) {
	fprintf(self->trace, "\n");
	fprintf(self->trace, "First & follow symbols:\n");
	fprintf(self->trace, "----------------------\n\n");

	for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	    sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	    fprintf(self->trace, "%s\n", sym->name);
	    fprintf(self->trace, "first:   ");
	    Tab_PrintSet(self, sym->first, 10);
	    fprintf(self->trace, "follow:  ");
	    Tab_PrintSet(self, sym->follow, 10);
	    fprintf(self->trace, "\n");
	}
    }
    if (self->ddt[4]) {
	fprintf(self->trace, "\n");
	fprintf(self->trace, "ANY and SYNC sets:\n");
	fprintf(self->trace, "-----------------\n");

	for (idx = 0; idx < self->nodes.Count; ++idx) {
	    p = (Node_t *)ArrayList_Get(&self->nodes, idx);
	    if (p->typ == node_any || p->typ == node_sync) {
		fprintf(self->trace, "%4d %4s ", p->n, nTyp[p->typ]);
		Tab_PrintSet(self, p->set, 11);
	    }
	}
    }
}

Bool_t
Tab_GrammarOk(Tab_t * self)
{
    Bool_t ok = Tab_NtsComplete(self) && Tab_AllNtReached(self) &&
	Tab_NoCircularProductions(self) && Tab_AllNtToTerm(self);
    if (ok) { Tab_CheckResolvers(self); Tab_CheckLL1(self); }
    return ok;
}

typedef struct {
    Symbol_t * left, * right;
}  CNode_t;

static CNode_t *
CNode(Symbol_t * l, Symbol_t * r)
{
    CNode_t * self = CocoMalloc(sizeof(CNode_t));
    self->left = l; self->right = r;
    return self;
}

void
Tab_GetSingles(Tab_t * self, Node_t * p, ArrayList_t * singles)
{
    if (p == NULL) return;
    if (p->typ == node_nt) {
	if (p->up || Node_DelGraph(p->next)) ArrayList_Add(singles, p->sym);
    } else if (p->typ == node_alt || p->typ == node_iter ||
	       p->typ == node_opt) {
	if (p->up || Node_DelGraph(p->next)) {
	    Tab_GetSingles(self, p->sub, singles);
	    if (p->typ == node_alt) Tab_GetSingles(self, p->down, singles);
	}
    }
    if (!p->up && Node_DelNode(p)) Tab_GetSingles(self, p->next, singles);
}

Bool_t
Tab_NoCircularProductions(Tab_t * self)
{
    Bool_t ok, changed, onLeftSide, onRightSide;
    Symbol_t * sym, * s; int idx, idxj;
    CNode_t * m, * n;
    ArrayList_t list, singles;

    ArrayList(&list);
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	ArrayList(&singles);
	Tab_GetSingles(self, sym->graph, &singles);
	for (idxj = 0; idxj < singles.Count; ++idxj) {
	    s = (Symbol_t *)ArrayList_Get(&singles, idxj);
	    ArrayList_Add(&list, CNode(sym, s));
	}
    }

    do {
	changed = FALSE;
	for (idx = 0; idx < list.Count; ++idx) {
	    n = (CNode_t *)ArrayList_Get(&list, idx);
	    onLeftSide = FALSE; onRightSide = FALSE;
	    for (idxj = 0; idxj < list.Count; ++idxj) {
		m = (CNode_t *)ArrayList_Get(&list, idxj);
		if (n->left == m->right) onRightSide = TRUE;
		if (n->right == m->left) onLeftSide = TRUE;
	    }
	    if (!onLeftSide || !onRightSide) {
		ArrayList_Remove(&list, n); --idx; changed = TRUE;
	    }
	}
    } while (changed);
    ok = TRUE;

    for (idx = 0; idx < list.Count; ++idx) {
	n = (CNode_t *)ArrayList_Get(&list, idx);
	ok = FALSE; self->errors->count++;
	fprintf(stderr, "  %s --> %s", n->left->name, n->right->name);
    }
    return ok;
}

void
Tab_LL1Error(Tab_t * self, int cond, Symbol_t * sym)
{
    fprintf(stderr, "  LL1 warning in %s: ", self->curSy->name);
    if (sym != NULL) fprintf(stderr, "%s is ", sym->name);
    switch (cond) {
    case 1: fprintf(stderr, "start of several alternatives\n"); break;
    case 2: fprintf(stderr, "start & successor of deletable structure\n"); break;
    case 3: fprintf(stderr, "an ANY node that matches no symbol\n"); break;
    case 4: fprintf(stderr, "contents of [...] or {...} must not be deletable\n"); break;
    }
}

void
Tab_CheckOverlap(Tab_t * self, BitArray_t * s1, BitArray_t * s2, int cond)
{
    int idx; Symbol_t * sym;
    for (idx = 0; idx < self->terminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->terminals, idx);
	if (BitArray_Get(s1, sym->n) && BitArray_Get(s2, sym->n)) {
	    Tab_LL1Error(self, cond, sym);
	}
    }
}

void
Tab_CheckAlts(Tab_t * self, Node_t * p)
{
    BitArray_t * s1, * s2; Node_t * q;
    while (p != NULL) {
	if (p->typ == node_alt) {
	    q = p;
	    s1 = BitArray(NULL, self->terminals.Count);
	    while (q != NULL) {
		s2 = Tab_Expected0(self, q->sub, self->curSy);
		Tab_CheckOverlap(self, s1, s2, 1);
		BitArray_Or(s1, s2);
		Tab_CheckAlts(self, q->sub);
		q = q->down;
	    }
	} else if (p->typ == node_opt || p->typ == node_iter) {
	    if (Node_DelSubGraph(p->sub)) Tab_LL1Error(self, 4, NULL);
	    else {
		s1 = Tab_Expected0(self, p->sub, self->curSy);
		s2 = Tab_Expected(self, p->next, self->curSy);
		Tab_CheckOverlap(self, s1, s2, 2);
	    }
	    Tab_CheckAlts(self, p->sub);
	} else if (p->typ == node_any) {
	    if (BitArray_Elements(p->set) == 0) Tab_LL1Error(self, 3, NULL);
	}
	if (p->up) break;
	p = p->next;
    }
}

void
Tab_CheckLL1(Tab_t * self)
{
    int idx; Symbol_t * sym;
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	self->curSy = sym;
	Tab_CheckAlts(self, self->curSy->graph);
    }
}

void
Tab_ResErr(Tab_t * self, Node_t * p, const char * msg)
{
    Errors_Warning(self->errors, p->line, p->pos->col, msg);
}

void
Tab_CheckRes(Tab_t * self, Node_t * p, Bool_t rslvAllowed)
{
    Node_t * q; BitArray_t * expected, * soFar, * fs;
    while (p != NULL) {
	if (p->typ == node_alt) {
	    expected = BitArray(NULL, self->terminals.Count);
	    for (q = p; q != NULL; q = q->down)
		BitArray_Or(expected, Tab_Expected0(self, q->sub, self->curSy));
	    soFar = BitArray(NULL, self->terminals.Count);
	    for (q = p; q != NULL; q = q->down) {
		if (q->sub->typ == node_rslv) {
		    fs = Tab_Expected(self, q->sub->next, self->curSy);
		    if (BitArray_Intersect(fs, soFar))
			Tab_ResErr(self, q->sub, "Warning: Resolver will never be evaluated. Place it at previous conflicting alternative.");
		    if (!BitArray_Intersect(fs, expected))
			Tab_ResErr(self, q->sub, "Warning: Misplaced resolver: no LL(1) conflict.");
		} else
		    BitArray_Or(soFar, Tab_Expected(self, q->sub, self->curSy));
		Tab_CheckRes(self, q->sub, TRUE);
	    }
	} else if (p->typ == node_iter || p->typ == node_opt) {
	    if (p->sub->typ == node_rslv) {
		BitArray_t * fs = Tab_First(self, p->sub->next);
		BitArray_t * fsNext = Tab_Expected(self, p->next, self->curSy);
		if (!BitArray_Intersect(fs, fsNext))
		    Tab_ResErr(self, p->sub, "Warning: Misplaced resolver: no LL(1) conflict.");
	    }
	    Tab_CheckRes(self, p->sub, TRUE);
	} else if (p->typ == node_rslv) {
	    if (rslvAllowed)
		Tab_ResErr(self, p, "Warning: Misplaced resolver: no alternative.");
	}
	if (p->up) break;
	p = p->next;
	rslvAllowed = FALSE;
    }
}

void
Tab_CheckResolvers(Tab_t * self)
{
    int idx;
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	self->curSy = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	Tab_CheckRes(self, self->curSy->graph, FALSE);
    }
}

Bool_t
Tab_NtsComplete(Tab_t * self)
{
    Bool_t complete = TRUE;
    int idx; Symbol_t * sym;
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	if (sym->graph == NULL) {
	    complete = FALSE; self->errors->count++;
	    fprintf(stderr, "  No production for %s\n", sym->name);
	}
    }
    return complete;
}

void
Tab_MarkReachedNts(Tab_t * self, Node_t * p)
{
    while (p != NULL) {
	if (p->typ == node_nt && BitArray_Get(&self->visited, p->sym->n)) {
	    BitArray_Set(&self->visited, p->sym->n, TRUE);
	    Tab_MarkReachedNts(self, p->sym->graph);
	} else if (p->typ == node_alt || p->typ == node_iter || p->typ == node_opt) {
	    Tab_MarkReachedNts(self, p->sub);
	    if (p->typ == node_alt) Tab_MarkReachedNts(self, p->down);
	}
	if (p->up) break;
	p = p->next;
    }
}

Bool_t
Tab_AllNtReached(Tab_t * self)
{
    Bool_t ok = TRUE;
    int idx; Symbol_t * sym;

    BitArray(&self->visited, self->nonterminals.Count);
    BitArray_Set(&self->visited, self->gramSy->n, TRUE);
    Tab_MarkReachedNts(self, self->gramSy->graph);
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	if (!BitArray_Get(&self->visited, sym->n)) {
	    ok = FALSE; self->errors->count++;
	    fprintf(stderr, "  %s cannot be reached\n", sym->name);
	}
    }
    return ok;
}

Bool_t
Tab_IsTerm(Tab_t * self, Node_t * p, BitArray_t * mark)
{
    while (p != NULL) {
	if (p->typ == node_nt && BitArray_Get(mark, p->sym->n)) return FALSE;
	if (p->typ == node_alt && !Tab_IsTerm(self, p->sub, mark) &&
	    (p->down == NULL || !Tab_IsTerm(self, p->down, mark)))
	    return FALSE;
	if (p->up) break;
	p = p->next;
    }
    return TRUE;
}

Bool_t
Tab_AllNtToTerm(Tab_t * self)
{
    Bool_t changed, ok = TRUE;
    BitArray_t mark;
    Symbol_t * sym;
    int idx;

    BitArray(&mark, self->nonterminals.Count);
    do {
	changed = FALSE;
	for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	    sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	    if (!BitArray_Get(&mark, sym->n) &&
		Tab_IsTerm(self, sym->graph, &mark)) {
		BitArray_Set(&mark, sym->n, TRUE); changed = TRUE;
	    }
	}
    } while (changed);
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	if (!BitArray_Get(&mark, sym->n)) {
	    ok = FALSE; self->errors->count++;
	    fprintf(stderr, "  %s cannot be derived to terminals\n", sym->name);
	}
    }
    return ok;
}

void
Tab_XRef(Tab_t * self)
{
    SortedList_t xref;
    Symbol_t * sym;
    int idx, idxj;
    ArrayList_t * list;
    Node_t * n;
    char paddedName[13];
    int col, line;

    SortedList(&xref);
    for (idx = 0; idx < self->nonterminals.Count; ++idx) {
	sym = (Symbol_t *)ArrayList_Get(&self->nonterminals, idx);
	list = (ArrayList_t *)SortedList_Get(&xref, sym);
	if (list == NULL) SortedList_Set(&xref, sym, list = ArrayList(NULL));
	ArrayList_Add(list, (void *)(-sym->line));
    }
    for (idx = 0; idx < self->nodes.Count; ++idx) {
	n = (Node_t *)ArrayList_Get(&self->nodes, idx);
	if (n->typ == node_t || n->typ == node_wt || n->typ == node_nt) {
	    list = (ArrayList_t *)SortedList_Get(&xref, n->sym);
	    if (list == NULL) SortedList_Set(&xref, sym, list = ArrayList(NULL));
	    ArrayList_Add(list, (void *)(n->line));
	}
    }
    fprintf(self->trace, "\n");
    fprintf(self->trace, "Cross reference list:\n");
    fprintf(self->trace, "--------------------\n\n");
    for (idx = 0; idx < xref.Count; ++idx) {
	sym = (Symbol_t *)SortedList_GetKey(&xref, idx);
	snprintf(paddedName, sizeof(paddedName), "%s            ", sym->name);
	fprintf(self->trace, "  %12s", paddedName);
	list = (ArrayList_t *)SortedList_Get(&xref, sym);
	col = 14;
	for (idxj = 0; idxj < list->Count; ++idxj) {
	    line = (int)ArrayList_Get(list, idx);
	    if (col + 5 > 80) {
		fprintf(self->trace, "\n");
		for (col = 1; col <= 14; ++col)
		    fprintf(self->trace, " ");
	    }
	    fprintf(self->trace, "%5d", line); col += 5;
	}
	fprintf(self->trace, "\n");
    }
    fprintf(self->trace, "\n\n");
}

void
Tab_SetDDT(Tab_t * self, const char * s)
{
    while (*s) {
	if (*s >= '0' && *s <= '9') self->ddt[*s - '0'] = TRUE;
	else switch (*s) {
	    case 'A': case 'a': self->ddt[0] = TRUE; break; /* trace automation */
	    case 'F': case 'f': self->ddt[1] = TRUE; break; /* list first/follow sets */
	    case 'G': case 'g': self->ddt[2] = TRUE; break; /* print syntax graph */
	    case 'I': case 'i': self->ddt[3] = TRUE; break; /* trace computation of first sets */
	    case 'J': case 'j': self->ddt[4] = TRUE; break; /* print ANY and SYNC sets */
	    case 'P': case 'p': self->ddt[8] = TRUE; break; /* print statistics */
	    case 'S': case 's': self->ddt[6] = TRUE; break; /* list symbol table */
	    case 'X': case 'x': self->ddt[7] = TRUE; break; /* list cross reference table */
	    default: break;
	    }
	++s;
    }
}
