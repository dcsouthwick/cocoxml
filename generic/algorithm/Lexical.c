/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
#include  "Lexical.h"
#include  "ArrayList.h"
#include  "BitArray.h"
#include  "Globals.h"
#include  "lexical/Action.h"
#include  "lexical/CharSet.h"
#include  "lexical/CharClass.h"
#include  "lexical/Comment.h"
#include  "lexical/Melted.h"
#include  "lexical/Nodes.h"
#include  "lexical/State.h"
#include  "lexical/Target.h"

/* SZ_LITERALS is a prime number, auto-extending is not supported now */
#define  SZ_LITERALS 127

static void
CcLexical_GetTargetStates(CcLexical_t * self, CcAction_t * a,
			  CcBitArray_t ** targets, CcSymbol_t ** endOf,
			  CcsBool_t * ctx);
static CcMelted_t *
CcLexical_NewMelted(CcLexical_t * self, CcBitArray_t * set, CcState_t * state);
static CcBitArray_t * CcLexical_MeltedSet(CcLexical_t * self, int nr);
static CcMelted_t *
CcLexical_StateWithSet(CcLexical_t * self, CcBitArray_t * s);

CcLexical_t *
CcLexical(CcLexical_t * self, CcGlobals_t * globals)
{
    self = (CcLexical_t *)CcEBNF(&self->base);
    self->globals = globals;

    self->ignored = CcCharSet();
    self->ignoreCase = FALSE;
    CcArrayList(&self->states);
    CcArrayList(&self->classes);
    CcHashTable(&self->literals, SZ_LITERALS);
    self->firstMelted = NULL;
    self->firstComment = NULL;

    self->lastSimState = 0;
    self->curSy = NULL;
    self->curGraph = NULL;
    self->dirtyLexical = FALSE;
    self->hasCtxMoves = FALSE;

    CcArrayList_New(&self->states, stateType);
    return self;
}

void
CcLexical_Destruct(CcLexical_t * self)
{
    CcComment_t * cur, * next;

    for (cur = self->firstComment; cur; cur = next) {
	next = cur->next;
	CcComment_Destruct(cur);
    }
    CcHashTable_Destruct(&self->literals);
    CcArrayList_Destruct(&self->classes);
    CcCharSet_Destruct(self->ignored);
    CcEBNF_Destruct(&self->base);
}

CcGraph_t *
CcLexical_StrToGraph(CcLexical_t * self, const char * str, const CcsToken_t * t)
{
    CcGraph_t * g; CcTransition_t trans;
    const char * cur, * slast;
    char * s;
    if ((s = CcsUnescape(str)) == NULL)
	CcsGlobals_Fatal(&self->globals->base, t,
			 "Invalid character encountered or out of memory.");
    if (strlen(s) == 0)
	CcsGlobals_SemErr(&self->globals->base, t, "empty token not allowed");
    g = CcGraph();
    cur = s; slast = s + strlen(s);
    while (cur < slast) {
	CcTransition(&trans, CcsUTF8GetCh(&cur, slast), trans_normal, &self->classes);
	CcGraph_Append(g, CcEBNF_NewNode(&self->base, node_trans, &trans));
	CcTransition_Destruct(&trans);
    }
    CcFree(s);
    return g;
}

void
CcLexical_SetContextTrans(CcLexical_t * self, CcNode_t * p)
{
    while (p != NULL) {
	if (p->base.type == node_trans) {
	    CcTransition_SetCode(&((CcNodeTrans_t *)p)->trans, trans_context);
	} else if (p->base.type == node_opt || p->base.type == node_iter) {
	    CcLexical_SetContextTrans(self, p->sub);
	} else if (p->base.type == node_alt) {
	    CcLexical_SetContextTrans(self, p->sub);
	    CcLexical_SetContextTrans(self, p->down);
	}
	if (p->up) break;
	p = p->next;
    }
}

CcCharClass_t *
CcLexical_NewCharClass(CcLexical_t * self, const char * name, CcCharSet_t * s)
{
    return (CcCharClass_t *)
	CcArrayList_New(&self->classes, char_class, name, s);
}

CcCharClass_t *
CcLexical_FindCharClassN(CcLexical_t * self, const char * name)
{
    CcCharClass_t * c; CcArrayListIter_t iter;
    for (c = (CcCharClass_t *)CcArrayList_First(&self->classes, &iter);
	 c; c = (CcCharClass_t *)CcArrayList_Next(&self->classes, &iter))
	if (!strcmp(name, c->name)) return c;
    return NULL;
}

CcCharSet_t *
CcLexical_CharClassSet(CcLexical_t * self, int index)
{
    return ((CcCharClass_t *)CcArrayList_Get(&self->classes, index))->set;
}

static void
CcLexical_NewTransition(CcLexical_t * self, CcState_t * from, CcState_t * to,
			const CcTransition_t * trans)
{
    CcTarget_t * t; CcAction_t * a;

    if (to == (CcState_t *)CcArrayList_Get(&self->states, 0))
	CcsGlobals_SemErr(&self->globals->base, NULL,
			  "token must not start with an iteration");
    t = CcTarget(to);
    a = CcAction(trans); a->target = t;
    CcState_AddAction(from, a);
}

static void
CcLexical_CombineShifts(CcLexical_t * self)
{
    CcState_t * state; CcArrayListIter_t iter;
    CcAction_t * a, * b, * c;
    CcCharSet_t * seta, * setb;

    for (state = (CcState_t *)CcArrayList_First(&self->states, &iter);
	 state; state = (CcState_t *)CcArrayList_Next(&self->states, &iter)) {
	for (a = state->firstAction; a != NULL; a = a->next) {
	    b = a->next;
	    while (b != NULL)
		if (a->target->state == b->target->state &&
		    a->trans.code == b->trans.code) {
		    seta = CcAction_GetShift(a);
		    setb = CcAction_GetShift(b);
		    CcCharSet_Or(seta, setb);
		    CcAction_SetShift(a, seta);
		    c = b; b = b->next; CcState_DetachAction(state, c);
		} else {
		    b = b->next;
		}
	}
    }
}

static void
CcLexical_FindUsedStates(CcLexical_t * self, CcState_t * state,
			 CcBitArray_t * used)
{
    CcAction_t * a;

    if (CcBitArray_Get(used, state->base.index)) return;
    CcBitArray_Set(used, state->base.index, TRUE);
    for (a = state->firstAction; a != NULL; a = a->next)
	CcLexical_FindUsedStates(self, a->target->state, used);
}

static CcObject_t *
state_filter(CcObject_t * object, int curidx, int newidx, void * data)
{
    if (CcBitArray_Get((CcBitArray_t *)data, curidx)) return object;
    CcObject_VDestruct(object);
    return NULL;
}

static void
CcLexical_DeleteRedundantStates(CcLexical_t * self)
{
    CcArrayListIter_t iter, iter0;
    CcState_t * s1, * s2, * state;
    CcBitArray_t used;
    CcAction_t * a;
    CcState_t ** newState = (CcState_t **)
	CcMalloc(sizeof(CcState_t *) * (self->states.Count));

    CcBitArray(&used, self->states.Count);

    s1 = (CcState_t *)CcArrayList_First(&self->states, &iter);
    CcLexical_FindUsedStates(self, s1, &used);
    while (s1) {
	if (CcBitArray_Get(&used, s1->base.index) && s1->endOf != NULL &&
	    s1->firstAction == NULL && !(s1->ctx)) {
	    CcArrayListIter_Copy(&iter0, &iter);
	    for (s2 = (CcState_t *)CcArrayList_Next(&self->states, &iter0);
		 s2; s2 = (CcState_t *)CcArrayList_Next(&self->states, &iter0)) {
		if (CcBitArray_Get(&used, s2->base.index) &&
		    s1->endOf == s2->endOf &&
		    s2->firstAction == NULL && !(s2->ctx)) {
		    CcBitArray_Set(&used, s2->base.index, FALSE);
		    newState[s2->base.index] = s1;
		}
	    }
	}
	s1 = (CcState_t *)CcArrayList_Next(&self->states, &iter);
    }

    for (state = (CcState_t *)CcArrayList_First(&self->states, &iter);
	 state; state = (CcState_t *)CcArrayList_Next(&self->states, &iter))
	if (CcBitArray_Get(&used, state->base.index))
	    for (a = state->firstAction; a != NULL; a = a->next)
		if (!CcBitArray_Get(&used, a->target->state->base.index))
		    a->target->state = newState[a->target->state->base.index];

    /* delete unused states */
    CcArrayList_Filter(&self->states, state_filter, &used);
    CcFree(newState);
    CcBitArray_Destruct(&used);
}

static CcState_t *
CcLexical_TheState(CcLexical_t * self, CcNode_t * p)
{
    CcState_t * state;

    if (p != NULL)  return p->state;
    state = (CcState_t *)CcArrayList_New(&self->states, stateType);
    state->endOf = self->curSy;
    return state;
}

static void
CcLexical_Step(CcLexical_t * self, CcState_t * from, CcNode_t * p, CcBitArray_t * stepped)
{
    CcBitArray_t newStepped;

    if (p == NULL) return;
    CcBitArray_Set(stepped, p->base.index, TRUE);
    if (p->base.type == node_trans) {
	CcLexical_NewTransition(self, from, CcLexical_TheState(self, p->next),
				&((CcNodeTrans_t *)p)->trans);
    } else if (p->base.type == node_alt) {
	CcLexical_Step(self, from, p->sub, stepped);
	CcLexical_Step(self, from, p->down, stepped);
    } else if (p->base.type == node_iter || p->base.type == node_opt) {
	if (p->next != NULL && CcBitArray_Get(stepped, p->next->base.index))
	    CcLexical_Step(self, from, p->next, stepped);
	CcLexical_Step(self, from, p->sub, stepped);
	if ((p->base.type == node_iter) && (p->state != from)) {
	    CcBitArray(&newStepped, self->base.nodes.Count);
	    CcLexical_Step(self, p->state, p, &newStepped);
	    CcBitArray_Destruct(&newStepped);
	}
    }
}

static void
CcLexical_NumberNodes(CcLexical_t * self, CcNode_t * p,
		      CcState_t * state, CcsBool_t renumIter)
{
    if (p == NULL) return;
    if (p->state != NULL) return; /* already visited */
    if ((state == NULL) || (p->base.type == node_iter && renumIter))
	state = (CcState_t *)CcArrayList_New(&self->states, stateType);
    p->state = state;
    if (CcNode_DelGraph(p))
	state->endOf = self->curSy;

    if (p->base.type == node_trans) {
	CcLexical_NumberNodes(self, p->next, NULL, FALSE);
    } else if (p->base.type == node_opt) {
	CcLexical_NumberNodes(self, p->next, NULL, FALSE);
	CcLexical_NumberNodes(self, p->sub, state, TRUE);
    } else if (p->base.type == node_iter) {
	CcLexical_NumberNodes(self, p->next, state, TRUE);
	CcLexical_NumberNodes(self, p->sub, state, TRUE);
    } else if (p->base.type == node_alt) {
	CcLexical_NumberNodes(self, p->next, NULL, FALSE);
	CcLexical_NumberNodes(self, p->sub, state, TRUE);
	CcLexical_NumberNodes(self, p->down, state, renumIter);
    }
}

static void
CcLexical_FindTrans(CcLexical_t * self, CcNode_t * p, CcsBool_t start, CcBitArray_t * marked)
{
    CcBitArray_t stepped;

    if (p == NULL || CcBitArray_Get(marked, p->base.index)) return;
    CcBitArray_Set(marked, p->base.index, TRUE);
    if (start) {
	CcBitArray(&stepped, self->base.nodes.Count);
	/* start of group of equally numbered nodes */
	CcLexical_Step(self, p->state, p, &stepped);
	CcBitArray_Destruct(&stepped);
    }

    if (p->base.type == node_trans) {
	CcLexical_FindTrans(self, p->next, TRUE, marked);
    } else if (p->base.type == node_opt) {
	CcLexical_FindTrans(self, p->next, TRUE, marked);
	CcLexical_FindTrans(self, p->sub, FALSE, marked);
    } else if (p->base.type == node_iter) {
	CcLexical_FindTrans(self, p->next, FALSE, marked);
	CcLexical_FindTrans(self, p->sub, FALSE, marked);
    } else if (p->base.type == node_alt) {
	CcLexical_FindTrans(self, p->sub, FALSE, marked);
	CcLexical_FindTrans(self, p->down, FALSE, marked);
    }
}

void
CcLexical_ConvertToStates(CcLexical_t * self, CcNode_t * p, CcSymbol_t * sym)
{
    CcBitArray_t stepped, marked;
    CcState_t * firstState = (CcState_t *)CcArrayList_Get(&self->states, 0);

    CcsAssert(sym->base.type == symbol_t || sym->base.type == symbol_pr);
    self->curGraph = p; self->curSy = sym;
    if (CcNode_DelGraph(self->curGraph))
	CcsGlobals_SemErr(&self->globals->base, NULL, "token might be empty");
    CcLexical_NumberNodes(self, self->curGraph, firstState, TRUE);

    CcBitArray(&marked, self->base.nodes.Count);
    CcLexical_FindTrans(self, self->curGraph, TRUE, &marked);
    CcBitArray_Destruct(&marked);

    if (p->base.type == node_iter) {
	CcBitArray(&stepped, self->base.nodes.Count);
	CcLexical_Step(self, firstState, p, &stepped);
	CcBitArray_Destruct(&stepped);
    }
}

/* match string against current automaton; store it either as a
 * fixedToken or as a litToken */
void
CcLexical_MatchLiteral(CcLexical_t * self, const CcsToken_t * t,
		       const char * s, CcSymbol_t * sym)
{
    char * s0;
    const char * scur, * slast;
    CcState_t * to, * state;
    CcAction_t * a;
    CcTransition_t trans;
    CcSymbol_t * matchedSym;
    CcState_t * firstState = (CcState_t *)CcArrayList_Get(&self->states, 0);

    if ((s0 = CcsUnescape(s)) == NULL)
	CcsGlobals_Fatal(&self->globals->base, t,
			 "Invalid character encountered or out of memory.");
    state = firstState; a = NULL;
    CcsAssert(sym->base.type == symbol_t || sym->base.type == symbol_pr);
    /* Try to match s against existing CcLexical. */
    scur = s0; slast = scur + strlen(s0);
    while (scur < slast) {
	a = CcState_FindAction(state, CcsUTF8GetCh(&scur, slast));
	if (a == NULL) break;
	state = a->target->state;
    }

    /* if s was not totally consumed or leads to a non-final state => make
     * new CcLexical from it */
    if (*scur || state->endOf == NULL) {
	state = firstState; scur = s0; a = NULL;
	self->dirtyLexical = TRUE;
    }
    while (scur < slast) { /* make new CcLexical for s0[i..len-1] */
	to = (CcState_t *)CcArrayList_New(&self->states, stateType);
	CcTransition(&trans, CcsUTF8GetCh(&scur, slast),
		     trans_normal, &self->classes);
	CcLexical_NewTransition(self, state, to, &trans);
	CcTransition_Destruct(&trans);
	state = to;
    }
    CcFree(s0);

    matchedSym = state->endOf;
    if (state->endOf == NULL) {
	state->endOf = sym;
    } else if (CcSymbol_GetTokenKind(matchedSym) == symbol_fixedToken ||
	       (a != NULL && a->trans.code == trans_context)) {
	/* s matched a token with a fixed definition or a token with
	 * an appendix that will be cut off */
	CcsGlobals_SemErr(&self->globals->base, NULL,
			  "tokens %ls and %ls cannot be distinguished",
			  sym->name, matchedSym->name);
    } else { /* matchedSym == classToken || classLitToken */
	CcSymbol_SetTokenKind(matchedSym, symbol_litToken);
	CcSymbol_SetTokenKind(sym, symbol_litToken);
    }
}

static void
CcLexical_MeltStates(CcLexical_t * self, CcState_t * state)
{
    CcsBool_t changed, ctx;
    CcBitArray_t * targets;
    CcSymbol_t * endOf;
    CcAction_t * action;
    CcMelted_t * melt;
    CcState_t * s;
    CcTarget_t * targ;

    for (action = state->firstAction; action != NULL; action = action->next) {
	if (action->target->next != NULL) {
	    CcLexical_GetTargetStates(self, action, &targets, &endOf, &ctx);
	    melt = CcLexical_StateWithSet(self, targets);
	    if (melt == NULL) {
		s = (CcState_t *)CcArrayList_New(&self->states, stateType);
		s->endOf = endOf; s->ctx = ctx;
		for (targ = action->target; targ != NULL; targ = targ->next)
		    CcState_MeltWith(s, targ->state);
		do { changed = CcState_MakeUnique(s); } while (changed);
		melt = CcLexical_NewMelted(self, targets, s);
	    }
	    action->target->next = NULL;
	    action->target->state = melt->state;
	}
    }
}

static void
CcLexical_FindCtxStates(CcLexical_t * self)
{
    CcState_t * state; CcArrayListIter_t iter;
    CcAction_t * action;

    for (state = (CcState_t *)CcArrayList_First(&self->states, &iter);
	 state; state = (CcState_t *)CcArrayList_Next(&self->states, &iter))
	for (action = state->firstAction; action; action = action->next)
	    if (action->trans.code == trans_context)
		action->target->state->ctx = TRUE;
}

void
CcLexical_MakeDeterministic(CcLexical_t * self)
{
    CcState_t * state; CcArrayListIter_t iter;
    CcsBool_t  changed;

    self->lastSimState = self->states.Count;
    /* heuristic for set size in CcMelted.set */
    self->maxStates = self->lastSimState + self->lastSimState;
    CcLexical_FindCtxStates(self);

    for (state = (CcState_t *)CcArrayList_First(&self->states, &iter);
	 state; state = (CcState_t *)CcArrayList_Next(&self->states, &iter))
	do { changed = CcState_MakeUnique(state); } while (changed);
    for (state = (CcState_t *)CcArrayList_First(&self->states, &iter);
	 state; state = (CcState_t *)CcArrayList_Next(&self->states, &iter))
	CcLexical_MeltStates(self, state);
    CcLexical_DeleteRedundantStates(self);
    CcLexical_CombineShifts(self);
}

/* ------------------------- melted states ------------------------------ */
static CcMelted_t *
CcLexical_NewMelted(CcLexical_t * self, CcBitArray_t * set, CcState_t * state)
{
    CcMelted_t * m = CcMelted(set, state);
    m->next = self->firstMelted; self->firstMelted = m;
    return m;
}

static CcBitArray_t *
CcLexical_MeltedSet(CcLexical_t * self, int nr)
{
    CcMelted_t * m = self->firstMelted;
    while (m != NULL) {
	if (m->state->base.index == nr) return m->set;
	else m = m->next;
    }
    /*Errors::Exception("-- compiler error in CcMelted::Set");*/
    /*throw new Exception("-- compiler error in CcMelted::Set");*/
    return NULL;
}

CcMelted_t *
CcLexical_StateWithSet(CcLexical_t * self, CcBitArray_t * s)
{
    CcMelted_t * m;
    for (m = self->firstMelted; m != NULL; m = m->next)
	if (CcBitArray_Equal(s, m->set)) return m;
    return NULL;
}

/* ---------------------------- actions -------------------------------- */
void
CcLexical_GetTargetStates(CcLexical_t * self, CcAction_t * a,
			  CcBitArray_t ** targets, CcSymbol_t ** endOf,
			  CcsBool_t * ctx)
{
    CcTarget_t * t; int stateNr;
    /* compute the set of target states */
    *targets = CcBitArray(CcMalloc(sizeof(CcBitArray_t)), self->maxStates);
    *endOf = NULL; *ctx = FALSE;
    for (t = a->target; t != NULL; t = t->next) {
	stateNr = t->state->base.index;
	if (stateNr <= self->lastSimState) {
	    CcBitArray_Set(*targets, stateNr, TRUE);
	} else {
	    CcBitArray_Or(*targets, CcLexical_MeltedSet(self, stateNr));
	}
	if (t->state->endOf != NULL) {
	    if (*endOf == NULL || *endOf == t->state->endOf)
		*endOf = t->state->endOf;
	    else {
		CcsGlobals_SemErr(&self->globals->base, NULL, 
				  "Tokens %s and %s cannot be distinguished\n",
				  (*endOf)->name,
				  t->state->endOf->name);
	    }
	}
	if (t->state->ctx) {
	    *ctx = TRUE;
	    /* The following check seems to be unnecessary. It reported an error
	     * if a symbol + context was the prefix of another symbol, e.g.
	     *   s1 = "a" "b" "c".
	     *   s2 = "a" CONTEXT("b").
	     * But this is ok.
	     * if (t.state.endOf != null) {
	     *   Console.WriteLine("Ambiguous context clause");
	     *	 Errors.count++;
	     * } */
	}
    }
}

/* ------------------------ comments -------------------------------- */
static void
CcLexical_CommentStr(CcLexical_t * self, const CcsToken_t * token,
		     int * output, CcNode_t * p)
{
    int * cur = output;
    CcTransition_t * trans;

    *cur = 0;
    while (p != NULL) {
	if (p->base.type == node_trans) {
	    trans = &((CcNodeTrans_t *)p)->trans;
	    if (CcTransition_Size(trans) != 1)
		CcsGlobals_SemErr(&self->globals->base, token,
				  "character set contains more than 1 character");
	    *cur++ = CcTransition_First(trans);
	} else {
	    CcsGlobals_SemErr(&self->globals->base, token,
			      "comment delimiters may not be structured");
	}
	if (cur - output > 2) {
	    CcsGlobals_SemErr(&self->globals->base, token,
			      "comment delimiters must be 1 or 2 characters long");
	    cur = output; *cur++ = '?';
	    break;
	}
	p = p->next;
    }
    *cur = 0;
}

void
CcLexical_NewComment(CcLexical_t * self, const CcsToken_t * token,
		     CcNode_t * from, CcNode_t * to, CcsBool_t nested)
{
    int start[3], stop[3];
    CcComment_t * c;

    CcLexical_CommentStr(self, token, start, from);
    CcLexical_CommentStr(self, token, stop, to);
    c = CcComment(start, stop, nested);
    c->next = self->firstComment; self->firstComment = c;
}
