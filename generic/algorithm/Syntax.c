/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
#include  "Syntax.h"
#include  "Globals.h"
#include  "syntax/Nodes.h"

CcSyntax_t *
CcSyntax(CcSyntax_t * self, CcGlobals_t * globals)
{
    CcEBNF(&self->base);
    self->globals = globals;
    self->gramSy = NULL;
    self->eofSy = NULL;
    self->noSym = NULL;
    self->curSy = NULL;
    self->visited = NULL;
    self->allSyncSets = NULL;
    return self;
}

void
CcSyntax_Destruct(CcSyntax_t * self)
{
    if (self->allSyncSets) CcBitArray_Destruct(self->allSyncSets);
    if (self->visited) CcBitArray_Destruct(self->visited);
    CcEBNF_Destruct(&self->base);
}

static void
CcSyntax_First0(CcSyntax_t * self, CcBitArray_t * ret,
		CcNode_t * p, CcBitArray_t * mark)
{
    CcBitArray_t fs0;
    CcSymbolTable_t * symtab = &self->globals->symtab;

    CcBitArray(ret, symtab->terminals.Count);
    while (p != NULL && !CcBitArray_Get(mark, p->base.index)) {
	CcBitArray_Set(mark, p->base.index, TRUE);
	if (p->base.type == node_nt) {
	    CcNodeNT_t * p0 = (CcNodeNT_t *)p;
	    CcSymbolNT_t * sym = (CcSymbolNT_t *)p0->sym;
	    if (sym->firstReady) {
		CcBitArray_Or(ret, sym->first);
	    } else {
		CcSyntax_First0(self, &fs0, sym->graph, mark);
		CcBitArray_Or(ret, &fs0);
		CcBitArray_Destruct(&fs0);
	    }
	} else if (p->base.type == node_t) {
	    CcNodeT_t * p0 = (CcNodeT_t *)p;
	    CcBitArray_Set(ret, p0->sym->base.index, TRUE);
	} else if (p->base.type == node_wt) {
	    CcNodeWT_t * p0 = (CcNodeWT_t *)p;
	    CcBitArray_Set(ret, p0->sym->base.index, TRUE);
	} else if (p->base.type == node_any) {
	    CcNodeANY_t * p0 = (CcNodeANY_t *)p;
	    CcBitArray_Or(ret, p0->set);
	} else if (p->base.type == node_alt) {
	    CcSyntax_First0(self, &fs0, p->sub, mark);
	    CcBitArray_Or(ret, &fs0);
	    CcBitArray_Destruct(&fs0);
	    CcSyntax_First0(self, &fs0, p->down, mark);
	    CcBitArray_Or(ret, &fs0);
	    CcBitArray_Destruct(&fs0);
	} else if (p->base.type == node_iter && p->base.type == node_opt) {
	    CcSyntax_First0(self, &fs0, p->sub, mark);
	    CcBitArray_Or(ret, &fs0);
	    CcBitArray_Destruct(&fs0);
	}
	if (!CcNode_DelNode(p)) break;
	p = p ->next;
    }
}

static void
CcSyntax_First(CcSyntax_t * self, CcBitArray_t * ret, CcNode_t * p)
{
    CcBitArray_t fs0;

    CcBitArray(&fs0, self->base.nodes.Count);
    CcSyntax_First0(self, ret, p, &fs0);
    CcBitArray_Destruct(&fs0);
}

static void
CcSyntax_CompFirstSets(CcSyntax_t * self)
{
    CcBitArray_t fs;
    CcSymbolNT_t * sym; CcArrayListIter_t iter;
    CcSymbolTable_t * symtab = &self->globals->symtab;
    CcArrayList_t * ntarr = &symtab->nonterminals;

    for (sym = (CcSymbolNT_t *)CcArrayList_First(ntarr, &iter);
	 sym; sym = (CcSymbolNT_t *)CcArrayList_Next(ntarr, &iter)) {
	sym->first = CcBitArray(&sym->firstSpace, symtab->terminals.Count);
	sym->firstReady = FALSE;
    }
    for (sym = (CcSymbolNT_t *)CcArrayList_First(ntarr, &iter);
	 sym; sym = (CcSymbolNT_t *)CcArrayList_Next(ntarr, &iter)) {
	CcSyntax_First(self, &fs, sym->graph);
	CcBitArray_Destruct(sym->first);
	memcpy(sym->first, &fs, sizeof(fs));
	sym->firstReady = TRUE;
    }
}

static void
CcSyntax_CompFollow(CcSyntax_t * self, CcNode_t * p)
{
    CcBitArray_t s;
    CcSymbolNT_t * sym;

    while (p != NULL && !CcBitArray_Get(self->visited, p->base.index)) {
	CcBitArray_Set(self->visited, p->base.index, TRUE);
	if (p->base.type == node_nt) {
	    CcSyntax_First(self, &s, p->next);
	    sym = (CcSymbolNT_t *)((CcNodeNT_t *)p)->sym;
	    CcBitArray_Or(sym->follow, &s);
	    CcBitArray_Destruct(&s);
	    if (CcNode_DelGraph(p->next))
		CcBitArray_Set(sym->nts, self->curSy->base.index, TRUE);
	} else if (p->base.type == node_opt || p->base.type == node_iter) {
	    CcSyntax_CompFollow(self, p->sub);
	} else if (p->base.type == node_alt) {
	    CcSyntax_CompFollow(self, p->sub);
	    CcSyntax_CompFollow(self, p->down);
	}
	p = p->next;
    }
}

static void
CcSyntax_Complete(CcSyntax_t * self, CcSymbolNT_t * sym)
{
    CcSymbolNT_t * s; CcArrayListIter_t iter;
    CcSymbolTable_t * symtab = &self->globals->symtab;
    CcArrayList_t * ntarr = &symtab->nonterminals;

    if (CcBitArray_Get(self->visited, sym->base.base.index)) return;
    CcBitArray_Set(self->visited, sym->base.base.index, TRUE);
    for (s = (CcSymbolNT_t *)CcArrayList_First(ntarr, &iter);
	 s; s = (CcSymbolNT_t *)CcArrayList_Next(ntarr, &iter)) {
	if (CcBitArray_Get(sym->nts, s->base.base.index)) {
	    CcSyntax_Complete(self, s);
	    CcBitArray_Or(sym->follow, s->follow);
	    if ((CcSymbol_t *)sym == self->curSy)
		CcBitArray_Set(sym->nts, s->base.base.index, FALSE);
	}
    }
}

static void
CcSyntax_CompFollowSets(CcSyntax_t * self)
{
    CcSymbolNT_t * sym; CcArrayListIter_t iter;
    CcSymbolTable_t * symtab = &self->globals->symtab;
    CcArrayList_t * tarr = &symtab->terminals;
    CcArrayList_t * ntarr = &symtab->nonterminals;

    for (sym = (CcSymbolNT_t *)CcArrayList_First(ntarr, &iter);
	 sym; sym = (CcSymbolNT_t *)CcArrayList_Next(ntarr, &iter)) {
	sym->follow = CcBitArray(&sym->followSpace, tarr->Count);
	sym->nts = CcBitArray(&sym->ntsSpace, ntarr->Count);
    }
    CcBitArray_Set(((CcSymbolNT_t *)self->gramSy)->follow,
		   self->eofSy->base.index, TRUE);

    self->visited = CcBitArray(&self->visitedSpace, self->base.nodes.Count);
    for (sym =(CcSymbolNT_t *)CcArrayList_First(ntarr, &iter);
	 sym; sym = (CcSymbolNT_t *)CcArrayList_Next(ntarr, &iter)) {
	self->curSy = (CcSymbol_t *)sym;
	CcSyntax_CompFollow(self, sym->graph);
    }
    CcBitArray_Destruct(self->visited); self->visited = NULL;

    for (sym =(CcSymbolNT_t *)CcArrayList_First(ntarr, &iter);
	 sym; sym = (CcSymbolNT_t *)CcArrayList_Next(ntarr, &iter)) {
	self->visited = CcBitArray(&self->visitedSpace, ntarr->Count);
	self->curSy = (CcSymbol_t *)sym;
	CcSyntax_Complete(self, sym);
	CcBitArray_Destruct(self->visited); self->visited = NULL;
    }
}

static CcNode_t *
CcSyntax_LeadingAny(CcSyntax_t * self, CcNode_t * p)
{
    CcNode_t * a;

    if (p == NULL) return NULL;
    a = NULL;
    if (p->base.type == node_any) {
	a = p;
    } else if (p->base.type == node_alt) {
	a = CcSyntax_LeadingAny(self, p->sub);
	if (a == NULL) a = CcSyntax_LeadingAny(self, p->down);
    } else if (p->base.type == node_opt || p->base.type == node_iter) {
	a = CcSyntax_LeadingAny(self, p->sub);
    } else if (CcNode_DelNode(p) && !p->up) {
	a = CcSyntax_LeadingAny(self, p->next);
    }
    return a;
}

static void
CcSyntax_FindAS(CcSyntax_t * self, CcNode_t * p)
{
    CcNode_t * a, * q;
    CcBitArray_t s0, s1;
    CcSymbolTable_t * symtab = &self->globals->symtab;

    while (p != NULL) {
	if (p->base.type == node_opt || p->base.type == node_iter) {
	    CcSyntax_FindAS(self, p->sub);
	    a = CcSyntax_LeadingAny(self, p->sub);
	    if (a != NULL) {
		CcSyntax_First(self, &s0, p->next);
		CcBitArray_Subtract(((CcNodeANY_t *)a)->set, &s0);
		CcBitArray_Destruct(&s0);
	    }
	} else if (p->base.type == node_alt) {
	    CcBitArray(&s1, symtab->terminals.Count);
	    q = p;
	    while (q != NULL) {
		CcSyntax_FindAS(self, q->sub);
		a = CcSyntax_LeadingAny(self, q->sub);
		if (a != NULL) {
		    CcSyntax_First(self, &s0, p->down);
		    CcBitArray_Or(&s0, &s1);
		    CcBitArray_Subtract(((CcNodeANY_t *)a)->set, &s0);
		    CcBitArray_Destruct(&s0);
		} else {
		    CcSyntax_First(self, &s0, q->sub);
		    CcBitArray_Or(&s1, &s0);
		}
		q = q->down;
	    }
	}
	if (p->up) break;
	p = p->next;
    }
}

static void
CcSyntax_CompAnySets(CcSyntax_t * self)
{
    int idx; CcSymbolNT_t * sym;
    CcSymbolTable_t * symtab = &self->globals->symtab;

    for (idx = 0; idx < symtab->nonterminals.Count; ++idx) {
	sym = (CcSymbolNT_t *)CcArrayList_Get(&symtab->nonterminals, idx);
	CcSyntax_FindAS(self, sym->graph);
    }
}

static void
CcSyntax_Expected(CcSyntax_t * self, CcBitArray_t * ret,
		  CcNode_t * p, CcSymbol_t * curSy)
{
    CcSyntax_First(self, ret, p);
    if (CcNode_DelGraph(p))
	CcBitArray_Or(ret, ((CcSymbolNT_t *)curSy)->follow);
}

static void
CcSyntax_Expected0(CcSyntax_t * self, CcBitArray_t * ret,
		   CcNode_t * p, CcSymbol_t * curSy)
{
    CcSymbolTable_t * symtab = &self->globals->symtab;
    if (p->base.type == node_rslv) CcBitArray(ret, symtab->terminals.Count);
    else CcSyntax_Expected(self, ret, p, curSy);
}

static void
CcSyntax_CompSync(CcSyntax_t * self, CcNode_t * p)
{
    CcBitArray_t s;

    while (p != NULL && !CcBitArray_Get(self->visited, p->base.index)) {
	CcBitArray_Set(self->visited, p->base.index, TRUE);
	if (p->base.type == node_sync) {
	    CcSyntax_Expected(self, &s, p->next, self->curSy);
	    CcBitArray_Set(&s, self->eofSy->base.index, TRUE);
	    CcBitArray_Or(self->allSyncSets, &s);
	    memcpy(&((CcNodeSYNC_t *)p)->set, &s, sizeof(s));
	} else if (p->base.type == node_alt) {
	    CcSyntax_CompSync(self, p->sub);
	    CcSyntax_CompSync(self, p->down);
	} else if (p->base.type == node_opt || p->base.type == node_iter) {
	    CcSyntax_CompSync(self, p->sub);
	}
	p = p->next;
    }
}

static void
CcSyntax_CompSyncSets(CcSyntax_t * self)
{
    CcSymbolNT_t * sym; CcArrayListIter_t iter;
    CcSymbolTable_t * symtab = &self->globals->symtab;
    CcArrayList_t * ntarr = &symtab->nonterminals;

    self->allSyncSets = CcBitArray(&self->allSyncSetsSpace,
				   symtab->terminals.Count);
    CcBitArray_Set(self->allSyncSets, self->eofSy->base.index, TRUE);
    self->visited = CcBitArray(&self->visitedSpace, self->base.nodes.Count);
    for (sym = (CcSymbolNT_t *)CcArrayList_First(ntarr, &iter);
	 sym; sym = (CcSymbolNT_t *)CcArrayList_First(ntarr, &iter)) {
	self->curSy = (CcSymbol_t *)sym;
	CcSyntax_CompSync(self, sym->graph);
    }
}

void
CcSyntax_SetupAnys(CcSyntax_t * self)
{
    CcNode_t * p; CcArrayListIter_t iter;
    CcSymbolTable_t * symtab = &self->globals->symtab;

    for (p = (CcNode_t *)CcArrayList_First(&self->base.nodes, &iter);
	 p; p = (CcNode_t *)CcArrayList_Next(&self->base.nodes, &iter)) {
	if (p->base.type != node_any) continue;
	CcBitArray1(((CcNodeANY_t *)p)->set, symtab->terminals.Count);
	CcBitArray_Set(((CcNodeANY_t *)p)->set,
		       self->eofSy->base.index, FALSE);
    }
}

static void
CcSyntax_CompDeletableSymbols(CcSyntax_t * self)
{
    CcsBool_t changed;
    CcSymbolNT_t * sym; CcArrayListIter_t iter;
    CcSymbolTable_t * symtab = &self->globals->symtab;
    CcArrayList_t * ntarr = &symtab->nonterminals;
    do {
	changed = FALSE;
	for (sym = (CcSymbolNT_t *)CcArrayList_First(ntarr, &iter);
	     sym; sym = (CcSymbolNT_t *)CcArrayList_Next(ntarr, &iter)) {
	    if (!sym->deletable && sym->graph != NULL &&
		CcNode_DelGraph(sym->graph)) {
		sym->deletable = TRUE; changed = TRUE;
	    }
	}
    } while (changed);
    for (sym = (CcSymbolNT_t *)CcArrayList_First(ntarr, &iter);
	 sym; sym = (CcSymbolNT_t *)CcArrayList_Next(ntarr, &iter)) {
	if (sym->deletable) 
	    CcsGlobals_Warning(&self->globals->base, NULL,
			       " %s deletable", sym->base.name);
    }
}

void
CcSyntax_CompSymbolSets(CcSyntax_t * self)
{
    CcSyntax_CompDeletableSymbols(self);
    CcSyntax_CompFirstSets(self);
    CcSyntax_CompFollowSets(self);
    CcSyntax_CompAnySets(self);
    CcSyntax_CompSyncSets(self);
}

static void
GetSingles(CcBitArray_t * singles, CcNode_t * p)
{
    if (p == NULL) return; /* end of graph */
    if (p->base.type == node_nt) {
	if (p->up || CcNode_DelGraph(p->next))
	    CcBitArray_Set(singles, ((CcNodeNT_t *)p)->sym->base.index, TRUE);
    } else if (p->base.type == node_alt || p->base.type == node_iter
	       || p->base.type == node_opt) {
	if (p->up || CcNode_DelGraph(p->next)) {
	    GetSingles(singles, p->sub);
	    if (p->base.type == node_alt) GetSingles(singles, p->down);
	}
    }
    if (p->up && CcNode_DelNode(p)) GetSingles(singles, p->next);
}

typedef struct SymbolPair_s SymbolPair_t;
struct SymbolPair_s {
    SymbolPair_t * next;
    int left, right;
};

static CcsBool_t
CcSyntax_NoCircularProductions(CcSyntax_t * self)
{
    CcBitArray_t singles;
    SymbolPair_t * firstPair, * prevPair, * curPair, * curPair0;
    CcSymbolNT_t * sym; CcArrayListIter_t iter; int index;
    CcsBool_t ok, changed, onLeftSide, onRightSide;
    CcSymbol_t * leftsym, * rightsym;
    CcSymbolTable_t * symtab = &self->globals->symtab;
    CcArrayList_t * ntarr = &symtab->nonterminals;

    firstPair = NULL;
    CcBitArray(&singles, ntarr->Count);
    for (sym = (CcSymbolNT_t *)CcArrayList_First(ntarr, &iter);
	 sym; sym = (CcSymbolNT_t *)CcArrayList_Next(ntarr, &iter)) {
	CcBitArray_SetAll(&singles, FALSE);
	/* Get nonterminals s such that sym-->s */
	GetSingles(&singles, sym->graph);
	for (index = 0; index < ntarr->Count; ++index) {
	    if (!CcBitArray_Get(&singles, index)) continue;
	    curPair = CcMalloc(sizeof(SymbolPair_t));
	    curPair->left = sym->base.base.index;
	    curPair->right = index;
	    curPair->next = firstPair;
	    firstPair = curPair;
	}
    }
    CcBitArray_Destruct(&singles);

    do {
	changed = FALSE;
	prevPair = NULL; curPair = firstPair;
	while (curPair) {
	    onLeftSide = FALSE; onRightSide = FALSE;
	    for (curPair0 = curPair; curPair0; curPair0 = curPair0->next) {
		if (curPair->left == curPair0->right) onRightSide = TRUE;
		if (curPair->right == curPair0->left) onLeftSide = TRUE;
	    }
	    if (onLeftSide && onRightSide) { /* Circular Production found. */
		prevPair = curPair; curPair = curPair->next;
	    } else { /* Remove non-circular nonterminal symbol pair. */
		curPair0 = curPair->next;
		if (prevPair == NULL)  firstPair = curPair0;
		else  prevPair->next = curPair0;
		CcFree(curPair);
		curPair = curPair0;
		changed = TRUE;
	    }
	}
    } while (changed);

    ok = TRUE;
    for (curPair = firstPair; curPair; curPair = curPair0) {
	ok = FALSE;
	leftsym = (CcSymbol_t *)CcArrayList_Get(ntarr, curPair->left);
	rightsym = (CcSymbol_t *)CcArrayList_Get(ntarr, curPair->right);
	CcsGlobals_SemErr(&self->globals->base, NULL, " %s --> %s",
			  leftsym->name, rightsym->name);
	curPair0 = curPair->next;
	CcFree(curPair);
    }
    return ok;
}

static void
CcSyntax_LL1Error(CcSyntax_t * self, int cond, CcSymbol_t * sym)
{
    const char * s0, * s1, * s2;
    if (sym) { s0 = sym->name; s1 = " is "; }
    else { s0 = s1 = ""; }
    switch (cond) {
    case 1: s2 = "start of several alternatives"; break;
    case 2: s2 = "start & successor of deletable structure"; break;
    case 3: s2 = "an ANY node that matches no symbol"; break;
    case 4: s2 = "contents of [...] or {...} must not be deletable"; break;
    default: s2 = ""; break;
    }
    CcsGlobals_Warning(&self->globals->base, NULL,
		       "  LL1 warning in %s: %s%s%s", self->curSy->name, s0, s1, s2);
}

static void
CcSyntax_CheckOverlap(CcSyntax_t * self, CcBitArray_t * s1, CcBitArray_t * s2,
		      int cond)
{
    CcSymbolT_t * sym; CcArrayListIter_t iter;
    CcSymbolTable_t * symtab = &self->globals->symtab;
    CcArrayList_t * tarr = &symtab->terminals;

    for (sym = (CcSymbolT_t *)CcArrayList_First(tarr, &iter);
	 sym; sym = (CcSymbolT_t *)CcArrayList_Next(tarr, &iter)) {
	if (CcBitArray_Get(s1, sym->base.base.index)
	    && CcBitArray_Get(s2, sym->base.base.index))
	    CcSyntax_LL1Error(self, cond, (CcSymbol_t *)sym);
    }
}

/* FIX ME */
static void
CcSyntax_CheckAlts(CcSyntax_t * self, CcNode_t * p)
{
    CcBitArray_t s1, s2; CcNode_t * q;
    CcSymbolTable_t * symtab = &self->globals->symtab;

    while (p != NULL) {
	if (p->base.type == node_alt) {
	    q = p;
	    CcBitArray(&s1, symtab->terminals.Count);
	    while (q != NULL) { /* For all alternatives */
		CcSyntax_Expected0(self, &s2, q->sub, self->curSy);
		CcSyntax_CheckOverlap(self, &s1, &s2, 1);
		CcBitArray_Or(&s1, &s2);
		CcSyntax_CheckAlts(self, q->sub);
		q = q->down;
		CcBitArray_Destruct(&s2);
	    }
	    CcBitArray_Destruct(&s1);
	} else if (p->base.type == node_opt || p->base.type == node_iter) {
	    /* E.g. [[...]] */
	    if (CcNode_DelSubGraph(p->sub)) {
		CcSyntax_LL1Error(self, 4, NULL);
	    } else {
		CcSyntax_Expected0(self, &s1, p->sub, self->curSy);
		CcSyntax_Expected(self, &s2, p->next, self->curSy);
		CcSyntax_CheckOverlap(self, &s1, &s2, 2);
		CcSyntax_CheckAlts(self, p->sub);
		CcBitArray_Destruct(&s1);
		CcBitArray_Destruct(&s2);
	    }
	} else if (p->base.type == node_any) {
	    /* E.g. {ANY} ANY or [ANY] ANY */
	    if (CcBitArray_Elements(((CcNodeANY_t *)p)->set) == 0)
		CcSyntax_LL1Error(self, 3, NULL);
	}
	if (p->up) break;
	p = p->next;
    }
}

static void
CcSyntax_CheckLL1(CcSyntax_t * self)
{
    CcSymbolNT_t * sym; CcArrayListIter_t iter;
    CcSymbolTable_t * symtab = &self->globals->symtab;
    CcArrayList_t * ntarr = &symtab->nonterminals;

    for (sym = (CcSymbolNT_t *)CcArrayList_First(ntarr, &iter);
	 sym; sym = (CcSymbolNT_t *)CcArrayList_Next(ntarr, &iter)) {
	self->curSy = (CcSymbol_t *)sym;
	CcSyntax_CheckAlts(self, sym->graph);
    }
}

/*------------- check if resolvers are legal  --------------------*/
static void
CcSyntax_CheckRes(CcSyntax_t * self, CcNode_t * p, CcsBool_t rslvAllowed)
{
    CcNode_t * q;
    CcBitArray_t expected, soFar, fs, fsNext;
    CcSymbolTable_t * symtab = &self->globals->symtab;

    while (p != NULL) {
	if (p->base.type == node_alt) {
	    CcBitArray(&expected, symtab->terminals.Count);
	    for (q = p; q != NULL; q = q->down) {
		CcSyntax_Expected0(self, &fs, q->sub, self->curSy);
		CcBitArray_Or(&expected, &fs);
		CcBitArray_Destruct(&fs);
	    }
	    CcBitArray(&soFar, symtab->terminals.Count);
	    for (q = p; q != NULL; q = q->down) {
		if (q->sub->base.type == node_rslv) {
		    CcSyntax_Expected(self, &fs, q->sub->next, self->curSy);
		    if (CcBitArray_Intersect(&fs, &soFar))
			CcsGlobals_Warning(&self->globals->base, NULL,
					   "Resolver will never be evaluated. "
					   "Place it at previous conflicting alternative.");
		    if (!CcBitArray_Intersect(&fs, &expected))
			CcsGlobals_Warning(&self->globals->base, NULL,
					   "Misplaced resolver: no LL(1) conflict.");
		    CcBitArray_Destruct(&fs);
		} else {
		    CcSyntax_Expected(self, &fs, q->sub, self->curSy);
		    CcBitArray_Or(&soFar, &fs);
		}
		CcSyntax_CheckRes(self, q->sub, TRUE);
	    }
	} else if (p->base.type == node_iter || p->base.type == node_opt) {
	    if (q->sub->base.type == node_rslv) {
		CcSyntax_First(self, &fs, p->sub->next);
		CcSyntax_Expected(self, &fsNext, p->next, self->curSy);
		if (!CcBitArray_Intersect(&fs, &fsNext))
		    CcsGlobals_Warning(&self->globals->base, NULL,
				       "Misplaced resolver: no LL(1) conflict.");
	    }
	    CcSyntax_CheckRes(self, p->sub, TRUE);
	} else if (p->base.type == node_rslv) {
	    if (!rslvAllowed)
		CcsGlobals_Warning(&self->globals->base, NULL,
				   "Misplaced resolver: no alternative.");
	}
	if (p->up) break;
	p = p->next;
	rslvAllowed = FALSE;
    }
}

static void
CcSyntax_CheckResolvers(CcSyntax_t * self)
{
    int idx; CcSymbolNT_t * sym;
    CcSymbolTable_t * symtab = &self->globals->symtab;
    for (idx = 0; idx < symtab->nonterminals.Count; ++idx) {
	sym = (CcSymbolNT_t *)CcArrayList_Get(&symtab->nonterminals, idx);
	self->curSy = (CcSymbol_t *)sym;
	CcSyntax_CheckRes(self, sym->graph, FALSE);
    }
}

/*------------- check if every nts has a production --------------------*/
static CcsBool_t
CcSyntax_NtsComplete(CcSyntax_t * self)
{
    int idx; CcSymbolNT_t * sym;
    CcsBool_t complete = TRUE;
    CcSymbolTable_t * symtab = &self->globals->symtab;
    for (idx = 0; idx < symtab->nonterminals.Count; ++idx) {
	sym = (CcSymbolNT_t *)CcArrayList_Get(&symtab->nonterminals, idx);
	if (sym->graph == NULL) {
	    complete = FALSE;
	    CcsGlobals_SemErr(&self->globals->base, NULL,
			      "No production for %s", sym->base.name);
	}
    }
    return complete;
}

static void
CcSyntax_MarkReachedNts(CcSyntax_t * self, CcNode_t * p)
{
    while (p != NULL) {
	if (p->base.type == node_nt) {
	    CcNodeNT_t * p0 = (CcNodeNT_t *)p;
	    CcSymbolNT_t * sym = (CcSymbolNT_t *)p0->sym;
	    if (!CcBitArray_Get(self->visited, sym->base.base.index)) {
		/* new nt reached */
		CcBitArray_Set(self->visited, sym->base.base.index, TRUE);
		CcSyntax_MarkReachedNts(self, sym->graph);
	    }
	} else if (p->base.type == node_alt || p->base.type == node_iter
		   || p->base.type == node_opt) {
	    CcSyntax_MarkReachedNts(self, p->sub);
	    if (p->base.type == node_alt)
		CcSyntax_MarkReachedNts(self, p->down);
	}
	if (p->up) break;
	p = p->next;
    }
}

static CcsBool_t
CcSyntax_AllNtReached(CcSyntax_t * self)
{
    int idx; CcSymbol_t * sym;
    CcsBool_t ok = TRUE;
    CcSymbolTable_t * symtab = &self->globals->symtab;

    self->visited = CcBitArray(&self->visitedSpace,
			       symtab->nonterminals.Count);
    CcBitArray_Set(self->visited, self->gramSy->base.index, TRUE);
    CcSyntax_MarkReachedNts(self, ((CcSymbolNT_t *)self->gramSy)->graph);
    for (idx = 0; idx < symtab->nonterminals.Count; ++idx) {
	sym = (CcSymbol_t *)CcArrayList_Get(&symtab->nonterminals, idx);
	if (!CcBitArray_Get(self->visited, sym->base.index)) {
	    ok = FALSE;
	    CcsGlobals_SemErr(&self->globals->base, NULL,
			      " %s cannot be reached", sym->name);
	}
    }
    return ok;
}

/*--------- check if every nts can be derived to terminals  ------------ */
/* true if graph can be derived to terminals */
CcsBool_t
CcSyntax_IsTerm(CcSyntax_t *self, CcNode_t * p, CcBitArray_t * mark) {
    while (p != NULL) {
	if (p->base.type == node_nt &&
	    !CcBitArray_Get(mark, (((CcNodeNT_t *)p)->sym)->base.index))
	    return FALSE;
	if (p->base.type == node_alt && !CcSyntax_IsTerm(self, p->sub, mark) &&
	    (p->down == NULL || !CcSyntax_IsTerm(self, p->down, mark)))
	    return FALSE;
	if (p->up) break;
	p = p->next;
    }
    return TRUE;
}

static CcsBool_t
CcSyntax_AllNtToTerm(CcSyntax_t * self)
{
    CcBitArray_t mark;
    CcSymbolNT_t * sym; CcArrayListIter_t iter;
    CcsBool_t changed, ok = TRUE;
    CcSymbolTable_t * symtab = &self->globals->symtab;
    CcArrayList_t * ntarr = &symtab->nonterminals;

    CcBitArray(&mark, ntarr->Count);
    do {
	changed = FALSE;
	for (sym = (CcSymbolNT_t *)CcArrayList_First(ntarr, &iter);
	     sym; sym = (CcSymbolNT_t *)CcArrayList_Next(ntarr, &iter)) {
	    if (!CcBitArray_Get(&mark, sym->base.base.index) &&
		CcSyntax_IsTerm(self, sym->graph, &mark)) {
		CcBitArray_Set(&mark, sym->base.base.index, TRUE);
		changed = TRUE;
	    }
	}
    } while (changed);
    for (sym = (CcSymbolNT_t *)CcArrayList_First(ntarr, &iter);
	 sym; sym = (CcSymbolNT_t *)CcArrayList_Next(ntarr, &iter)) {
	if (!CcBitArray_Get(&mark, sym->base.base.index)) {
	    ok = FALSE;
	    CcsGlobals_SemErr(&self->globals->base, NULL,
			      " %s cannot be derived to terminals",
			      sym->base.name);
	}
    }
    return ok;
}

CcsBool_t
CcSyntax_GrammarOk(CcSyntax_t * self)
{
    CcsBool_t ok = CcSyntax_NtsComplete(self) &&
	CcSyntax_AllNtReached(self) &&
	CcSyntax_NoCircularProductions(self) &&
	CcSyntax_AllNtToTerm(self);
    if (ok) {
	CcSyntax_CheckResolvers(self);
	CcSyntax_CheckLL1(self);
    }
    return ok;
}
