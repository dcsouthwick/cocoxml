/* -*- c -*- */
/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*---- open(Parser.h) ----*/
/*---- license ----*/

#ifdef  COCO_PARSER_H
#define COCO_PARSER_H

#include  <stdio.h>
#include  "Scanner.h"

EXTC_BEGIN

/*---- headerdef ----*/

struct Errors_s {
    FILE * fp;
    int count;
};

Errors_t * Errors(Errors_t * self, FILE * fp);
void Errors_Destruct(Errors_t * self);
void Errors_SynErr(Errors_t * self, int line, int col, int n);
void Errors_Warning(Errors_t * self, int line, int col, const char * s);
void Errors_WarningS(Errors_t * self, const char * s);
void Errors_Exception(Errors_t * self, const char * s);

struct Parser_s {
    /*---- constantsheader ----*/
    Token_t * dummyToken;
    int errDist;
    int minErrDist;

    Scanner_t * scanner;
    Errors_t errors;
    Token_t * t;
    Token_t * la;

    /*---- declarations ----*/
};

Parser_t * Parser(Parser_t * self, Scannr_t * scanner);
void Parser_Destruct(Parser_t * self);
void Parser_SemErr(Parser_t * self, const char * msg);
void Parser_Parse();

/*---- productionsheader ----*/

EXTC_END

#endif /* COCO_PARSER_H */
/*---- open(Parser.c) ----*/
/*---- license ----*/
#include  <stdio.h>
#include  <stdlib.h>
#include  "Parser.h"

Errors_t *
Errors(Errors_t * self, FILE * fp)
{
    if (!self && !(self = malloc(sizeof(Errors_t)))) return NULL;
    self->count = 0;
    self->fp = fp;
    return self;
}

void
Errors_Destruct(Errors_t * self)
{
}

void
Errors_SynErr(Errors_t * self, int line, int col, int n)
{
    char * s, format[20];
    switch (n) {
	/*---- errors ----*/
    default:
	snprintf(format, sizeof(format), "error %d", n);
	s = format;
	break;
    }
    fprintf(self->fp, "-- line %d col %d: %s\n", line, col, s);
    ++self->count;
}

void
Errors_Error(Errors_t * self, int line, int col, const char * s)
{
    fprintf(self->fp, "-- line %d col %d: %s\n", line, col, s);
    ++self->count;
}

void
Errors_Warning(Errors_t * self, int line, int col, const char * s)
{
    fprintf(self->fp, "-- line %d col %d: %s\n", line, col, s);
}

void
Errors_WarningS(Errors_t * self, const char * s)
{
    fprintf(self->fp, "%s\n", s);
}

void
Errors_Exception(Errors_t * self, const char * s)
{
    fprintf(self->fp, "s", s);
    exit(1);
}

static void
Parser_SynErr(Parser_t * self, int n)
{
    if (self->errDist >= self->minErrDist)
	Errors_SynErr(self->errors, self->la->line, self->la->col, n);
    self->errDist = 0;
}

static void
Parser_Get(Parser_t * self)
{
    for (;;) {
	self->t = self->la;
	self->la = Scanner_Scan(self->scanner);
	if (self->la->kind <= maxT) { ++self->errDist; break; }
	/*---- pragmas ----*/
	if (self->dummyToken != self->t) {
	    self->dummyToken->kind = self->t->kind;
	    self->dummyToken->pos = self->t->pos;
	    self->dummyToken->col = self->t->col;
	    self->dummyToken->line = self->t->line;
	    self->dummyToken->next = NULL;
	    free(self->dummyToken->val);
	    self->dummyToken->val = strdup(t->val);
	    self->t = self->dummyToken;
	}
	self->la = self->t;
    }
}

static void
Parser_Expect(Parser_t * self, int n)
{
    if (self->la->kind == n) Parser_Get(self);
    else Parser_SynErr(self, n);
}

static Bool_t
Parser_StartOf(Parser_t * self, int s)
{
    /*---- initialization ----*/
    return self->set[s][la->kind];
}

static void
Parser_ExpectWeak(Parser_t * self, int n, int follow)
{
    if (self->la->kind == n) Parser_Get(self);
    else {
	Parser_SynErr(self, n);
	while (!Parser_StartOf(self, follow)) Parser_Get(self);
    }
}

static Bool_t
Parser_WeakSeparator(Parser_t * self, int n, int syFol, int repFol)
{
    if (self->la->kind == n) { Parser_Get(self); return TRUE; }
    else if (Parser_StartOf(self, repFol)) { return TRUE; }
    else {
	Parser_SynErr(self, n);
	while (!(Parser_StartOf(self, syFol) ||
		 Parser_StartOf(self, repFol) ||
		 Parser_StartOf(self, 0)))
	    Parser_Get(self);
	return Parser_StartOf(self, syFol);
    }
}


void
Parser_SemErr(Parser_t * self, const char * msg)
{
    if (self->errDist >= self->minErrDist)
	Errors_SynErr(self->errors, self->t->line, self->t->col, msg);
    self->errDist = 0;
}

/*---- productions ----*/

void
Parser_Parser(Parser_t * self)
{
    self->t = NULL;
    self->la = self->dummyToken = Token(NULL);
    self->la->val = strdup("Dummy Token");
    Parser_Get(self);
    /*---- parseRoot ----*/
    Parser_Expect(0);
}

Parser_t *
Parser(Parser_t * self, Scanner_t * scanner)
{
    if (!self && !(self = malloc(sizeof(Parser_t)))) return NULL;
    /*---- constants ----*/
    self->dummyToken = NULL;
    self->t = self->la = NULL;
    self->minErrDist = 2;
    self->errDist = self->minErrDist;
    self->scanner = scanner;
    Errors(&self->errors);
    return self;
}

void
Parser_Destruct(Parser_t * self)
{
    Errors_Destruct(&self->errors);
    if (self->dummyToken) {
	Token_Destruct(self->dummyToken); free(self->dummyToken);
    }
}
