/* -*- c -*- */
/*---- open(Scanner.h) S ----*/
/*---- open(c.Scanner.frame) F ----*/
/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by the
  Free Software Foundation; either version 2, or (at your option) any
  later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  for more details.

  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*---- enable ----*/
#ifndef  COCO_SCANNER_H
#define  COCO_SCANNER_H

#include  <stdio.h>

#ifdef __cplusplus
#define  EXTC_BEGIN extern "C" {
#define  EXTC_END   }
#else
#define  EXTC_BEGIN
#define  EXTC_END
#endif

EXTC_BEGIN

#define COCO_WCHAR_MAX 65535
#define EoF            -1
#define ErrorChr       -2

typedef struct Token_s Token_t;
struct Token_s
{
    Token_t * next;
    int kind;
    int pos;
    int col;
    int line;
    char * val;
};

typedef struct {
    FILE * fp;
    long   start;
    char * buf;
    char * busyFirst; /* The first char used by Token_t. */
    char * lockCur;   /* The value of of cur when locked. */
    char * lockNext;  /* The value of next when locked. */
    char * cur;    /* The first char of the current char in Scanner_t.*/
    char * next;   /* The first char of the next char in Scanner_t. */
    char * loaded;
    char * last;
} Buffer_t;

typedef struct {
    int        eofSym;
    int        noSym;
    int        maxT;

    Token_t  * dummyToken;

    Token_t  * busyTokenList;
    Token_t ** curToken;
    Token_t ** peekToken;

    int        ch;
    int        chBytes;
    int        pos;
    int        line;
    int        col;
    int        oldEols;
    int        oldEolsEOL;

    Buffer_t   buffer;
} Scanner_t;

Scanner_t * Scanner(Scanner_t * self, const char * filename);
void Scanner_Destruct(Scanner_t * self);
const Token_t * Scanner_GetDummy(Scanner_t * self);
void Scanner_Release(Scanner_t * self, const Token_t * token);
const Token_t * Scanner_Scan(Scanner_t * self);
const Token_t * Scanner_Peek(Scanner_t * self);
void Scanner_ResetPeek(Scanner_t * self);

EXTC_END

#endif /* COCO_SCANNER_H */
/*---- open(Scanner.c) S ----*/
/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*---- enable ----*/
#include  <assert.h>
#include  <stdlib.h>
#include  <string.h>
#include  "Scanner.h"

/*------------------------------ Token_t ------------------------------*/
static Token_t *
Token(int kind, int pos, int col, int line, const char * val, size_t vallen)
{
    Token_t * self;
    if (!(self = malloc(sizeof(Token_t) + vallen + 1))) return NULL;
    self->next = NULL;
    self->kind = kind;
    self->pos = pos;
    self->col = col;
    self->line = line;
    self->val = (char *)(self + 1);
    if (vallen > 0) memcpy(self->val, val, vallen);
    self->val[vallen] = 0;
    return self;
}

static void
Token_Destruct(Token_t * self)
{
    free(self);
}

/*------------------------------ Buffer_t ------------------------------*/
/* Buffer_t members for Scanner_t. */
/* fp should be opened with 'r' mode to deal with CR/LF. */
static Buffer_t * Buffer(Buffer_t * self, FILE * fp);
static void Buffer_Destruct(Buffer_t * self);
static long Buffer_GetPos(Buffer_t * self);
static int Buffer_Read(Buffer_t * self, int * retBytes);
static const char * Buffer_GetString(Buffer_t * self, long start, size_t size);
static void Buffer_SetBusy(Buffer_t * self, long startBusy);
static void Buffer_ClearBusy(Buffer_t * self);
static void Buffer_Lock(Buffer_t * self);
static void Buffer_LockReset(Buffer_t * self);
static void Buffer_Unlock(Buffer_t * self);

/* Buffer_t private members. */
/*#define BUFSTEP  8*/
#define BUFSTEP 4096
static int Buffer_Load(Buffer_t * self);
static int Buffer_ReadByte(Buffer_t * self, int * value);

static Buffer_t *
Buffer(Buffer_t * self, FILE * fp)
{
    self->fp = fp;
    self->start = 0;
    if (!(self->buf = malloc(BUFSTEP))) goto errquit0;
    self->busyFirst = self->lockCur = NULL;
    self->cur = NULL;
    self->next = self->loaded = self->buf;
    self->last = self->buf + BUFSTEP;
    if (Buffer_Load(self) < 0) goto errquit1;
    return self;
 errquit1:
    free(self->buf);
 errquit0:
    return NULL;
}

static void
Buffer_Destruct(Buffer_t * self)
{
    fclose(self->fp);
    free(self->buf);
}

static long
Buffer_GetPos(Buffer_t * self)
{
    return self->cur ? self->start + (self->cur - self->buf) : 0L;
}

static int
Buffer_Read(Buffer_t * self, int * retBytes)
{
    int ch, c1, c2, c3, c4;
    /* self->start might be changed in Buffer_ReadByte */
    long next = self->start + (self->next - self->buf);

    self->cur = self->next;

    if (Buffer_ReadByte(self, &ch) < 0) goto quit;

    if (ch < 128) goto quit;

    if ((ch & 0xC0) != 0xC0) /* Inside UTF-8 character! */
	return ErrorChr;
    if ((ch & 0xF0) == 0xF0) {
	/* 1110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
	c1 = ch & 0x07;
	if (Buffer_ReadByte(self, &ch) < 0) goto quit;
	c2 = ch & 0x3F;
	if (Buffer_ReadByte(self, &ch) < 0) goto quit;
	c3 = ch & 0x3F;
	if (Buffer_ReadByte(self, &ch) < 0) goto quit;
	c4 = ch & 0x3F;
	ch = (((((c1 << 6) | c2) << 6) | c3) << 6) | c4;
    } else if ((ch & 0xE0) == 0xE0) {
	/* 1110xxxx 10xxxxxx 10xxxxxx */
	c1 = ch & 0x0F;
	if (Buffer_ReadByte(self, &ch) < 0) goto quit;
	c2 = ch & 0x3F;
	if (Buffer_ReadByte(self, &ch) < 0) goto quit;
	c3 = ch & 0x3F;
	ch = (((c1 << 6) | c2) << 6) | c3;
    } else {
	/* (ch & 0xC0) == 0xC0 */
	/* 110xxxxx 10xxxxxx */
	c1 = ch & 0x1F;
	if (Buffer_ReadByte(self, &ch) < 0) goto quit;
	c2 = ch & 0x3F;
	ch = (c1 << 6) | c2;
    }
 quit:
    *retBytes = self->start + (self->next - self->buf) - next;
    return ch;
}

const char *
Buffer_GetString(Buffer_t * self, long start, size_t size)
{
    if (size == 0) return NULL;
    if (start < self->start || start >= self->start + (self->cur - self->buf)){
	fprintf(stderr, "start is out of range!\n");
	exit(-1);
    }
    return self->buf + (start - self->start);
}

static void
Buffer_SetBusy(Buffer_t * self, long startBusy)
{
    assert(startBusy >= self->start);
    self->busyFirst = self->buf + (startBusy - self->start);
    assert(self->busyFirst <= self->cur);
}

static void
Buffer_ClearBusy(Buffer_t * self)
{
    self->busyFirst = NULL;
}

static void
Buffer_Lock(Buffer_t * self)
{
    assert(self->lockCur == NULL);
    self->lockCur = self->cur;
    self->lockNext = self->next;
}

static void
Buffer_LockReset(Buffer_t * self)
{
    assert(self->lockCur != NULL);
    self->cur = self->lockCur;
    self->next = self->lockNext;
    self->lockCur = NULL;
}

static void
Buffer_Unlock(Buffer_t * self)
{
    assert(self->lockCur != NULL);
    self->lockCur = NULL;
}

static int
Buffer_Load(Buffer_t * self)
{
    size_t rc = fread(self->loaded, 1, self->last - self->loaded, self->fp);
    if (rc > 0) self->loaded += rc;
    else if (ferror(self->fp)) return -1;
    return 0;
}

static int
Buffer_ReadByte(Buffer_t * self, int * value)
{
    int delta; char * keptFirst, * newbuf;
    while (self->next >= self->loaded) {
	/* Calculate keptFirst */
	keptFirst = self->cur;
	if (self->busyFirst && self->busyFirst < keptFirst)
	    keptFirst = self->busyFirst;
	if (self->lockCur && self->lockCur < keptFirst)
	    keptFirst = self->lockCur;
	if (self->buf < keptFirst) { /* Remove the unprotected data. */
	    delta = keptFirst - self->buf;
	    memmove(self->buf, keptFirst, self->loaded - keptFirst);
	    self->start += delta;
	    if (self->busyFirst) self->busyFirst -= delta;
	    if (self->lockCur) {
		self->lockCur -= delta; self->lockNext -= delta;
	    }
	    self->cur -= delta;
	    self->next -= delta;
	    self->loaded -= delta;
	}
	if (feof(self->fp)) { *value = EoF; return -1; }
	/* Try to extend the storage space */
	while (self->loaded >= self->last) {
	    if (!(newbuf =
		  realloc(self->buf, self->last - self->buf + BUFSTEP))) {
		*value = ErrorChr;
		return -1;
	    }
	    if (self->busyFirst)
		self->busyFirst = newbuf + (self->busyFirst - self->buf);
	    if (self->lockCur) {
		self->lockCur = newbuf + (self->lockCur - self->buf);
		self->lockNext = newbuf + (self->lockNext - self->buf);
	    }
	    self->cur = newbuf + (self->cur - self->buf);
	    self->next = newbuf + (self->next - self->buf);
	    self->loaded = newbuf + (self->loaded - self->buf);
	    self->last = newbuf + (self->last - self->buf + BUFSTEP);
	    self->buf = newbuf;
	}
	if (Buffer_Load(self) < 0) { *value = ErrorChr; return -1; }
    }
    *value = *self->next++;
    return 0;
}

/*------------------------------ Scanner_t ------------------------------*/
static int Char2State(int chr);
static int Identifier2KWKind(const char * key, size_t keylen, int defaultVal);
static void Scanner_Init(Scanner_t * self);
static Token_t * Scanner_NextToken(Scanner_t * self);
static void Scanner_GetCh(Scanner_t * self);

static const char * dummyval = "dummy";
Scanner_t *
Scanner(Scanner_t * self, const char * filename)
{
    FILE * fp;
    if (!(fp = fopen(filename, "r"))) goto errquit0;
    if (!(self->dummyToken = Token(0, 0, 0, 0, dummyval, strlen(dummyval))))
	goto errquit1;
    if (Buffer(&self->buffer, fp) == NULL) goto errquit2;
    Scanner_Init(self);
    return self;
 errquit2:
    fclose(fp);
 errquit1:
    Token_Destruct(self->dummyToken);
 errquit0:
    return NULL;
}

static void
Scanner_Init(Scanner_t * self)
{
    self->eofSym = 0;
    /*---- declarations ----*/
    /*---- enable ----*/

    self->busyTokenList = NULL;
    self->curToken = &self->busyTokenList;
    self->peekToken = &self->busyTokenList;

    self->ch = 0; self->chBytes = 0;
    self->pos = 0; self->line = 1; self->col = 0;
    self->oldEols = 0; self->oldEolsEOL = 0;
    Scanner_GetCh(self);
}

void
Scanner_Destruct(Scanner_t * self)
{
    Token_t * cur, * next;
    for (cur = self->busyTokenList; cur; cur = next) {
	next = cur->next;
	Token_Destruct(cur);
    }
    Token_Destruct(self->dummyToken);
    Buffer_Destruct(&self->buffer);
}

const Token_t *
Scanner_GetDummy(Scanner_t * self)
{
    return self->dummyToken;
}

void
Scanner_Release(Scanner_t * self, const Token_t * token)
{
    Token_t ** curToken, * token0;
    if (token == self->dummyToken) return;
    assert(self->busyTokenList != NULL);
    for (curToken = &self->busyTokenList;
	 *curToken != token; curToken = &(*curToken)->next)
	assert(*curToken && curToken != self->curToken);
    /* Found, detach and destroy it. */
    token0 = *curToken; *curToken = (*curToken)->next;
    Token_Destruct(token0);
    /* Adjust Buffer busy pointer */
    if (curToken == &self->busyTokenList) {
	if (self->busyTokenList) {
	    Buffer_SetBusy(&self->buffer, self->busyTokenList->pos);
	} else {
	    Buffer_ClearBusy(&self->buffer);
	}
    }
}

const Token_t *
Scanner_Scan(Scanner_t * self)
{
    Token_t * cur;
    if (*self->curToken == NULL) {
	*self->curToken = Scanner_NextToken(self);
	if (self->curToken == &self->busyTokenList)
	    Buffer_SetBusy(&self->buffer, self->busyTokenList->pos);
    }
    cur = *self->curToken;
    self->peekToken = self->curToken = &cur->next;
    return cur;
}

const Token_t *
Scanner_Peek(Scanner_t * self)
{
    Token_t * cur;
    do {
	if (*self->peekToken == NULL) {
	    *self->peekToken = Scanner_NextToken(self);
	    if (self->peekToken == &self->busyTokenList)
		Buffer_SetBusy(&self->buffer, self->busyTokenList->pos);
	}
	cur = *self->peekToken;
	self->peekToken = &cur->next;
    } while (cur->kind > self->maxT); /* Skip pragmas */
    return cur;
}

void
Scanner_ResetPeek(Scanner_t * self)
{
    *self->peekToken = *self->curToken;
}

/* All the following things are used by Scanner_NextToken. */
typedef struct {
    int key, val;
}  Char2State_t;

static const Char2State_t c2sArr[] = {
    /*---- chars2states ----*/
    /*---- enable ----*/
};
static const int c2sNum = sizeof(c2sArr) / sizeof(c2sArr[0]);

static int
c2sCmp(const void * key, const void * c2s)
{
    return *((const int *)key) - ((const Char2State_t *)c2s)->key;
}
static int
Char2State(int chr)
{
    Char2State_t * c2s;

    c2s = bsearch(&chr, c2sArr, c2sNum, sizeof(Char2State_t), c2sCmp);
    return c2s ? c2s->val : 0;
}

typedef struct {
    const char * key;
    int val;
}  Identifier2KWKind_t;

static const Identifier2KWKind_t i2kArr[] = {
    /*---- identifiers2keywordkinds ----*/
    /*---- enable ----*/
};
static const int i2kNum = sizeof(i2kArr) / sizeof(i2kArr[0]);

static int
i2kCmp(const void * key, const void * i2k)
{
    return strcmp((const char *)key, ((const Identifier2KWKind_t *)i2k)->key);
}

static int
Identifier2KWKind(const char * key, size_t keylen, int defaultVal)
{
    char * keystr;
    Identifier2KWKind_t * i2k;

    keystr = alloca(keylen + 1);
    memcpy(keystr, key, keylen);
    keystr[keylen] = 0;
    i2k = bsearch(keystr, i2kArr, i2kNum, sizeof(Identifier2KWKind_t), i2kCmp);
    return i2k ? i2k->val : defaultVal;
}

static void
Scanner_GetCh(Scanner_t * self)
{
    if (self->oldEols > 0) {
	self->ch = '\n'; --self->oldEols; self->oldEolsEOL= 1;
    } else {
	if (self->ch == '\n') {
	    if (self->oldEolsEOL) self->oldEolsEOL = 0;
	    else {
		++self->line; self->col = 0;
	    }
	} else {
	    self->col += self->chBytes;
	}
	self->ch = Buffer_Read(&self->buffer, &self->chBytes);
	self->pos = Buffer_GetPos(&self->buffer);
    }
}

typedef struct {
    int ch, chBytes;
    int pos, line, col;
}  SLock_t;
static void
Scanner_LockCh(Scanner_t * self, SLock_t * slock)
{
    slock->ch = self->ch;
    slock->chBytes = self->chBytes;
    slock->pos = self->pos;
    slock->line = self->line;
    slock->col = self->col;
    Buffer_Lock(&self->buffer);
}
static void
Scanner_UnlockCh(Scanner_t * self, SLock_t * slock)
{
    Buffer_Unlock(&self->buffer);
}
static void
Scanner_ResetCh(Scanner_t * self, SLock_t * slock)
{
    self->ch = slock->ch;
    self->chBytes = slock->chBytes;
    self->pos = slock->pos;
    self->line = slock->line;
    self->line = slock->line;
    Buffer_LockReset(&self->buffer);
}

/*---- comments ----*/
/*---- enable ----*/

Token_t *
Scanner_NextToken(Scanner_t * self)
{
    int pos, line, col, state, kind; Token_t * t;
    for (;;) {
	while (self->ch == ' ' ||
	       /*---- scan1 ----*/
	       /*---- enable ----*/
	       ) Scanner_GetCh(self);
	/*---- scan2 ----*/
	/*---- enable ----*/
	break;
    }
    pos = self->pos; line = self->line; col = self->col;
    Buffer_Lock(&self->buffer);
    state = Char2State(self->ch);
    Scanner_GetCh(self);
    switch (state) {
    case -1: kind = self->eofSym; break;
    case 0: kind = self->noSym; break;
	/*---- scan3 ----*/
	/*---- enable ----*/
    }
    t = Token(kind, pos, col, line,
	      Buffer_GetString(&self->buffer, pos, self->pos - pos),
	      self->pos - pos);
    Buffer_Unlock(&self->buffer);
    return t;
}
