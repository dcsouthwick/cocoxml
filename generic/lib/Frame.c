/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
#include  <ctype.h>
#include  <stdio.h>
#include  <stdlib.h>
#include  <string.h>
#include  "Frame.h"

static Bool_t
LocateMark(const char ** b, const char ** e,
	   const char * lmark, const char * rmark)
{
    int llen = strlen(lmark), rlen = strlen(rmark);
    int tlen = llen + rlen;
    while (*b < *e && isspace(**b)) ++*b;
    while (*b < *e && isspace(*(*e - 1))) --*e;
    if (*e - *b < tlen) return FALSE;
    if (strncmp(*b, lmark, llen)) return FALSE;
    if (strncmp(*e - rlen, rmark, rlen)) return FALSE;
    *b += llen; *e -= rlen;
    while (*b < *e && isspace(**b)) ++*b;
    while (*b < *e && isspace(*(*e - 1))) --*e;
    return TRUE;
}

static void
GetResult(char * dest, size_t destlen, const char * src, size_t srclen)
{
    if (srclen < destlen - 1) {
	memcpy(dest, src, srclen); dest[srclen] = 0;
    } else {
	memcpy(dest, src, destlen - 1); dest[destlen - 1] = 0;
    }
}

static Bool_t
CheckMark(const char * lnbuf,
	  char * retIndent, size_t szRetIndent,
	  char * retCommand, size_t szRetCommand,
	  char * retParamStr, size_t szRetParamStr,
	  char * retSections, size_t szRetSections)
{
    const char * b, * e, * start;
    if (!*lnbuf) return FALSE;
    b = lnbuf; e = lnbuf + strlen(lnbuf);

    for (b = lnbuf; isspace(*b); ++b);
    GetResult(retIndent, szRetIndent, lnbuf, b - lnbuf);

    if (!LocateMark(&b, &e, "/*---- ", " ----*/")) return FALSE;
    start = b;
    while (b < e && isalnum(*b)) ++b;
    GetResult(retCommand, szRetCommand, start, b - start);

    while (b < e && isspace(*b)) ++b;
    if (*b != '(') *retParamStr = 0;
    else {
	start = b + 1;
	while (b <= e && *b != ')') ++b;
	GetResult(retParamStr, szRetParamStr, start, b - start);
	++b;
    }

    while (b < e && isspace(*b)) ++b;
    if (b >= e) *retSections = 0;
    else {
	start = b;
	while (b < e && isalnum(*b)) ++b;
	GetResult(retSections, szRetSections, start, b - start);
    }
    return TRUE;
}

static void
TextWritter(DumpBuffer_t * dbuf, char * lnbuf,
	    const char * replacedPrefix, const char * prefix)
{
    char * start, * cur; int len;
    if (!*replacedPrefix) {
	DumpBuffer_Print(dbuf, "%s", lnbuf);
	return;
    }
    len = strlen(replacedPrefix);
    start = cur = lnbuf;
    while (*cur) {
	if (*cur != *replacedPrefix) ++cur;
	else if (strncmp(cur, replacedPrefix, len)) ++cur;
	else { /* An instance of replacedPrefix is found. */
	    *cur = 0;
	    DumpBuffer_Print(dbuf, "%s", start);
	    start = (cur += len);
	    DumpBuffer_Print(dbuf, "%s", prefix);
	}
    }
    DumpBuffer_Print(dbuf, "%s", start);
}

int
Frames(char          secChr,
       const char  * outDir,
       const char  * prefix,
       const char  * license,
       void        * cbData,
       int        (* cbFunc)(void * cbData,
			     FILE * outfp,
			     const char * indentstr,
			     const char * command,
			     const char * paramstr),
       int           numFrames,
       const char ** frameNames)
{
    const char ** curframefn;
    FILE * framefp, * outfp; Bool_t enabled;
    char outFName[256], lnbuf[4096];
    char indentStr[128], Command[128], ParamStr[128], Sections[8];
    char replacedPrefix[128];
    DumpBuffer_t dbuf; char dbufspace[16384];

    outfp = NULL; DumpBuffer(&dbuf, dbufspace, sizeof(dbufspace));
    for (curframefn = frameNames;
	 curframefn - frameNames < numFrames; ++curframefn) {
	if (!(framefp = fopen(*curframefn, "r"))) goto errquit0;
	enabled = TRUE;
	while (fgets(lnbuf, sizeof(lnbuf), framefp)) {
	    if (!CheckMark(lnbuf,
			   indentStr, sizeof(indentStr),
			   Command, sizeof(Command),
			   ParamStr, sizeof(ParamStr),
			   Sections, sizeof(Sections))) {
		if (enabled) {
		    TextWritter(&dbuf, lnbuf, replacedPrefix, prefix);
		    if (outfp) {
			fputs(dbufspace, outfp); DumpBuffer_Clear(&dbuf);
		    }
		}
		continue;
	    }

	    /* Clear up dbufspace before fclose. */
	    if (Sections[0] == 0 || strchr(Sections, secChr)) {
		if (!strcmp(Command, "open") && outfp) {
		    if (*dbufspace) {
			fputs(dbufspace, outfp); DumpBuffer_Clear(&dbuf);
		    }
		    fclose(outfp);
		}
	    }
	    /* Instruction line is kept in even if enabled is FALSE. */
	    DumpBuffer_Print(&dbuf, "%s", lnbuf);
	    if (outfp) {
		fputs(dbufspace, outfp); DumpBuffer_Clear(&dbuf);
	    }
	    /* Do the instructions. */
	    if (Sections[0] == 0 || strchr(Sections, secChr)) {
		if (!strcmp(Command, "open")) {
		    snprintf(outFName, sizeof(outFName),
			     "%s/%s", outDir, ParamStr);
		    if (!(outfp = fopen(outFName, "w"))) goto errquit1;
		    DumpBuffer_Print(&dbuf, "%s", license);
		    fputs(dbufspace, outfp); DumpBuffer_Clear(&dbuf);
		    enabled = FALSE;
		} else if (!strcmp(Command, "prefix")) {
		    if (ParamStr == NULL) replacedPrefix[0] = 0;
		    else strncpy(replacedPrefix, ParamStr,
				 sizeof(replacedPrefix));
		} else if (!strcmp(Command, "enable")) {
		    enabled = TRUE;
		} else if (!strcmp(Command, "disable")) {
		    enabled = FALSE;
		} else { /* Caller specific commands. */
		    if (outfp) {
			if (*dbufspace) {
			    fputs(dbufspace, outfp); DumpBuffer_Clear(&dbuf);
			}
			if (cbFunc &&
			    cbFunc(cbData, outfp,
				   indentStr, Command, ParamStr) < 0)
			    goto errquit1;
		    }
		    enabled = FALSE;
		}
	    }
	}
	fclose(framefp);
    }
    if (outfp != NULL) {
	if (*dbufspace) { /* Write the remaineded text. */
	    fputs(dbufspace, outfp); DumpBuffer_Clear(&dbuf);
	}
	fclose(outfp);
    }
    return 0;
 errquit1:
    if (outfp != NULL) fclose(outfp);
    fclose(framefp);
 errquit0:
    return -1;
}

int
Frame(char         secChr,
      const char * outDir,
      const char * prefix,
      const char * license,
      void       * cbData,
      int       (* cbFunc)(void       * cbData,
			   FILE       * outfp,
			   const char * indentstr,
			   const char * command,
			   const char * paramstr),
      const char * frameName)
{
    const char * frameNames[1];
    frameNames[0] = frameName;
    return Frames(secChr, outDir, prefix, license,
		  cbData, cbFunc, 1, frameNames);
}
