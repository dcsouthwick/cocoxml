/*---- license ----*/
/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*---- enable ----*/
#include  <ctype.h>
#include  "Parser.h"
#include  "CGlobals.h"
/*
#include  "Tab.h"
#include  "Symbol.h"
#include  "Node.h"
#include  "CharSet.h"
#include  "CharClass.h"
#include  "DFA.h"
#include  "Graph.h"
*/
/*---- constantsheader ----*/
static const int CcsParser_id = 0;
static const int CcsParser_str = 1;
/*---- enable ----*/

void
CcsParser_SynErr(CcsParser_t * self, int n)
{
    const char * s; char format[20];
    switch (n) {
	/*---- errors ----*/
    case 0: s = "EOF expected"; break;
    case 1: s = "ident expected"; break;
    case 2: s = "number expected"; break;
    case 3: s = "string expected"; break;
    case 4: s = "badString expected"; break;
    case 5: s = "char expected"; break;
    case 6: s = "\"COMPILER\" expected"; break;
    case 7: s = "\"IGNORECASE\" expected"; break;
    case 8: s = "\"CHARACTERS\" expected"; break;
    case 9: s = "\"TOKENS\" expected"; break;
    case 10: s = "\"PRAGMAS\" expected"; break;
    case 11: s = "\"COMMENTS\" expected"; break;
    case 12: s = "\"FROM\" expected"; break;
    case 13: s = "\"TO\" expected"; break;
    case 14: s = "\"NESTED\" expected"; break;
    case 15: s = "\"IGNORE\" expected"; break;
    case 16: s = "\"PRODUCTIONS\" expected"; break;
    case 17: s = "\"=\" expected"; break;
    case 18: s = "\".\" expected"; break;
    case 19: s = "\"END\" expected"; break;
    case 20: s = "\"+\" expected"; break;
    case 21: s = "\"-\" expected"; break;
    case 22: s = "\"..\" expected"; break;
    case 23: s = "\"ANY\" expected"; break;
    case 24: s = "\"<\" expected"; break;
    case 25: s = "\">\" expected"; break;
    case 26: s = "\"<.\" expected"; break;
    case 27: s = "\".>\" expected"; break;
    case 28: s = "\"|\" expected"; break;
    case 29: s = "\"WEAK\" expected"; break;
    case 30: s = "\"(\" expected"; break;
    case 31: s = "\")\" expected"; break;
    case 32: s = "\"[\" expected"; break;
    case 33: s = "\"]\" expected"; break;
    case 34: s = "\"{\" expected"; break;
    case 35: s = "\"}\" expected"; break;
    case 36: s = "\"SYNC\" expected"; break;
    case 37: s = "\"IF\" expected"; break;
    case 38: s = "\"CONTEXT\" expected"; break;
    case 39: s = "\"(.\" expected"; break;
    case 40: s = "\".)\" expected"; break;
    case 41: s = "??? expected"; break;
    case 42: s = "this symbol not expected in Coco"; break;
    case 43: s = "this symbol not expected in TokenDecl"; break;
    case 44: s = "invalid TokenDecl"; break;
    case 45: s = "invalid AttrDecl"; break;
    case 46: s = "invalid SimSet"; break;
    case 47: s = "invalid Sym"; break;
    case 48: s = "invalid Term"; break;
    case 49: s = "invalid Factor"; break;
    case 50: s = "invalid Attribs"; break;
    case 51: s = "invalid TokenFactor"; break;
	/*---- enable ----*/
    default:
	snprintf(format, sizeof(format), "error %d", n);
	s = format;
	break;
    }
    CcsErrorPool_Error(&self->globals->error, self->la->line, self->la->col, "%s", s);
}

void
CcsParser_SemErr(CcsParser_t * self, const char * format, ...)
{
    va_list ap;
    /*if (self->errDist >= self->minErrDist) {*/
    va_start(ap, format);
    Errors_Error(&self->globals->error, self->t->line, self->t->col, format, ap);
    va_end(ap);
    /*}
      self->errDist = 0;*/
}

#if 0
static void
CcsParser_Get(CcsParser_t * self)
{
    for (;;) {
	self->t = self->la;
	self->la = Scanner_Scan(self->scanner);
	if (self->la->kind <= self->maxT) { ++self->errDist; break; }
	/*---- pragmas ----*/
	if (self->la->kind == 42) {
	    Tab_SetDDT(self->tab, self->la->val);
	}
	/*---- enable ----*/
	self->la = self->t;
    }
}

static const char * set[] = {
    /*---- initialization ----*/
    "**.*.*....**...***.....................*...",
    ".*****.***********************************.",
    ".******.....***..*************************.",
    "**.*.*....**...****....*....***.*.*.**.*...",
    "**.*.*....**...***.*...................*...",
    "**.*.*....**...***.....................*...",
    ".*.*.*....**...**......................*...",
    "...........*.****.*............*.*.*.......",
    ".*.*.*........................*.*.*........",
    ".************************.****************.",
    ".***.********************.****************.",
    ".**************************.**************.",
    ".***.**********************.**************.",
    ".***************************************.*.",
    ".***.**********************************..*.",
    "..................*............*.*.*.......",
    ".*.*.*............*....*....**********.*...",
    ".*.*.*.................*.....**.*.*.**.*...",
    ".*.*.*.................*.....**.*.*.*..*...",
    "..................*.........*..*.*.*.......",
    ".******************************.**********."
    /*---- enable ----*/
};
static int
CcsParser_StartOf(CcsParser_t * self, int s)
{
    return set[s][self->la->kind] == '*';
}

static void
CcsParser_Expect(CcsParser_t * self, int n)
{
    if (self->la->kind == n) CcsParser_Get(self);
    else CcsParser_SynErr(self, n);
}

static void
CcsParser_ExpectWeak(CcsParser_t * self, int n, int follow)
{
    if (self->la->kind == n) CcsParser_Get(self);
    else {
	CcsParser_SynErr(self, n);
	while (!CcsParser_StartOf(self, follow)) CcsParser_Get(self);
    }
}

static int
CcsParser_WeakSeparator(CcsParser_t * self, int n, int syFol, int repFol)
{
    if (self->la->kind == n) { CcsParser_Get(self); return 1; }
    else if (CcsParser_StartOf(self, repFol)) { return 1; }
    CcsParser_SynErr(self, n);
    while (!(CcsParser_StartOf(self, syFol) ||
	     CcsParser_StartOf(self, repFol) ||
	     CcsParser_StartOf(self, 0)))
	CcsParser_Get(self);
    return CcsParser_StartOf(self, syFol);
}

/*---- productionsheader ----*/
static void CcsParser_Coco(CcsParser_t * self);
static void CcsParser_SetDecl(CcsParser_t * self);
static void CcsParser_TokenDecl(CcsParser_t * self, int typ);
static void CcsParser_TokenExpr(CcsParser_t * self, Graph_t ** g);
static void CcsParser_Set(CcsParser_t * self, CharSet_t ** s);
static void CcsParser_AttrDecl(CcsParser_t * self, Symbol_t * sym);
static void CcsParser_SemText(CcsParser_t * self, Position_t ** pos);
static void CcsParser_Expression(CcsParser_t * self, Graph_t ** g);
static void CcsParser_SimSet(CcsParser_t * self, CharSet_t ** s);
static void CcsParser_Char(CcsParser_t * self, int * n);
static void CcsParser_Sym(CcsParser_t * self, char ** name, int * kind);
static void CcsParser_Term(CcsParser_t * self, Graph_t ** g);
static void CcsParser_Resolver(CcsParser_t * self, Position_t ** pos);
static void CcsParser_Factor(CcsParser_t * self, Graph_t ** g);
static void CcsParser_Attribs(CcsParser_t * self, Node_t * p);
static void CcsParser_Condition(CcsParser_t * self);
static void CcsParser_TokenTerm(CcsParser_t * self, Graph_t ** g);
static void CcsParser_TokenFactor(CcsParser_t * self, Graph_t ** g);
/*---- enable ----*/

void
CcsParser_Parse(CcsParser_t * self)
{
    self->t = NULL;
    self->la = Scanner_GetDummy(self->scanner);
    CcsParser_Get(self);
    /*---- parseRoot ----*/
    CcsParser_Coco(self);
    /*---- enable ----*/
    CcsParser_Expect(self, 0);
}

CcsParser_t *
CcsParser(CcsParser_t * self, Scanner_t * scanner)
{
    /*---- constants ----*/
    self->maxT = 41;
    /*---- enable ----*/
    self->t = self->la = NULL;
    self->minErrDist = 2;
    self->errDist = self->minErrDist;
    self->scanner = scanner;
    Errors(&self->errors, stderr);
    return self;
}

void
CcsParser_Destruct(CcsParser_t * self)
{
    Errors_Destruct(&self->errors);
}

/*---- productionsheader ----*/
static void /* OK */
CcsParser_Coco(CcsParser_t * self) {
    Symbol_t * sym;
    Graph_t * g, * g1, * g2;
    const char * gramName = NULL;
    CharSet_t * s;

    InitDeclarations();
    Token_t * beg;
    Scanner_IncRef(self->scanner, beg = self->la);
    while (CcsParser_StartOf(self, 1)) {
	CcsParser_Get(self);
    }
    if (self->la->pos != beg->pos) {
	self->pgen->usingPos =
	    Scanner_GetPositionWithTail(self->scanner, beg, self->t);
	/*pgen->usingPos = new Position(beg, t->pos - beg + coco_string_length(t->val), 0);*/
    }

    CcsParser_Expect(self, 6);
    self->genScanner = TRUE;
    self->tab->ignored = CharSet(NULL); 
    CcsParser_Expect(self, 1);
    gramName = strdupa(self->t->val);
    Scanner_DecRef(self->scanner, beg);
    Scanner_IncRef(self->scanner, beg = self->la);

    while (CcsParser_StartOf(self, 2)) {
	CcsParser_Get(self);
    }
    self->tab->semDeclPos = Scanner_GetPosition(self->scanner, beg, self->la);
    if (self->la->kind == 7) {
	CcsParser_Get(self);
	self->dfa->ignoreCase = TRUE; 
    }
    if (self->la->kind == 8) {
	CcsParser_Get(self);
	while (self->la->kind == 1) {
	    CcsParser_SetDecl(self);
	}
    }
    if (self->la->kind == 9) {
	CcsParser_Get(self);
	while (self->la->kind == 1 || self->la->kind == 3 || self->la->kind == 5) {
	    CcsParser_TokenDecl(self, node_t);
	}
    }
    if (self->la->kind == 10) {
	CcsParser_Get(self);
	while (self->la->kind == 1 || self->la->kind == 3 || self->la->kind == 5) {
	    CcsParser_TokenDecl(self, node_pr);
	}
    }
    while (self->la->kind == 11) {
	CcsParser_Get(self);
	Bool_t nested = FALSE; 
	CcsParser_Expect(self, 12);
	CcsParser_TokenExpr(self, &g1);
	CcsParser_Expect(self, 13);
	CcsParser_TokenExpr(self, &g2);
	if (self->la->kind == 14) {
	    CcsParser_Get(self);
	    nested = TRUE; 
	}
	DFA_NewComment(self->dfa, g1->l, g2->l, nested);
    }
    while (self->la->kind == 15) {
	CcsParser_Get(self);
	CcsParser_Set(self, &s);
	CharSet_Or(self->tab->ignored, s);
    }
    while (!(self->la->kind == 0 || self->la->kind == 16)) {CcsParser_SynErr(self, 42); CcsParser_Get(self);}
    CcsParser_Expect(self, 16);
    if (self->genScanner) DFA_MakeDeterministic(self->dfa);
    Tab_DeleteNodes(self->tab);

    while (self->la->kind == 1) {
	CcsParser_Get(self);
	sym = Tab_FindSym(self->tab, self->t->val);
	Bool_t undef = (sym == NULL);
	if (undef) sym = Tab_NewSym(self->tab, node_nt, self->t->val, self->t->line);
	else {
	    if (sym->typ == node_nt) {
		if (sym->graph != NULL) CcsParser_SemErr(self, "name declared twice");
	    } else CcsParser_SemErr(self, "this symbol kind not allowed on left side of production");
	    sym->line = self->t->line;
	}
	Bool_t noAttrs = (sym->attrPos == NULL);
	sym->attrPos = NULL;

	if (self->la->kind == 24 || self->la->kind == 26) {
	    CcsParser_AttrDecl(self, sym);
	}
	if (!undef)
	    if (noAttrs != (sym->attrPos == NULL))
		CcsParser_SemErr(self, "attribute mismatch between declaration and use of this symbol");

	if (self->la->kind == 39) {
	    CcsParser_SemText(self, &sym->semPos);
	}
	CcsParser_ExpectWeak(self, 17, 3);
	CcsParser_Expression(self, &g);
	sym->graph = g->l;
	Tab_Finish(self->tab, g);
	
	CcsParser_ExpectWeak(self, 18, 4);
    }
    CcsParser_Expect(self, 19);
    CcsParser_Expect(self, 1);
    if (strcmp(gramName, self->t->val))
	CcsParser_SemErr(self, "name does not match grammar name");
    self->tab->gramSy = Tab_FindSym(self->tab, gramName);
    if (self->tab->gramSy == NULL)
	CcsParser_SemErr(self, "missing production for grammar name");
    else {
	sym = self->tab->gramSy;
	if (sym->attrPos != NULL)
	    CcsParser_SemErr(self, "grammar symbol must not have attributes");
    }
    self->tab->noSym = Tab_NewSym(self->tab, node_t, "???", 0); /* noSym gets highest number */
    Tab_SetupAnys(self->tab);
    Tab_RenumberPragmas(self->tab);
    if (self->tab->ddt[2]) Tab_PrintNodes(self->tab);
    if (self->errors.count == 0) {
	fprintf(stderr, "checking\n");
	Tab_CompSymbolSets(self->tab);
	if (self->tab->ddt[7]) Tab_XRef(self->tab);
	if (Tab_GrammarOk(self->tab)) {
	    fprintf(stderr, "parser");
	    CcsParserGen_WriteCcsParser(self->pgen);
	    if (self->genScanner) {
		fprintf(stderr, " + scanner");
		DFA_WriteScanner(self->dfa);
		if (self->tab->ddt[0]) DFA_PrintStates(self->dfa);
	    }
	    fprintf(stderr, " generated\n");
	    if (self->tab->ddt[8]) CcsParserGen_WriteStatistics(self->pgen);
	}
    }
    if (self->tab->ddt[6]) Tab_PrintSymbolTable(self->tab);

    CcsParser_Expect(self, 18);
}

static void /* OK */
CcsParser_SetDecl(CcsParser_t * self) {
    CharSet_t * s; 
    CcsParser_Expect(self, 1);
    const char * name = self->t->val;
    CharClass_t * c = Tab_FindCharClassS(self->tab, name);

    if (c != NULL) CcsParser_SemErr(self, "name declared twice");

    CcsParser_Expect(self, 17);
    CcsParser_Set(self, &s);
    if (CharSet_Elements(s) == 0)
	CcsParser_SemErr(self, "character set must not be empty");
    Tab_NewCharClass(self->tab, name, s);

    CcsParser_Expect(self, 18);
}

static void /* OK */
CcsParser_TokenDecl(CcsParser_t * self, int typ) {
    char * name = NULL; int kind; Symbol_t * sym; Graph_t * g; 
    CcsParser_Sym(self, &name, &kind);
    sym = Tab_FindSym(self->tab, name);
    if (sym != NULL) CcsParser_SemErr(self, "name declared twice");
    else {
	sym = Tab_NewSym(self->tab, typ, name, self->t->line);
	sym->tokenKind = symbol_fixedToken;
    }
    self->tokenString = NULL;

    while (!(CcsParser_StartOf(self, 5))) {
	CcsParser_SynErr(self, 43); CcsParser_Get(self);
    }
    if (self->la->kind == 17) {
	CcsParser_Get(self);
	CcsParser_TokenExpr(self, &g);
	CcsParser_Expect(self, 18);
	if (kind == CcsParser_str)
	    CcsParser_SemErr(self, "a literal must not be declared with a structure");
	Tab_Finish(self->tab, g);
	if (self->tokenString == NULL ||
	    !strcmp(self->tokenString, self->noString))
	    DFA_ConvertToStates(self->dfa, g->l, sym);
	else { /* CcsParser_TokenExpr is a single string */
	    if (HashTable_Get(&self->tab->literals, self->tokenString) != NULL)
		CcsParser_SemErr(self, "token string declared twice");
	    HashTable_Set(&self->tab->literals, self->tokenString, sym);
	    DFA_MatchLiteral(self->dfa, self->tokenString, sym);
	}
    } else if (CcsParser_StartOf(self, 6)) {
	if (kind == CcsParser_id) self->genScanner = FALSE;
	else DFA_MatchLiteral(self->dfa, sym->name, sym);
    } else CcsParser_SynErr(self, 44);
    if (self->la->kind == 39) {
	CcsParser_SemText(self, &sym->semPos);
	if (typ != node_pr)
	    CcsParser_SemErr(self, "semantic action not allowed here"); 
    }
}

static void /* OK */
CcsParser_TokenExpr(CcsParser_t * self, Graph_t ** g) {
    Graph_t * g2;
    CcsParser_TokenTerm(self, g);
    Bool_t first = TRUE; 
    while (CcsParser_WeakSeparator(self, 28,8,7) ) {
	CcsParser_TokenTerm(self, &g2);
	if (first) { Tab_MakeFirstAlt(self->tab, *g); first = FALSE; }
	Tab_MakeAlternative(self->tab, *g, g2);
    }
}

static void /* OK */
CcsParser_Set(CcsParser_t * self, CharSet_t ** s) {
    CharSet_t * s2; 
    CcsParser_SimSet(self, s);
    while (self->la->kind == 20 || self->la->kind == 21) {
	if (self->la->kind == 20) {
	    CcsParser_Get(self);
	    CcsParser_SimSet(self, &s2);
	    CharSet_Or(*s, s2);
	} else {
	    CcsParser_Get(self);
	    CcsParser_SimSet(self, &s2);
	    CharSet_Subtract(*s, s2);
	}
    }
}

static void /* OK */
CcsParser_AttrDecl(CcsParser_t * self, Symbol_t * sym) {
    if (self->la->kind == 24) {
	CcsParser_Get(self);
	Token_t * beg;
	Scanner_IncRef(self->scanner, beg = self->la);
	while (CcsParser_StartOf(self, 9)) {
	    if (CcsParser_StartOf(self, 10)) {
		CcsParser_Get(self);
	    } else {
		CcsParser_Get(self);
		CcsParser_SemErr(self, "bad string in attributes"); 
	    }
	}
	CcsParser_Expect(self, 25);
	sym->attrPos = Scanner_GetPosition(self->scanner, beg, self->t);
	Scanner_DecRef(self->scanner, beg);
    } else if (self->la->kind == 26) {
	CcsParser_Get(self);
	Token_t * beg;
	Scanner_IncRef(self->scanner, beg = self->la);
	while (CcsParser_StartOf(self, 11)) {
	    if (CcsParser_StartOf(self, 12)) {
		CcsParser_Get(self);
	    } else {
		CcsParser_Get(self);
		CcsParser_SemErr(self, "bad string in attributes"); 
	    }
	}
	CcsParser_Expect(self, 27);
	sym->attrPos = Scanner_GetPosition(self->scanner, beg, self->t);
	Scanner_DecRef(self->scanner, beg);
    } else {
	CcsParser_SynErr(self, 45);
    }
}

static void /* OK */
CcsParser_SemText(CcsParser_t * self, Position_t ** pos) {
    CcsParser_Expect(self, 39);
    Token_t * beg;
    Scanner_IncRef(self->scanner, beg = self->la);
    while (CcsParser_StartOf(self, 13)) {
	if (CcsParser_StartOf(self, 14)) {
	    CcsParser_Get(self);
	} else if (self->la->kind == 4) {
	    CcsParser_Get(self);
	    CcsParser_SemErr(self, "bad string in semantic action"); 
	} else {
	    CcsParser_Get(self);
	    CcsParser_SemErr(self, "missing end of previous semantic action"); 
	}
    }
    CcsParser_Expect(self, 40);
    *pos = Scanner_GetPosition(self->scanner, beg, self->t);
    Scanner_DecRef(self->scanner, beg);
}

static void /* OK */
CcsParser_Expression(CcsParser_t * self, Graph_t ** g) {
    Graph_t * g2;
    CcsParser_Term(self, g);
    Bool_t first = TRUE; 
    while (CcsParser_WeakSeparator(self, 28,16,15) ) {
	CcsParser_Term(self, &g2);
	if (first) { Tab_MakeFirstAlt(self->tab, *g); first = FALSE; }
	Tab_MakeAlternative(self->tab, *g, g2);
    }
}

static void /* OK */
CcsParser_SimSet(CcsParser_t * self, CharSet_t ** s) {
    int n1, n2; 
    *s = CharSet(NULL); 
    if (self->la->kind == 1) {
	CcsParser_Get(self);
	CharClass_t * c = Tab_FindCharClassS(self->tab, self->t->val);
	if (c == NULL) CcsParser_SemErr(self, "undefined name");
	else CharSet_Or(*s, c->set);
    } else if (self->la->kind == 3) {
	CcsParser_Get(self);
	const char * cur0; int ch;
	char * cur, * name = Unescape(self->t->val);
	if (self->dfa->ignoreCase) {
	    for (cur = name; *cur; ++cur) *cur = tolower(*cur);
	}
	cur0 = name;
	while (*cur0) {
	    ch = UTF8Get(&cur0, EoF);
	    assert(ch >= 0);
	    CharSet_Set(*s, ch);
	}
	CocoFree(name);
    } else if (self->la->kind == 5) {
	CcsParser_Char(self, &n1);
	CharSet_Set(*s, n1);
	if (self->la->kind == 22) {
	    CcsParser_Get(self);
	    CcsParser_Char(self, &n2);
	    int idx;
	    for (idx = n1; idx <= n2; ++idx) CharSet_Set(*s, idx); 
	}
    } else if (self->la->kind == 23) {
	CcsParser_Get(self);
	*s = CharSet(NULL); CharSet_Fill(*s, COCO_WCHAR_MAX);
    } else {
	CcsParser_SynErr(self, 46);
    }
}

static void /* OK */
CcsParser_Char(CcsParser_t * self, int * n) {
    CcsParser_Expect(self, 5);
    *n = 0;
    char * name; const char * cur;
    cur = name = Unescape(self->t->val);
    *n = UTF8Get(&cur, EoF);
    if (*cur != 0) CcsParser_SemErr(self, "unacceptable character value");
    CocoFree(name);
    if (self->dfa->ignoreCase) *n = tolower(*n);
}

static void /* OK */
CcsParser_Sym(CcsParser_t * self, char ** name, int * kind) {
    *name = CocoStrdup("???"); *kind = CcsParser_id;
    if (self->la->kind == 1) {
	CcsParser_Get(self);
	*kind = CcsParser_id; CocoFree(*name); *name = CocoStrdup(self->t->val);
    } else if (self->la->kind == 3 || self->la->kind == 5) {
	if (self->la->kind == 3) {
	    CcsParser_Get(self);
	    CocoFree(*name); *name = CocoStrdup(self->t->val);
	} else {
	    CcsParser_Get(self);
	    /* FIX ME: csharp code is:
	     * name = "\"" + t.val.Substring(1, t.val.Length-2) + "\""; */
	    CocoFree(*name); *name = CocoStrdup(self->t->val);
	}
	*kind = CcsParser_str;
	if (self->dfa->ignoreCase) {
	    char * cur;
	    for (cur = *name; *cur; ++cur) *cur = tolower(*cur);
	}
	if (strchr(*name, ' '))
	    CcsParser_SemErr(self, "literal tokens \"%s\" can not contain blanks", *name);
    } else {
	CcsParser_SynErr(self, 47);
    }
}

static void /* OK */
CcsParser_Term(CcsParser_t * self, Graph_t ** g) {
    Graph_t *g2; Node_t * rslv = NULL; *g = NULL; 
    if (CcsParser_StartOf(self, 17)) {
	if (self->la->kind == 37) {
	    rslv = Tab_NewNodeTSL(self->tab, node_rslv, NULL, self->la->line); 
	    CcsParser_Resolver(self, &rslv->pos);
	    *g = GraphP(NULL, rslv);
	}
	CcsParser_Factor(self, &g2);
	if (rslv != NULL) Tab_MakeSequence(self->tab, *g, g2);
	else *g = g2;
	while (CcsParser_StartOf(self, 18)) {
	    CcsParser_Factor(self, &g2);
	    Tab_MakeSequence(self->tab, *g, g2);
	}
    } else if (CcsParser_StartOf(self, 19)) {
	*g = GraphP(NULL, Tab_NewNodeTSL(self->tab, node_eps, NULL, 0)); 
    } else CcsParser_SynErr(self, 48);
    if (*g == NULL) /* invalid start of Term */
	*g = GraphP(NULL, Tab_NewNodeTSL(self->tab, node_eps, NULL, 0)); 
}

static void /* OK */
CcsParser_Resolver(CcsParser_t * self, Position_t ** pos) {
    CcsParser_Expect(self, 37);
    CcsParser_Expect(self, 30);
    Token_t * beg;
    Scanner_IncRef(self->scanner, beg = self->la);
    CcsParser_Condition(self);
    *pos = Scanner_GetPosition(self->scanner, beg, self->t);
    Scanner_DecRef(self->scanner, beg);
}

static void /* OK */
CcsParser_Factor(CcsParser_t * self, Graph_t ** g) {
    char * name = NULL; int kind; Position_t * pos; Bool_t weak = FALSE; 
    *g = NULL;

    switch (self->la->kind) {
    case 1: case 3: case 5: case 29: {
	if (self->la->kind == 29) {
	    CcsParser_Get(self);
	    weak = TRUE; 
	}
	CcsParser_Sym(self, &name, &kind);
	Symbol_t * sym = Tab_FindSym(self->tab, name);
	if (sym == NULL && kind == CcsParser_str)
	    sym = (Symbol_t *)HashTable_Get(&self->tab->literals, name);
	Bool_t undef = (sym == NULL);
	if (undef) {
	    if (kind == CcsParser_id)
		sym = Tab_NewSym(self->tab, node_nt, name, 0);  /* forward nt */
	    else if (self->genScanner) { 
		sym = Tab_NewSym(self->tab, node_t, name, self->t->line);
		DFA_MatchLiteral(self->dfa, sym->name, sym);
	    } else {  /* undefined string in production */
		CcsParser_SemErr(self, "undefined string in production");
		sym = self->tab->eofSy;  /* dummy */
	    }
	}
	int typ = sym->typ;
	if (typ != node_t && typ != node_nt)
	    CcsParser_SemErr(self, "this symbol kind is not allowed in a production");
	if (weak) {
	    if (typ == node_t) typ = node_wt;
	    else CcsParser_SemErr(self, "only terminals may be weak");
	}
	Node_t * p = Tab_NewNodeTSL(self->tab, typ, sym, self->t->line);
	*g = GraphP(NULL, p);

	if (self->la->kind == 24 || self->la->kind == 26) {
	    CcsParser_Attribs(self, p);
	    if (kind != CcsParser_id)
		CcsParser_SemErr(self, "a literal must not have attributes");
	}
	if (undef)
	    sym->attrPos = p->pos;  /* dummy */
	else if ((p->pos == NULL) != (sym->attrPos == NULL))
	    CcsParser_SemErr(self, "attribute mismatch between declaration and use of this symbol");
	break;
    }
    case 30: {
	CcsParser_Get(self);
	CcsParser_Expression(self, g);
	CcsParser_Expect(self, 31);
	break;
    }
    case 32: {
	CcsParser_Get(self);
	CcsParser_Expression(self, g);
	CcsParser_Expect(self, 33);
	Tab_MakeOption(self->tab, *g); 
	break;
    }
    case 34: {
	CcsParser_Get(self);
	CcsParser_Expression(self, g);
	CcsParser_Expect(self, 35);
	Tab_MakeIteration(self->tab, *g);
	break;
    }
    case 39: {
	CcsParser_SemText(self, &pos);
	Node_t * p = Tab_NewNodeTSL(self->tab, node_sem, NULL, 0);
	p->pos = pos;
	*g = GraphP(NULL, p);
	break;
    }
    case 23: {
	CcsParser_Get(self);
	/* p.set is set in Tab_SetupAnys */
	Node_t * p = Tab_NewNodeTSL(self->tab, node_any, NULL, 0);
	*g = GraphP(NULL, p);
	break;
    }
    case 36: {
	CcsParser_Get(self);
	Node_t * p = Tab_NewNodeTSL(self->tab, node_sync, NULL, 0);
	*g = GraphP(NULL, p);
	break;
    }
    default: CcsParser_SynErr(self, 49); break;
    }
    if (*g == NULL) // invalid start of Factor
	*g = GraphP(NULL, Tab_NewNodeTSL(self->tab, node_eps, NULL, 0));
}

static void /* OK */
CcsParser_Attribs(CcsParser_t * self, Node_t * p) {
    if (self->la->kind == 24) {
	CcsParser_Get(self);
	Token_t * beg;
	Scanner_IncRef(self->scanner, beg = self->la);
	while (CcsParser_StartOf(self, 9)) {
	    if (CcsParser_StartOf(self, 10)) {
		CcsParser_Get(self);
	    } else {
		CcsParser_Get(self);
		CcsParser_SemErr(self, "bad string in attributes"); 
	    }
	}
	CcsParser_Expect(self, 25);
	p->pos = Scanner_GetPosition(self->scanner, beg, self->t);
	Scanner_DecRef(self->scanner, beg);
    } else if (self->la->kind == 26) {
	CcsParser_Get(self);
	Token_t * beg;
	Scanner_IncRef(self->scanner, beg = self->la);
	while (CcsParser_StartOf(self, 11)) {
	    if (CcsParser_StartOf(self, 12)) {
		CcsParser_Get(self);
	    } else {
		CcsParser_Get(self);
		CcsParser_SemErr(self, "bad string in attributes"); 
	    }
	}
	CcsParser_Expect(self, 27);
	p->pos = Scanner_GetPosition(self->scanner, beg, self->t);
	Scanner_DecRef(self->scanner, beg);
    } else CcsParser_SynErr(self, 50);
}

static void /* OK */
CcsParser_Condition(CcsParser_t * self) {
    while (CcsParser_StartOf(self, 20)) {
	if (self->la->kind == 30) {
	    CcsParser_Get(self);
	    CcsParser_Condition(self);
	} else {
	    CcsParser_Get(self);
	}
    }
    CcsParser_Expect(self, 31);
}

static void /* OK */
CcsParser_TokenTerm(CcsParser_t * self, Graph_t ** g) {
    Graph_t * g2; 
    CcsParser_TokenFactor(self, g);
    while (CcsParser_StartOf(self, 8)) {
	CcsParser_TokenFactor(self, &g2);
	Tab_MakeSequence(self->tab, *g, g2); 
    }
    if (self->la->kind == 38) {
	CcsParser_Get(self);
	CcsParser_Expect(self, 30);
	CcsParser_TokenExpr(self, &g2);
	Tab_SetContextTrans(self->tab, g2->l);
	self->dfa->hasCtxMoves = TRUE;
	Tab_MakeSequence(self->tab, *g, g2);
	CcsParser_Expect(self, 31);
    }
}

static void /* OK */
CcsParser_TokenFactor(CcsParser_t * self, Graph_t ** g) {
    char * name = NULL; int kind;
    *g = NULL;
    if (self->la->kind == 1 || self->la->kind == 3 || self->la->kind == 5) {
	CcsParser_Sym(self, &name, &kind);
	if (kind == CcsParser_id) {
	    CharClass_t * c = Tab_FindCharClassS(self->tab, name);
	    if (c == NULL) {
		CcsParser_SemErr(self, "undefined name");
		c = Tab_NewCharClass(self->tab, name, CharSet(NULL));
	    }
	    Node_t * p = Tab_NewNodeTSL(self->tab, node_clas, NULL, 0);
	    p->val = c->n;
	    *g = GraphP(NULL, p);
	    self->tokenString = strdup(self->noString);
	} else { /* CcsParser_str */
	    *g = Tab_StrToGraph(self->tab, name);
	    if (self->tokenString == NULL) self->tokenString = strdup(name);
	    else {
		free(self->tokenString);
		self->tokenString = strdup(self->noString);
	    }
	}
    } else if (self->la->kind == 30) {
	CcsParser_Get(self);
	CcsParser_TokenExpr(self, g);
	CcsParser_Expect(self, 31);
    } else if (self->la->kind == 32) {
	CcsParser_Get(self);
	CcsParser_TokenExpr(self, g);
	CcsParser_Expect(self, 33);
	Tab_MakeOption(self->tab, *g); 
    } else if (self->la->kind == 34) {
	CcsParser_Get(self);
	CcsParser_TokenExpr(self, g);
	CcsParser_Expect(self, 35);
	Tab_MakeIteration(self->tab, *g); 
    } else CcsParser_SynErr(self, 51);
    if (g == NULL) /* invalid start of TokenFactor */
	*g = GraphP(NULL, Tab_NewNodeTSL(self->tab, node_eps, NULL, 0));
}
/*---- enable ----*/
#endif /* 0 */
