/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
#include  "Scanner.h"

static int Char2State(int chr);
static int Identifier2KWKind(const char * key, size_t keylen, int defaultVal);
static void CcsScanner_Init(CcsScanner_t * self);
static CcsToken_t * CcsScanner_NextCcsToken(CcsScanner_t * self);
static void CcsScanner_GetCh(CcsScanner_t * self);

static const char * dummyval = "dummy";
CcsScanner_t *
CcsScanner(CcsScanner_t * self, CcsGlobals_t * globals, const char * filename)
{
    FILE * fp;
    self->globals = globals;
    if (!(fp = fopen(filename, "r"))) {
	fprintf(stderr, "Can not open '%s'.\n", filename);
	goto errquit0;
    }
    if (!(self->dummyToken = CcsToken(0, 0, 0, 0, dummyval, strlen(dummyval))))
	goto errquit1;
    if (CcsBuffer(&self->buffer, fp) == NULL) goto errquit2;
    CcsScanner_Init(self);
    return self;
 errquit2:
    fclose(fp);
 errquit1:
    CcsToken_Destruct(self->dummyToken);
 errquit0:
    return NULL;
}

static void
CcsScanner_Init(CcsScanner_t * self)
{
    self->eofSym = 0;
    /*---- declarations ----*/
    self->maxT = 41;
    self->noSym = 41;
    /*---- enable ----*/

    self->busyTokenList = NULL;
    self->curToken = &self->busyTokenList;
    self->peekToken = &self->busyTokenList;

    self->ch = 0; self->chBytes = 0;
    self->pos = 0; self->line = 1; self->col = 0;
    self->oldEols = 0; self->oldEolsEOL = 0;
    CcsScanner_GetCh(self);
}

void
CcsScanner_Destruct(CcsScanner_t * self)
{
    CcsToken_t * cur, * next;
    for (cur = self->busyTokenList; cur; cur = next) {
	next = cur->next;
	CcsToken_Destruct(cur);
    }
    CcsToken_Destruct(self->dummyToken);
    CcsBuffer_Destruct(&self->buffer);
}

CcsToken_t *
CcsScanner_GetDummy(CcsScanner_t * self)
{
    return self->dummyToken;
}

CcsToken_t *
CcsScanner_Scan(CcsScanner_t * self)
{
    CcsToken_t * cur;
    if (*self->curToken == NULL) {
	*self->curToken = CcsScanner_NextCcsToken(self);
	if (self->curToken == &self->busyTokenList)
	    CcsBuffer_SetBusy(&self->buffer, self->busyTokenList->pos);
    }
    cur = *self->curToken;
    self->peekToken = self->curToken = &cur->next;
    ++cur->refcnt;
    return cur;
}

CcsToken_t *
CcsScanner_Peek(CcsScanner_t * self)
{
    CcsToken_t * cur;
    do {
	if (*self->peekToken == NULL) {
	    *self->peekToken = CcsScanner_NextCcsToken(self);
	    if (self->peekToken == &self->busyTokenList)
		CcsBuffer_SetBusy(&self->buffer, self->busyTokenList->pos);
	}
	cur = *self->peekToken;
	self->peekToken = &cur->next;
    } while (cur->kind > self->maxT); /* Skip pragmas */
    ++cur->refcnt;
    return cur;
}

void
CcsScanner_ResetPeek(CcsScanner_t * self)
{
    *self->peekToken = *self->curToken;
}

void
CcsScanner_IncRef(CcsScanner_t * self, CcsToken_t * token)
{
    ++token->refcnt;
}

void
CcsScanner_DecRef(CcsScanner_t * self, CcsToken_t * token)
{
    CcsToken_t ** curToken;
    if (token == self->dummyToken) return;
    if (--token->refcnt > 0) return;
    CcsAssert(self->busyTokenList != NULL);
    for (curToken = &self->busyTokenList;
	 *curToken != token; curToken = &(*curToken)->next)
	CcsAssert(*curToken && curToken != self->curToken);
    /* Found, *curToken == token, detach and destroy it. */
    *curToken = (*curToken)->next;
    CcsToken_Destruct(token);
    /* Adjust CcsBuffer busy pointer */
    if (curToken == &self->busyTokenList) {
	if (self->busyTokenList) {
	    CcsBuffer_SetBusy(&self->buffer, self->busyTokenList->pos);
	} else {
	    CcsBuffer_ClearBusy(&self->buffer);
	}
    }
}

CcsPosition_t *
CcsScanner_GetPosition(CcsScanner_t * self,
		       CcsToken_t * begin, CcsToken_t * end)
{
    int len = end->pos - begin->pos;
    return CcsPosition(begin->pos, len, begin->col,
		    CcsBuffer_GetString(&self->buffer, begin->pos, len));
}

CcsPosition_t *
CcsScanner_GetPositionWithTail(CcsScanner_t * self,
			       CcsToken_t * begin, CcsToken_t * end)
{
    int len = (end->pos + strlen(end->val)) - begin->pos;
    return CcsPosition(begin->pos, len, begin->col,
		    CcsBuffer_GetString(&self->buffer, begin->pos, len));
}


/* All the following things are used by CcsScanner_NextCcsToken. */
typedef struct {
    int key, val;
}  Char2State_t;

static const Char2State_t c2sArr[] = {
    /*---- chars2states ----*/
    { EoF, -1 },
    { 34, 11 },
    { 36, 10 },
    { 39, 5 },
    { 40, 30 },
    { 41, 21 },
    { 43, 14 },
    { 45, 15 },
    { 46, 28 },
    { 48, 2 },
    { 49, 2 },
    { 50, 2 },
    { 51, 2 },
    { 52, 2 },
    { 53, 2 },
    { 54, 2 },
    { 55, 2 },
    { 56, 2 },
    { 57, 2 },
    { 60, 29 },
    { 61, 13 },
    { 62, 17 },
    { 65, 1 },
    { 66, 1 },
    { 67, 1 },
    { 68, 1 },
    { 69, 1 },
    { 70, 1 },
    { 71, 1 },
    { 72, 1 },
    { 73, 1 },
    { 74, 1 },
    { 75, 1 },
    { 76, 1 },
    { 77, 1 },
    { 78, 1 },
    { 79, 1 },
    { 80, 1 },
    { 81, 1 },
    { 82, 1 },
    { 83, 1 },
    { 84, 1 },
    { 85, 1 },
    { 86, 1 },
    { 87, 1 },
    { 88, 1 },
    { 89, 1 },
    { 90, 1 },
    { 91, 22 },
    { 93, 23 },
    { 95, 1 },
    { 97, 1 },
    { 98, 1 },
    { 99, 1 },
    { 100, 1 },
    { 101, 1 },
    { 102, 1 },
    { 103, 1 },
    { 104, 1 },
    { 105, 1 },
    { 106, 1 },
    { 107, 1 },
    { 108, 1 },
    { 109, 1 },
    { 110, 1 },
    { 111, 1 },
    { 112, 1 },
    { 113, 1 },
    { 114, 1 },
    { 115, 1 },
    { 116, 1 },
    { 117, 1 },
    { 118, 1 },
    { 119, 1 },
    { 120, 1 },
    { 121, 1 },
    { 122, 1 },
    { 123, 24 },
    { 124, 20 },
    { 125, 25 },
    /*---- enable ----*/
};
static const int c2sNum = sizeof(c2sArr) / sizeof(c2sArr[0]);

static int
c2sCmp(const void * key, const void * c2s)
{
    return *((const int *)key) - ((const Char2State_t *)c2s)->key;
}
static int
Char2State(int chr)
{
    Char2State_t * c2s;

    c2s = bsearch(&chr, c2sArr, c2sNum, sizeof(Char2State_t), c2sCmp);
    return c2s ? c2s->val : 0;
}

typedef struct {
    const char * key;
    int val;
}  Identifier2KWKind_t;

static const Identifier2KWKind_t i2kArr[] = {
    /*---- identifiers2keywordkinds ----*/
    { "ANY", 23 },
    { "CHARACTERS", 8 },
    { "COMMENTS", 11 },
    { "COMPILER", 6 },
    { "CONTEXT", 38 },
    { "END", 19 },
    { "FROM", 12 },
    { "IF", 37 },
    { "IGNORE", 15 },
    { "IGNORECASE", 7 },
    { "NESTED", 14 },
    { "PRAGMAS", 10 },
    { "PRODUCTIONS", 16 },
    { "SYNC", 36 },
    { "TO", 13 },
    { "TOKENS", 9 },
    { "WEAK", 29 },
    /*---- enable ----*/
};
static const int i2kNum = sizeof(i2kArr) / sizeof(i2kArr[0]);

static int
i2kCmp(const void * key, const void * i2k)
{
    return strcmp((const char *)key, ((const Identifier2KWKind_t *)i2k)->key);
}

static int
Identifier2KWKind(const char * key, size_t keylen, int defaultVal)
{
    char * keystr;
    Identifier2KWKind_t * i2k;

    if (!(keystr = CcsMalloc(keylen + 1))) exit(-1);
    memcpy(keystr, key, keylen);
    keystr[keylen] = 0;
    i2k = bsearch(keystr, i2kArr, i2kNum, sizeof(Identifier2KWKind_t), i2kCmp);
    CcsFree(keystr);
    return i2k ? i2k->val : defaultVal;
}

static void
CcsScanner_GetCh(CcsScanner_t * self)
{
    if (self->oldEols > 0) {
	self->ch = '\n'; --self->oldEols; self->oldEolsEOL= 1;
    } else {
	if (self->ch == '\n') {
	    if (self->oldEolsEOL) self->oldEolsEOL = 0;
	    else {
		++self->line; self->col = 0;
	    }
	} else {
	    self->col += self->chBytes;
	}
	self->ch = CcsBuffer_Read(&self->buffer, &self->chBytes);
	self->pos = CcsBuffer_GetPos(&self->buffer);
    }
}

typedef struct {
    int ch, chBytes;
    int pos, line, col;
}  SLock_t;
static void
CcsScanner_LockCh(CcsScanner_t * self, SLock_t * slock)
{
    slock->ch = self->ch;
    slock->chBytes = self->chBytes;
    slock->pos = self->pos;
    slock->line = self->line;
    slock->col = self->col;
    CcsBuffer_Lock(&self->buffer);
}
static void
CcsScanner_UnlockCh(CcsScanner_t * self, SLock_t * slock)
{
    CcsBuffer_Unlock(&self->buffer);
}
static void
CcsScanner_ResetCh(CcsScanner_t * self, SLock_t * slock)
{
    self->ch = slock->ch;
    self->chBytes = slock->chBytes;
    self->pos = slock->pos;
    self->line = slock->line;
    self->line = slock->line;
    CcsBuffer_LockReset(&self->buffer);
}

/*---- comments ----*/
static int
CcsScanner_Comment0(CcsScanner_t * self)
{
    SLock_t slock;
    int level = 1, line0 = self->line;

    CcsScanner_LockCh(self, &slock); CcsScanner_GetCh(self);
    if (self->ch == '/') {
	CcsScanner_UnlockCh(self, &slock);
	CcsScanner_GetCh(self);
	for (;;) {
	    if (self->ch == 10) {
		--level;
		if (level == 0) {
		    self->oldEols = self->line - line0;
		    CcsScanner_GetCh(self);
		    return 1;
		}
		CcsScanner_GetCh(self);
	    } else if (self->ch == EoF) {
		return 0;
	    } else {
		CcsScanner_GetCh(self);
	    }
	}
    } else {
	CcsScanner_ResetCh(self, &slock);
    }
    return 0;
}

static int
CcsScanner_Comment1(CcsScanner_t * self)
{
    SLock_t slock;
    int level = 1, line0 = self->line;

    CcsScanner_LockCh(self, &slock); CcsScanner_GetCh(self);
    if (self->ch == '*') {
	CcsScanner_UnlockCh(self, &slock);
	CcsScanner_GetCh(self);
	for (;;) {
	    if (self->ch == '*') {
		CcsScanner_GetCh(self);
		if (self->ch == '/') {
		    --level;
		    if (level == 0) {
			self->oldEols = self->line - line0;
			CcsScanner_GetCh(self);
			return 1;
		    }
		    CcsScanner_GetCh(self);
		}
	    } else if (self->ch == '/') {
		CcsScanner_GetCh(self);
		if (self->ch == '*') {
		    ++level; CcsScanner_GetCh(self);
		}
	    } else if (self->ch == EoF) {
		return 0;
	    } else {
		CcsScanner_GetCh(self);
	    }
	}
    } else {
	CcsScanner_ResetCh(self, &slock);
    }
    return 0;
}
/*---- enable ----*/

CcsToken_t *
CcsScanner_NextCcsToken(CcsScanner_t * self)
{
    int pos, line, col, state, kind; CcsToken_t * t;
    for (;;) {
	while (self->ch == ' ' ||
	       /*---- scan1 ----*/
	       (self->ch >= 9 && self->ch <= 10) || self->ch == 13
	       /*---- enable ----*/
	       ) CcsScanner_GetCh(self);
	/*---- scan2 ----*/
	if (self->ch == '/' && CcsScanner_Comment0(self)) continue;
	if (self->ch == '/' && CcsScanner_Comment1(self)) continue;
	/*---- enable ----*/
	break;
    }
    pos = self->pos; line = self->line; col = self->col;
    CcsBuffer_Lock(&self->buffer);
    state = Char2State(self->ch);
    CcsScanner_GetCh(self);
    switch (state) {
    case -1: kind = self->eofSym; break;
    case 0: kind = self->noSym; break;
	/*---- scan3 ----*/
    case 1: case_1:
	if ((self->ch >= '0' && self->ch <= '9') ||
	    (self->ch >= 'A' && self->ch <= 'Z') ||
	    self->ch == '_' ||
	    (self->ch >= 'a' && self->ch <= 'z')) {
	    CcsScanner_GetCh(self); goto case_1;
	} else {
	    kind = 1;
	    kind = Identifier2KWKind(CcsBuffer_GetString(&self->buffer, pos, self->pos - pos),
				     self->pos - pos, kind);
	    break;
	}
    case 2: case_2:
	if ((self->ch >= '0' && self->ch <= '9')) {
	    CcsScanner_GetCh(self); goto case_2;
	} else {
	    kind = 2;
	    break;
	}
    case 3: case_3: {kind = 3; break;}
    case 4: case_4: {kind = 4; break;}
    case 5:
	if (self->ch <= 9 ||
	    (self->ch >= 11 && self->ch <= 12) ||
	    (self->ch >= 14 && self->ch <= '&') ||
	    (self->ch >= '(' && self->ch <= '[') ||
	    (self->ch >= ']' && self->ch <= 65535)) {
	    CcsScanner_GetCh(self); goto case_6;
	} else if (self->ch == 92) {
	    CcsScanner_GetCh(self); goto case_7;
	} else {
	    kind = self->noSym; break;
	}
    case 6: case_6:
	if (self->ch == 39) {
	    CcsScanner_GetCh(self); goto case_9;
	} else {
	    kind = self->noSym; break;
	}
    case 7: case_7:
	if (self->ch >= ' ' && self->ch <= '~') {
	    CcsScanner_GetCh(self); goto case_8;
	} else {
	    kind = self->noSym; break;
	}
    case 8: case_8:
	if ((self->ch >= '0' && self->ch <= '9') ||
	    (self->ch >= 'a' && self->ch <= 'f')) {
	    CcsScanner_GetCh(self); goto case_8;
	} else if (self->ch == 39) {
	    CcsScanner_GetCh(self); goto case_9;
	} else {
	    kind = self->noSym; break;
	}
    case 9: case_9: {kind = 5; break;}
    case 10: case_10:
	if ((self->ch >= '0' && self->ch <= '9') ||
	    (self->ch >= 'A' && self->ch <= 'Z') ||
	    self->ch == '_' ||
	    (self->ch >= 'a' && self->ch <= 'z')) {
	    CcsScanner_GetCh(self); goto case_10;
	} else {
	    kind = 42; break;
	}
    case 11: case_11:
	if (self->ch <= 9 ||
	    (self->ch >= 11 && self->ch <= 12) ||
	    (self->ch >= 14 && self->ch <= '!') ||
	    (self->ch >= '#' && self->ch <= '[') ||
	    (self->ch >= ']' && self->ch <= 65535)) {
	    CcsScanner_GetCh(self); goto case_11;
	} else if (self->ch == 10 || self->ch == 13) {
	    CcsScanner_GetCh(self); goto case_4;
	} else if (self->ch == '"') {
	    CcsScanner_GetCh(self); goto case_3;
	} else if (self->ch == 92) {
	    CcsScanner_GetCh(self); goto case_12;
	} else {
	    kind = self->noSym; break;
	}
    case 12: case_12:
	if (self->ch >= ' ' && self->ch <= '~') {
	    CcsScanner_GetCh(self); goto case_11;
	} else {
	    kind = self->noSym; break;
	}
    case 13: {kind = 17; break;}
    case 14: {kind = 20; break;}
    case 15: {kind = 21; break;}
    case 16: case_16: {kind = 22; break;}
    case 17: {kind = 25; break;}
    case 18: case_18: {kind = 26; break;}
    case 19: case_19: {kind = 27; break;}
    case 20: {kind = 28; break;}
    case 21: {kind = 31; break;}
    case 22: {kind = 32; break;}
    case 23: {kind = 33; break;}
    case 24: {kind = 34; break;}
    case 25: {kind = 35; break;}
    case 26: case_26: {kind = 39; break;}
    case 27: case_27: {kind = 40; break;}
    case 28:
	if (self->ch == '.') {CcsScanner_GetCh(self); goto case_16;}
	else if (self->ch == '>') {CcsScanner_GetCh(self); goto case_19;}
	else if (self->ch == ')') {CcsScanner_GetCh(self); goto case_27;}
	else {kind = 18; break;}
    case 29:
	if (self->ch == '.') {CcsScanner_GetCh(self); goto case_18;}
	else {kind = 24; break;}
    case 30:
	if (self->ch == '.') {CcsScanner_GetCh(self); goto case_26;}
	else {kind = 30; break;}
	/*---- enable ----*/
    }
    t = CcsToken(kind, pos, col, line,
		 CcsBuffer_GetString(&self->buffer, pos, self->pos - pos),
		 self->pos - pos);
    CcsBuffer_Unlock(&self->buffer);
    return t;
}

