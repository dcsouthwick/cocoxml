-*- coding: utf-8 -*-

根据Coco/R、CocoXml的任务，我们大概可以把他们要做的事情分为三类。
一、生成、优化、检验词法(或 XmlLangDefinition)、语法状态机。这一部分纯粹是维护数据结构，根据数据本身的特征完成需要的计算操作。与输入、输出的形式无关。它们的输入是产生式规则、输出是状态机数据结构；
二、根据状态机数据结构，生成不同形式的输出。可以想象的是，相同的状态机可以为不同的编程语言生成源代码，也可以生成测试信息输出。这些输出的格式跟数据的运算是完全无关的；
三、作为状态机输出的一个特例，即输出针对某种编程语言的源代码。这些生成的源代码与前面两个部分是完全隔离的，甚至可能是属于不同编程语言的。所谓的完全隔离，就是说不能使用前两部分提供的任何代码，包括数据结构、算法，等等。

Coco/R的代码，包含了上述三个部分，但是没有加以明确的区分。为了使结构清晰化，我们有必要对其结构进行调整。只有清晰化的结构，我们才能轻松地实现一个Coco为所有目标语言生成源代码，或者是为Coco增加新的功能(即强化词法、语法状态机的功能)

这里我们把对状态机的一组相关输出，称为“输出方案”。输出源代码的输出方案，称为“源代码输出方案”。

根据上面对事情的分类，可以确定Coco应该含有：
* 数据结构和算法：
  * 词法分析类：用于维护词法分析状态机；
    * 一些内部数据结构，例如 CharSet_t；
  * 语法分析类：用于维护语法分析状态机；
    * 一些内部数据结构，例如 Node_t；
  * Xml 语言定义类：用于存储 XML 语言相关的数据；
* 子数据结构，用于表征基本对象，简化交互。例如 Symbol_t、Token_t；这类对象往往只是数据的集合，本身并没有什么复杂操作。
* 各种输出方案，拥有同一个基类：OutputScheme_t。各种源代码输出方案，拥有同一个基类：SourceOutputScheme_t。SourceOutputScheme_t 是 OutputScheme_t 的派生类。
* 在 OutputScheme_t 中，实现所有输出方案共有的特性。在 SourceOutputScheme_t 中，实现所有源码输出方案共有的特性。
* 支持类，提供一些大家都需要的特性，例如：报错、基本数据结构、UTF-8 字符串维护等等。

上述类和结构，都不包括生成的源代码。要知道生成的源代码甚至是完全不同的编程语言，所以代码完全不可通用。在编码过程中尤其要注意区分那些是生产者，那些是产品。

生成的源代码要做的事，包括：获取输入、把输入分解为 Token_t、根据 Token_t 和产生式，执行对应的语义操作。需要注意的是这里所有的数据结构，均与前面所述的数据结构无关。在 Coco/R 目前的代码里面，有些结构是共用的，没有加以明确的区分。现在必须明确区分。有一部分支持类也是共享的，这也导致一定的混乱出现。

为了便于区分，所有Coco本体的结构和函数，均以Cc为前缀。而生成的源代码，均以方案名或者方案名缩写为前缀。用于生成Coco自身的输出方案，我们以Ccs为前缀。

在源代码组织上，根目录下保存主程序入口 Coco.c 和 CocoXml.c。

core 子目录含有所有数据结构算法类及子数据结构。一个 EBNF.c 实现状态机通用算法、一个.c含有词法状态机、一个.c含有语法状态机、一个.c含有Xml 语言定义、一个.c含有各种支持类及工具函数、一个.c含有交互子数据结构。

schemes 子目录含有各种输出方案，不同的输出方案在 schemes 的子目录中。schemes 中一个 .c 定义 OutputScheme 类，一个 .c 定义 SourceOutputScheme 类。

在输出方案子目录中，输出生产者和产品模板被保存在一起。这里要特别注意对这两者加以区分。

Coco 的算法核心是 EBNF 产生式，EBNF 在 Coco 内的数据结构表示由 Graph_t 和 Node_t 组成。由于词法分析和语法分析都使用了 EBNF 产生式，因此词法分析和语法分析都利用了 Graph_t 和 Node_t。不同类型的 Node_t 分别在词法分析和语法分析中使用。

要整理 Coco 的源代码，首先必须对现有的 Coco 类及其成员进行分类。首先必须区分是属于本体还是属于被生成的源代码。而后对于本体部分，再按照本体需完成的事务类别进行区分。

* Token_t(Scanner.frame)：是词法解析的输出，同时又是语法分析的输入。这是产品类，应名为 CcsToken_t。
* Buffer_t(Scanner.frame)：用于缓冲输入文件的内容，主要是保存 Token_t 的 val 字段。确保当前仍然存在的 Token_t，其对应的字符串值仍然被保留在Buffer_t之中。以便于实现从输入文件中复制出一段文本的功能。这是产品类，应名为 CcsBuffer_t。由于 CcsToken_t 的值总是在 CcsBuffer_t 之中，因此CcsToken_t只需要记录位置指针，而不必复制字符串。在目前的代码中，为了使用的方便，对CcsToken_t对应的文本进行了复制。
* Scanner_t(Scanner.frame)：词法分析状态机。把输入的字符分解为 Token_t。这是产品类，应名为 CcsScanner_t。
* Parser_t(Parser.frame)：语法分析状态机。以 Token_t 为输入，根据语法状态机决定执行那些语义动作。应名为CcsParser_t。
* Errors_t(Parser.frame)：错误报告对象，所有产品类的实例均向它报告错误、警告。因此它是产品类之中的支持类，应名为CcsParser_t。

* Action_t：词法分析有限自动机的动作。属于Coco本体，是词法分析的内部子结构。应名为 CsAction_t。
* ArrayList_t：数据结构支持类，实现可变长度的数组。属于 Coco 本体。由于是本体类，应名为 CsArrayList_t。主要由 Tab_t，即语法分析器使用。
* BitArray_t：数据结构支持类。是本体类，词法分析状态机的生成类 DFA_t 和语法分析状态机的生成类 Tab_t 都用它进行状态/结点分析。应名为CsBitArray_t。
* CharClass_t：字符类，即命名且编号了的字符集。是本体类，属于词法分析的子结构。应名为 CsCharClass_t。不知为什么 CharClass_t 是在 Tab_t 之中定义且操作的。似乎完全没有这样的必要，而且还造成混乱。Tab_t 中唯一用到CharClass的地方是PrintNodes，而这些应该是放在输出方案中实现的。
* CharSet_t：字符集。是本体类，属于词法分析的子结构。应名为 CsCharSet_t。
* Comment_t：由于Coco对注释进行了特殊处理，因此用一个特殊的结构加以保存。是本体类，属于词法自动机的内部子结构，应名为 CsComment_t。
* Graph_t：语法状态机用于表示两个结点之间的连接关系。是本体类，是语法自动机的内部子结构。应名为 CsGraph_t。
* HashTable_t：数据结构支持类，实现杂凑表。是本体类中的支持类，应名为 CsHashTable_t。在 Coco 中，HashTable_t 只有一个用途，就是为词法分析器记录字面量和符号之间的对应关系。它的 key 是字符串，值是 Symbol_t。由于它只有这一个用途，所以也可以看作是词法自动机的内部子结构。但从它的含义上讲是没有这层关系的。
* Melted_t：被分解的状态。是本体类，属于词法分析的子结构。应名为 CsMelted_t。
* Node_t：EBNF 结点，是本体类中的语法状态机的子结构，应名为 CsNode_t。在 Coco 现有代码中，有些类型的结点是属于词法分析的，有些是属于语法分析的，还有些是用于生成源代码输出的。有必要逐个区分，以便正确分解。
  * node_t 语法
  * node_pr 语法
  * node_nt 语法
  * node_clas 词法
  * node_chr 词法
  * node_wt 语法
  * node_any 语法
  * node_eps 空，基本 EBNF 结点
  * node_sync 语法
  * node_sem 语义动作，源码生成
  * node_alt 替换，基本 EBNF 结点
  * node_opt 可选，基本 EBNF 结点
  * node_rslv 语法
* ParserGen_t：用于输出当前编程语言的Parser_t源代码。是本体类中源码输出方案的一部分。
* Position_t：是 CcsScanner_t 输出的一种，用于输出输入文件的指定片段。由于 Position_t 的值(字符串)的时候，CcsBuffer_t 可能已经丢弃相关数据，因此必须复制 Position_t 的相关内容。它是产品类，应名为 CcsPosition_t。
* Set：定义了 BitArray_t 的一些操作函数，应该合并到BitArray_t之中去。
* SortedList_t：数据结构支持类，实现自动排序列表。只在输出交叉引用表的时候使用。如果能够比较容易地计算出成员数量，在C语言中应该能够以简单的 qsort 调用代替,，因此不必单独命名了。它属于 Coco 本体，是调试信息输出方案的一部分。
* State_t：状态，是本体中词法分析自动机的结点。是本体类，属于词法分析的子结构。应名为 CsState_t。
* Symbol_t：符号。是本体中词法分析的输出，语法分析的输入。对应于产品源代码之中的 Token_t。由于是本体交互子结构，因此应名为 CsSymbol_t。Symbol_t 有四种类型：
  * fixedToken：
  * classToken：字符类符号
  * litToken： 字面量符号
  * classLitToken：
* Target_t：一个动作能够到达的状态集合。是本体类，属于词法分析的子结构。应名为 CsTarget_t。

要在 DFA_t 和 Tab_t 之间区分那些是属于词法分析的部分，那些是属与语法分析的部分，分析 Coco.atg 中的终结符和非终结符的用途是前提：
* Coco
* SetDecl：定义字符集。属于词法分析，操作 CharSet_t、CharClass_t。
* Set：定义字符集。属于词法分析，操作 CharSet_t。
* SimSet：定义字符集。属于词法分析，操作 CharSet_t、CharClass_t。
* Char：定义单个字符。属于词法分析，操作字符(int)。
* TokenDecl：定义符号，即词法分析的结果，语法分析的输入。操作 Symbol_t、Graph_t、DFA_t。从这个角度看 Graph_t 应该是属于词法分析的(那么 Node_t 也应该属于词法分析)。Symbol_t 应该是属于词法、语法中介对象的(符号表？)。
* AttrDecl
* Expression
* Term
* Factor
* Resolver
* Condition
* TokenExpr
* TokenTerm
* TokenFactor
* Sym
* Attribs
* SemText
* UsingDecl：填充 ParserGen_t 中的 usingPos，用于把 Coco.atg 中的 using 命令，复制到产品源码中。它只于具体的输出方案有关，应该放到输出方案里去。

符号表应该是一个终结符、非终结符、pragmas 的列表。词法分析、语法分析都不应该内置。
Graph_t 和 Node_t 难道在语法分析和词法分析中用作不同的用途。Graph_t 和 Node_t 应该是对 EBNF 的实现，这一实现在词法分析中用到，在语法分析中也用到。

* DFA_t：本体类中的词法分析状态机的生成类。但是它还糅合了输出词法分析源代码和输出部分调试信息的工作，这部分代码要全部清理出去，让它只完成词法分析状态机的生成和分析这一件事。应名为 CsDFA_t。
  * int maxStates：自动机状态
  * int lastStates
  * State_t firstState
  * State_t lastState
  * int lastSimState：最后一个 Melted 状态。
  * FILE fram：输出方案的一部分，从DFA_t删除，放到输出方案去
  * FILE gen：同上
  * Symbol_t curSy：DFA_t、ParserGen_t、Tab_t 都含有该成员，各有其内部用途。
  * Node_t curGraph：从出现的情况看没必要作为实例成员存在。
  * Bool_t ignoreCase：OK
  * Bool_t dirtyDFA：OK
  * Bool_t hasCtxMoves：只跟源代码生成有关，应从DFA_t中删除，放到输出方案中去。
  * Parser_t parser：主要用于报告错误。
  * Tab_t tab：按道理说没有必要存在的。清理之后应该能够删掉。
  * Errors_t errors：错误处理对象，应该从 DFA_t 中删除放到辅助类实例集合中去。
  * FILE trace：应从 DFA_t 中删除放到辅助类实例集合中去。
  * Melted_t firstMelted：所有 Melted 相关信息的链表。
  * Comment_t firstComment： 所有注释相关信息的链表
  * ConvertToStates、FindTrans、NumberNodes、Step，最终的外界接口是 ConvertToStates。该功能只在 TokenDecl_t 之中使用，也就是说只于词法分析的标记表达式有关。但奇怪的是很多计算都出现在 Tab_t 之中。

* Tab_t：本体类中的语法分析状态机的生成类。但是它还包含了输出部分调试信息的工作，这部分代码要全部清理出去，让它只完成语法分析状态机的生成和分析这一件事。应名为 CsTab_t。
  * Position_t semDeclPos：仅仅是用于记录 COMPILER 标记之前的文本，用于帮助引入头文件。这是本体中输出方案的一部份，应放到具体输出方案中去。
  * CharSet_t ignored：被忽略的字符集，与词法分析有关，与语法分析无关，应从 Tab_t 中删除并转移到 DFA_t 中去。
  * Bool_t ddt[10]：决定输出那些调试信息，与语法分析无关，应从 Tab_t 中删除。
  * Symbol_t gramSy：起始符号，即最后要归约的目标。
  * Symbol_t eofSy：文件结束符号。
  * Symbol_t noSym：无符号，空。
  * BitArray_t allSyncSets：所有同步集合的并集。
  * HashTable_t literals：字符串到符号(终结符)的转换关系。在词法分析器中用于表示字面量 CcsToken_t/CsSymbol_t 的转换关系。应从 Tab_t 中删除并转移到 DFA_t 中去。
  * srcName：输入文件名名称。应放到支持对象中，与语法分析无关，应从Tab_t中删除。
  * srcDir：输入文件所在的目录。同上。
  * nsName：Namespace 名称。只在输出源码的时候有用，应放到输出方案中去处理，并从  Tab_t 中删除。
  * frameDir：frame文件所在的目录。同 srcDir。
  * outDir：源码输出目录，同上。
  * BitArray_t visited
  * Symbol_t curSy
  * Parser_t parser：主要用于获得报错方法，即取得对 errors 的访问权。于语法分析无关，应从Tab_t中删除。
  * FILE trace：调试文件输出对象，与语法分析无关。应从 Tab_t 中删除。
  * Errors_t errors：错误处理对象，应该放到支持对象集合中去。
  * ArrayList_t terminals：终结符号列表。
  * ArrayList_t pragmas：pragmas 符号列表。
  * ArrayList_t nonterminals：非终结符列表。
  * ArrayList_t nodes
  * Node_t dummyNode
  * ArrayList_t classes：有名字符集列表，应该放到 DFA_t 之中。
  * int dummyName

编码工作，从 EBNF 的实现开始吧。
