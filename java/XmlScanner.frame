/* -*- java -*- */
/*----------------------------------------------------------------------
Compiler Generator CocoXml/R,
Copyright (c) 2008 Charles Wang <charlesw123456@gmail.com>

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of CocoXml/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by CocoXml/R (other than 
CocoXml/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/
/*---- Begin ----*/
import org.xml.sax.helpers.DefaultHandler;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.SAXParser;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.Queue;
import java.util.Stack;

/*---- Namespace ----*/

class Token {
/*---- Options ----*/
    public int kind;
    public int col;
    public int line;
    public String val;
}

public class TagInfo {
    public int startToken;
    public int endToken;
}

public class XmlLangDefinition {
    public boolean[]                  useVector;
    public Hashtable<String, TagInfo> Tags;
    public Hashtable<String, int>     Attrs;

    public XmlLangDefinition() {
	useVector = new boolean[Token.numOptions];
	Tags = new Hashtable<String, TagInfo>();
	Attrs = new Hashtable<String, int>();
    }

    public void AddTag(String Name, int StartToken, int EndToken) {
	TagInfo tinfo = new TagInfo();
	tinfo.startToken = StartToken;
	tinfo.endToken = EndToken;
	Tags.put(Name, tinfo);
    }

    public void AddAttr(String Name, int AttrToken) {
	Attrs.put(Name, AttrToken);
    }
}

enum SAXRecordType {
    StartElement, EndElement, Attribute,
	Text, Whitespace, ProcessingInstruction
}

class SAXRecord {
    SAXRecordType  typ;
    String         namespaceURI;
    String         localName;
    String         target;
    String         value;
}

class XSHandler extends DefaultHandler {
    Queue<SAXRecord>  queue;

    public DefaultHandler() {
	queue = new Queue<SAXRecord>;
    }

    public void startElement(String namespaceURI, String localName,
			     String QName, Attributes attrs)
	throws SAXException
    {
	String nsURI;
	SAXRecord record = new SAXRecord();
	record.typ = SAXRecordType.StartElement;
	record.namespaceURI = namespaceURI;
	record.localName = localName;
	queue.add(record);
	for (int idx = 0; idx < attrs.getLength(); ++idx) {
	    record = new SAXRecord();
	    record.typ = SAXRecordType.Attribute;
	    nsURI = attrs.getURI(idx);
	    record.namespaceURI = (nsURI == '') ? namespaceURI : nsURI;
	    record.localName = attrs.getLocalName(idx);
	    record.value = attrs.getValue(idx);
	    queue.add(record);
	}
    }

    public void endElement(String namespaceURI, String localName, String QName)
	throws SAXException
    {
	SAXRecord record = new SAXRecord();
	record.typ = SAXRecordType.EndElement;
	record.namespaceURI = namespaceURI;
	record.localName = localName;
	queue.add(record);
    }

    public void characters(char[] ch, int start, int length) {
	SAXRecord record = new SAXRecord();
	record.value = new String(ch, start, length);
	record.typ = record.value.trim() == '' ?
	    SAXRecordType.Text : SAXRecordType.Whitespace;
	queue.add(record);
    }

    public void ignorableWhitespace(char[] ch, int start, int length) {
	SAXRecord record = new SAXRecord();
	record.typ = SAXRecordType.Whitespace;
	record.value = new String(ch, start, length);
	queue.add(record);
    }

    public void processingInstruction(String target, String data) {
	SAXRecord record = new SAXRecord();
	record.typ = SAXRecordType.ProcessingInstruction;
	record.target = target;
	record.value = data;
	queue.add(record);
    }

    public SAXRecord get() {
	return queue.poll();
    }
}

class tagStackEle {
    public boolean unknownNamespace;
    public boolean unknownTag;
    public XmlLangDefinition xldef;
}

public class XmlScanner {
    enum XSStatus { XSCommon, XSFirstAttr, XSNextAttr };

    final char EOL = '\n';
    final int eofSym = 0;
/*---- Declarations ----*/

    Stream stream;
    XmlTextReader                         xmlreader;
    Hashtable<String, XmlLangDefinition>  XmlLangMap;
    Stack<tagStackEle>                    tagStack;
    XSStatus                              status;
    boolean                               inEmptyElement;
    String                                emptyNSURI;
    String                                emptyLName;
    List<Token>                           tokens;
    int                                   peek;

    public XmlScanner (String fileName) {
	try {
	    stream = new FileStream(fileName, FileMode.Open,
				    FileAccess.Read, FileShare.Read);
	    Init();
	} catch (IOException) {
	    throw new FatalError("Can not open file " + fileName);
	}
    }

    public XmlScanner (Stream s) {
	stream = s;
	Init();
    }

    void Init() {
	XmlLangDefinition curXLDef;

	xmlreader = new XmlTextReader(stream);
	XmlLangMap = new Hashtable<String, XmlLangDefinition>();
	tagStack = new Stack<tagStackEle>();
	status = XSStatus.XSCommon;
	inEmptyElement = false;
	tokens = new List<Token>();
	peek = 0;

/*---- Initialization ----*/

	tagStackEle  tsEle = new tagStackEle();
	tsEle.unknownNamespace = false;
	tsEle.unknownTag = false;
	tsEle.xldef = XmlLangMap[""];
	tagStack.Push(tsEle);
    }

    int StartElement2Kind(String NamespaceURI, String TagName) {
	tagStackEle curEle = tagStack.Peek();
	tagStackEle newEle = new tagStackEle();

	if (!XmlLangMap.ContainsKey(NamespaceURI)) {
	    newEle.unknownNamespace = true;
	    newEle.unknownTag = false;
	    newEle.xldef = curEle.xldef;
	    tagStack.Push(newEle);
	    return useKindVector[(int)Token.Options.UNKNOWN_NAMESPACE];
	}
	newEle.unknownNamespace = false;
	newEle.xldef = XmlLangMap[NamespaceURI];
	if (!newEle.xldef.Tags.ContainsKey(TagName)) {
	    newEle.unknownTag = true;
	    tagStack.Push(newEle);
	    return useKindVector[(int)Token.Options.UNKNOWN_TAG];
	}
	newEle.unknownTag = false;
	tagStack.Push(newEle);
	return newEle.xldef.Tags[TagName].startToken;
    }

    int EndElement2Kind(String NamespaceURI, String TagName) {
	tagStackEle curEle = tagStack.Pop();

	if (curEle.unknownNamespace) {
	    return useKindVector[(int)Token.Options.END_UNKNOWN_NAMESPACE];
	}
	if (curEle.unknownTag)
	    return useKindVector[(int)Token.Options.END_UNKNOWN_TAG];
	return curEle.xldef.Tags[TagName].endToken;
    }

    int Attribute2Kind(String NamespaceURI, String AttrName) {
	XmlLangDefinition xldef;
	tagStackEle curEle = tagStack.Peek();

	// assert(!curEle.unknownNamespace and !curEle.unknownTag);
	if (NamespaceURI == "") xldef = curEle.xldef;
	else if (!XmlLangMap.ContainsKey(NamespaceURI))
	    return useKindVector[(int)Token.Options.UNKNOWN_ATTR_NAMESPACE];
	else xldef = XmlLangMap[NamespaceURI];
	if (!xldef.Attrs.ContainsKey(AttrName))
	    return useKindVector[(int)Token.Options.UNKNOWN_ATTR];
	return xldef.Attrs[AttrName];
    }

    int Others2Kind(XmlNodeType ntype) {
	Token.Options opt;
	tagStackEle curEle = tagStack.Peek();

	switch (ntype) {
	case XmlNodeType.Text:
	    if (curEle.unknownNamespace) opt = Token.Options.UNS_TEXT;
	    else if (curEle.unknownTag) opt = Token.Options.UT_TEXT;
	    else opt = Token.Options.TEXT;
	    break;
	case XmlNodeType.CDATA:
	    if (curEle.unknownNamespace) opt = Token.Options.UNS_CDATA;
	    else if (curEle.unknownTag) opt = Token.Options.UT_CDATA;
	    else opt = Token.Options.CDATA;
	    break;
	case XmlNodeType.Whitespace:
	    if (curEle.unknownNamespace) opt = Token.Options.UNS_WHITESPACE;
	    else if (curEle.unknownTag) opt = Token.Options.UT_WHITESPACE;
	    else opt = Token.Options.WHITESPACE;
	    break;
	case XmlNodeType.Comment:
	    if (curEle.unknownNamespace) opt = Token.Options.UNS_COMMENT;
	    else if (curEle.unknownTag) opt = Token.Options.UT_COMMENT;
	    else opt = Token.Options.COMMENT;
	    break;
	case XmlNodeType.ProcessingInstruction:
	    if (curEle.unknownNamespace) opt = Token.Options.UNS_PROCESSING_INSTRUCTION;
	    else if (curEle.unknownTag) opt = Token.Options.UT_PROCESSING_INSTRUCTION;
	    else opt = Token.Options.PROCESSING_INSTRUCTION;
	    break;
	default:
	    return -1;
	}
	return curEle.xldef.useVector[(int)opt] ? useKindVector[(int)opt] : -1;
    }

    void AppendToken() {
	int kind = -1;
	Token new_token = null;
	while (kind < 0) {
	    switch (status) {
	    case XSStatus.XSCommon:
		if (inEmptyElement) {
		    kind = EndElement2Kind(emptyNSURI, emptyLName);
		    inEmptyElement = false;
		    break;
		} else if (!xmlreader.Read()) { kind = eofSym; break; }
		switch (xmlreader.NodeType) {
		case XmlNodeType.Element:
		    kind = StartElement2Kind(xmlreader.NamespaceURI,
					     xmlreader.LocalName);
		    if (xmlreader.IsEmptyElement) {
			emptyNSURI = xmlreader.NamespaceURI;
			emptyLName = xmlreader.LocalName;
			inEmptyElement = true;
		    }
		    if (kind >= 0) status = XSStatus.XSFirstAttr;
		    break;
		case XmlNodeType.EndElement:
		    kind = EndElement2Kind(xmlreader.NamespaceURI,
					   xmlreader.Name);
		    break;
		default:
		    kind = Others2Kind(xmlreader.NodeType);
		    break;
		}
		break;
	    case XSStatus.XSFirstAttr:
		if (!xmlreader.MoveToFirstAttribute()) {
		    status = XSStatus.XSCommon;
		    kind = -1;
		} else {
		    status = XSStatus.XSNextAttr;
		    kind = Attribute2Kind(xmlreader.NamespaceURI,
					  xmlreader.LocalName);
		}
		break;
	    case XSStatus.XSNextAttr:
		if (!xmlreader.MoveToNextAttribute()) {
		    status = XSStatus.XSCommon;
		    kind = -1;
		} else {
		    kind = Attribute2Kind(xmlreader.NamespaceURI,
					  xmlreader.LocalName);
		}
		break;
	    }
	}
	new_token = new Token();
	new_token.kind = kind;
	new_token.line = xmlreader.LineNumber;
	new_token.col = xmlreader.LinePosition;
	new_token.val = xmlreader.Value;
	tokens.Add(new_token);
    }

    public Token Scan () {
	Token token;
	if (tokens.Count == 0) AppendToken();
	token = tokens[0];
	tokens.RemoveAt(0);
	return token;
    }

    public Token Peek () {
	if (peek == tokens.Count) AppendToken();
	return tokens[peek ++];
    }

    public void ResetPeek () { peek = 0; }
}

/*---- $$$ ----*/
