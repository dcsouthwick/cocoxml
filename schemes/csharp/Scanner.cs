/*---- license ----*/
/*-------------------------------------------------------------------------
 Coco.ATG -- Attributed Grammar
 Compiler Generator Coco/R,
 Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
 extended by M. Loeberbauer & A. Woess, Univ. of Linz
 with improvements by Pat Terry, Rhodes University.
 ported to C by Charles Wang <charlesw123456@gmail.com>

 This program is free software; you can redistribute it and/or modify it 
 under the terms of the GNU General Public License as published by the 
 Free Software Foundation; either version 2, or (at your option) any 
 later version.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 for more details.

 You should have received a copy of the GNU General Public License along 
 with this program; if not, write to the Free Software Foundation, Inc., 
 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

 As an exception, it is allowed to write an extension of Coco/R that is
 used as a plugin in non-free software.

 If not otherwise stated, any source code generated by Coco/R (other than 
 Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*---- enable ----*/
using System;
using System.IO;
using System.Diagnostics;

public class CcsScanner_t {
    CcsErrorPool_t errpool;
    bool           caseSensitive;
    int            eofSym;
    int            noSym;
    int            maxT;
    CcsToken_t     dummyToken;
    CcsToken_t     busyTokenList;
    CcsToken_t     curToken;
    CcsToken_t     peekToken;

    int            ch;
    int            chBytes;
    long           pos;
    int            line;
    int            col;
    int            oldEols;
    bool           oldEolsEOL;
    CcsBuffer_t    buffer;

    public CcsScanner_t(CcsErrorPool_t errpool, string filename)
    {
	Stream stream;
	this.errpool = errpool;
	stream = new FileStream(filename, FileMode.Open);
	dummyToken = new CcsToken_t(0, 0, 0, 0, "dummy");
	buffer = new CcsBuffer_t(stream);
	Init();
    }

    private void Init()
    {
	/*---- declarations ----*/
	caseSensitive = true;
	eofSym = 0;
	maxT = 47;
	noSym = 47;
	/*---- enable ----*/

	busyTokenList = null;
	curToken = null;
	peekToken = null;

	ch = 0; chBytes = 0;
	pos = 0; line = 1; col = 0;
	oldEols = 0; oldEolsEOL = false;
	GetCh();
    }

    ~CcsScanner_t()
    {
    }    

    public CcsToken_t GetDummy()
    {
	return dummyToken;
    }

    public CcsToken_t Scan()
    {
	CcsToken_t cur;
	if (curToken == null) {
	    curToken = NextToken();
	    if (curToken == busyTokenList)
		buffer.SetBusy(busyTokenList.pos);
	}
	cur = curToken;
	peekToken = curToken = cur.next;
	++cur.refcnt;
	return cur;
    }

    public CcsToken_t Peek()
    {
	CcsToken_t cur;
	do {
	    if (peekToken == null) {
		peekToken = NextToken();
		if (peekToken == busyTokenList)
		    buffer.SetBusy(busyTokenList.pos);
	    }
	    cur = peekToken;
	    peekToken = cur.next;
	} while (cur.kind > maxT); /* Skip pragmas */
	++cur.refcnt;
	return cur;
    }

    public void ResetPeek()
    {
	peekToken = curToken;
    }

    public void IncRef(CcsToken_t token)
    {
	++token.refcnt;
    }

    public void DecRef(CcsToken_t token)
    {
	CcsToken_t prevToken, curToken;
	if (token == dummyToken) return;
	if (--token.refcnt > 0) return;
	Debug.Assert(busyTokenList != null);
	for (prevToken = null, curToken = busyTokenList;
	     curToken != token; prevToken = curToken, curToken = curToken.next)
	    Debug.Assert(curToken != null && curToken != this.curToken);
	/* Found, *curToken == token, detach and destroy it. */
	if (prevToken == null) busyTokenList = curToken.next;
	else prevToken.next = curToken.next;
	token = null;
	/* Adjust CcsBuffer busy pointer */
	if (prevToken == null) {
	    if (busyTokenList != null) buffer.SetBusy(busyTokenList.pos);
	    else buffer.ClearBusy();
	}
    }

    public CcsPosition_t GetPosition(CcsToken_t begin, CcsToken_t end)
    {
	int len = (int)(end.pos - begin.pos);
	return new CcsPosition_t(begin.pos, len, begin.col,
				 buffer.GetString(begin.pos, len));
    }

    public CcsPosition_t GetPositionBetween(CcsToken_t begin, CcsToken_t end)
    {
	long begpos = begin.pos + begin.val.Length;
	int len = (int)(end.pos - begpos);
	string str = buffer.GetString(begpos, len);
	int cur;

	/* Skip the leading spaces. */
	for (cur = 0; cur < len; ++cur)
	    if (str[cur] != ' ' && str[cur] != '\t' &&
		str[cur] != '\r' && str[cur] != '\n') break;
	return new CcsPosition_t(begpos + cur, len - cur, 0,
				 str.Substring(cur));
    }

    /* All the following things are used by CcsScanner_NextToken. */
    private class Char2State_t {
	public int keyFrom;
	public int keyTo;
	public int val;

	public Char2State_t(int keyFrom, int keyTo, int val)
	{
	    this.keyFrom = keyFrom;
	    this.keyTo = keyTo;
	    this.val = val;
	}
    };

    static readonly Char2State_t[] c2sArr = {
	/*---- chars2states ----*/
	new Char2State_t(CcsBuffer_t.EoF, CcsBuffer_t.EoF, -1),
	new Char2State_t(34, 34, 11),	/* '"' '"' */
	new Char2State_t(36, 36, 10),	/* '$' '$' */
	new Char2State_t(39, 39, 5),	/* '\'' '\'' */
	new Char2State_t(40, 40, 30),	/* '(' '(' */
	new Char2State_t(41, 41, 21),	/* ')' ')' */
	new Char2State_t(43, 43, 14),	/* '+' '+' */
	new Char2State_t(45, 45, 15),	/* '-' '-' */
	new Char2State_t(46, 46, 28),	/* '.' '.' */
	new Char2State_t(48, 57, 2),	/* '0' '9' */
	new Char2State_t(60, 60, 29),	/* '<' '<' */
	new Char2State_t(61, 61, 13),	/* '=' '=' */
	new Char2State_t(62, 62, 17),	/* '>' '>' */
	new Char2State_t(65, 90, 1),	/* 'A' 'Z' */
	new Char2State_t(91, 91, 22),	/* '[' '[' */
	new Char2State_t(93, 93, 23),	/* ']' ']' */
	new Char2State_t(95, 95, 1),	/* '_' '_' */
	new Char2State_t(97, 122, 1),	/* 'a' 'z' */
	new Char2State_t(123, 123, 24),	/* '{' '{' */
	new Char2State_t(124, 124, 20),	/* '|' '|' */
	new Char2State_t(125, 125, 25),	/* '}' '}' */
	/*---- enable ----*/
    };

    private int Char2State(int chr)
    {
	int m, b = 0, e = c2sArr.Length;
	while (b < e) {
	    m = (b + e) / 2;
	    if (chr < c2sArr[m].keyFrom) e = m;
	    else if (chr > c2sArr[m].keyTo) b = m + 1;
	    else return c2sArr[m].val;
	}
	return 0;
    }

    private class Identifier2KWKind_t {
	public string key;
	public int val;

	public Identifier2KWKind_t(string key, int val)
	{
	    this.key = key;
	    this.val = val;
	}
    };

    static readonly Identifier2KWKind_t[] i2kArr = {
	/*---- identifiers2keywordkinds ----*/
	new Identifier2KWKind_t("ANY", 29),
	new Identifier2KWKind_t("CHARACTERS", 11),
	new Identifier2KWKind_t("COMMENTS", 14),
	new Identifier2KWKind_t("COMPILER", 6),
	new Identifier2KWKind_t("CONSTRUCTOR", 8),
	new Identifier2KWKind_t("CONTEXT", 44),
	new Identifier2KWKind_t("DESTRUCTOR", 9),
	new Identifier2KWKind_t("END", 22),
	new Identifier2KWKind_t("FROM", 15),
	new Identifier2KWKind_t("IF", 43),
	new Identifier2KWKind_t("IGNORE", 18),
	new Identifier2KWKind_t("IGNORECASE", 10),
	new Identifier2KWKind_t("MEMBERS", 7),
	new Identifier2KWKind_t("NESTED", 17),
	new Identifier2KWKind_t("PRAGMAS", 13),
	new Identifier2KWKind_t("PRODUCTIONS", 19),
	new Identifier2KWKind_t("SCHEME", 23),
	new Identifier2KWKind_t("SECTION", 24),
	new Identifier2KWKind_t("SYNC", 42),
	new Identifier2KWKind_t("TO", 16),
	new Identifier2KWKind_t("TOKENS", 12),
	new Identifier2KWKind_t("UPDATES", 25),
	new Identifier2KWKind_t("WEAK", 35),
	/*---- enable ----*/
    };

    private int Identifier2KWKind(string key, int defaultVal)
    {
	int rc, m, b = 0, e = i2kArr.Length;

	if (!caseSensitive) key = key.ToLower();
	while (b < e) {
	    m = (b + e) / 2;
	    rc = String.Compare(key, i2kArr[m].key);
	    if (rc < 0) e = m;
	    else if (rc > 0) b = m + 1;
	    else return i2kArr[m].val;
	}
	return defaultVal;
    }

    private int GetKWKind(long start, long end, int defaultVal)
    {
	return Identifier2KWKind(buffer.GetString(start, (int)(end - start)),
				 defaultVal);
    }

    private void GetCh()
    {
	if (oldEols > 0) {
	    ch = '\n'; --oldEols; oldEolsEOL= true;
	} else {
	    if (ch == '\n') {
		if (oldEolsEOL) oldEolsEOL = false;
		else {
		    ++line; col = 0;
		}
	    } else if (ch == '\t') {
		col += 8 - col % 8;
	    } else {
		/* FIX ME: May be the width of some specical character
		 * is NOT self->chBytes. */
		col += chBytes;
	    }
	    ch = buffer.Read(out chBytes);
	    pos = buffer.GetPos();
	}
    }

    private class SLock_t {
	public int ch, chBytes;
	public long pos;
	public int line, col;
    };

    private SLock_t LockCh()
    {
	SLock_t slock = new SLock_t();
	slock.ch = ch;
	slock.chBytes = chBytes;
	slock.pos = pos;
	slock.line = line;
	slock.col = col;
	buffer.Lock();
	return slock;
    }

    private void UnlockCh(SLock_t slock)
    {
	buffer.Unlock();
    }

    private void ResetCh(SLock_t slock)
    {
	ch = slock.ch;
	chBytes = slock.chBytes;
	pos = slock.pos;
	line = slock.line;
	buffer.LockReset();
    }

    private class CcsComment_t {
	public int[] start;
	public int[] end;
	public bool nested;

	public CcsComment_t(int start0, int start1,
			    int end0, int end1, bool nested)
	{
	    start = new int[2] { start0, start1 };
	    end = new int[2] { end0, end1 };
	    this.nested = nested;
	}
    }
    static readonly CcsComment_t[] comments = {
	/*---- comments ----*/
	new CcsComment_t('/', '/', '\n', 0, false),
	new CcsComment_t('/', '*', '*', '/', true),
	/*---- enable ----*/
    };

    private bool Comment(CcsComment_t c)
    {
	SLock_t slock = null;
	int level = 1, line0 = line;

	if (c.start[1] != 0) {
	    slock = LockCh(); GetCh();
	    if (ch != c.start[1]) {
		ResetCh(slock);
		return false;
	    }
	    UnlockCh(slock);
	}
	GetCh();
	for (;;) {
	    if (ch == c.end[0]) {
		if (c.end[1] == 0) {
		    if (--level == 0) break;
		} else {
		    slock = LockCh(); GetCh();
		    if (ch == c.end[1]) {
			UnlockCh(slock);
			if (--level == 0) break;
		    } else {
			ResetCh(slock);
		    }
		}
	    } else if (c.nested && ch == c.start[0]) {
		if (c.start[1] == 0) {
		    ++level;
		} else {
		    slock = LockCh(); GetCh();
		    if (ch == c.start[1]) {
			UnlockCh(slock);
			++level;
		    } else {
			ResetCh(slock);
		    }
		}
	    } else if (ch == CcsBuffer_t.EoF) {
		return true;
	    }
	    GetCh();
	}
	oldEols = line - line0;
	GetCh();
	return true;
    }

    public CcsToken_t NextToken()
    {
	long pos;
	int line, col, state, kind; CcsToken_t t;
	int curComment;
	for (;;) {
	    while (ch == ' '
		   /*---- scan1 ----*/
		   || (ch >= '\t' && ch <= '\n')
		   || ch == '\r'
		   /*---- enable ----*/
		   ) GetCh();
	    for (curComment = 0; curComment < comments.Length; ++curComment)
		if (ch == comments[curComment].start[0] &&
		    Comment(comments[curComment])) break;
	    if (curComment >= comments.Length) break;
	}
	pos = this.pos; line = this.line; col = this.col;
	buffer.Lock();
	state = Char2State(ch);
	GetCh();
	kind = noSym;
	switch (state) {
	case -1: kind = eofSym; break;
	case 0: kind = noSym; break;
	    /*---- scan3 ----*/
	case 1: case_1:
	    if ((ch >= '0' && ch <= '9') ||
		(ch >= 'A' && ch <= 'Z') ||
		ch == '_' ||
		(ch >= 'a' && ch <= 'z')) {
		GetCh(); goto case_1;
	    } else { kind = GetKWKind(pos, this.pos, 1); break; }
	case 2: case_2:
	    if ((ch >= '0' && ch <= '9')) {
		GetCh(); goto case_2;
	    } else { kind = 2; break; }
	case 3: case_3:
	    { kind = 3; break; }
	case 4: case_4:
	    { kind = 4; break; }
	case 5:
	    if ((ch >= 0 && ch <= '\t') ||
		(ch >= '\v' && ch <= '\f') ||
		(ch >= 14 && ch <= '&') ||
		(ch >= '(' && ch <= '[') ||
		(ch >= ']' && ch <= 65535)) {
		GetCh(); goto case_6;
	    } else if (ch == '\\') {
		GetCh(); goto case_7;
	    } else { kind = noSym; break; }
	case 6: case_6:
	    if (ch == '\'') {
		GetCh(); goto case_9;
	    } else { kind = noSym; break; }
	case 7: case_7:
	    if ((ch >= ' ' && ch <= '~')) {
		GetCh(); goto case_8;
	    } else { kind = noSym; break; }
	case 8: case_8:
	    if ((ch >= '0' && ch <= '9') ||
		(ch >= 'a' && ch <= 'f')) {
		GetCh(); goto case_8;
	} else if (ch == '\'') {
		GetCh(); goto case_9;
	    } else { kind = noSym; break; }
	case 9: case_9:
	    { kind = 5; break; }
	case 10: case_10:
	    if ((ch >= '0' && ch <= '9') ||
		(ch >= 'A' && ch <= 'Z') ||
		ch == '_' ||
		(ch >= 'a' && ch <= 'z')) {
		GetCh(); goto case_10;
	    } else { kind = 48; break; }
	case 11: case_11:
	    if ((ch >= 0 && ch <= '\t') ||
		(ch >= '\v' && ch <= '\f') ||
		(ch >= 14 && ch <= '!') ||
		(ch >= '#' && ch <= '[') ||
		(ch >= ']' && ch <= 65535)) {
		GetCh(); goto case_11;
	    } else if (ch == '"') {
		GetCh(); goto case_3;
	    } else if (ch == '\\') {
		GetCh(); goto case_12;
	    } else if (ch == '\n' ||
		       ch == '\r') {
		GetCh(); goto case_4;
	    } else { kind = noSym; break; }
	case 12: case_12:
	    if ((ch >= ' ' && ch <= '~')) {
		GetCh(); goto case_11;
	    } else { kind = noSym; break; }
	case 13:
	    { kind = 20; break; }
	case 14:
	    { kind = 26; break; }
	case 15:
	    { kind = 27; break; }
	case 16: case_16:
	    { kind = 28; break; }
	case 17:
	    { kind = 31; break; }
	case 18: case_18:
	    { kind = 32; break; }
	case 19: case_19:
	    { kind = 33; break; }
	case 20:
	    { kind = 34; break; }
	case 21:
	    { kind = 37; break; }
	case 22:
	    { kind = 38; break; }
	case 23:
	    { kind = 39; break; }
	case 24:
	    { kind = 40; break; }
	case 25:
	    { kind = 41; break; }
	case 26: case_26:
	    { kind = 45; break; }
	case 27: case_27:
	    { kind = 46; break; }
	case 28:
	    if (ch == '.') {
		GetCh(); goto case_16;
	    } else if (ch == '>') {
		GetCh(); goto case_19;
	    } else if (ch == ')') {
		GetCh(); goto case_27;
	    } else { kind = 21; break; }
	case 29:
	    if (ch == '.') {
		GetCh(); goto case_18;
	    } else { kind = 30; break; }
	case 30:
	    if (ch == '.') {
		GetCh(); goto case_26;
	    } else { kind = 36; break; }
	    /*---- enable ----*/
	}
	t = new CcsToken_t(kind, pos, col, line,
			   buffer.GetString(pos, (int)(this.pos - pos)));
	buffer.Unlock();
	return t;
    }
}
