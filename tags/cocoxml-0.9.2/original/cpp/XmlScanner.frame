/*----------------------------------------------------------------------
Compiler Generator CocoXml/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

/*---- Begin ----*/
#if !defined(COCOXML_SCANNER_H__)
#define COCOXML_SCANNER_H__

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vector>
#include <map>
#include <stack>

#include <expat.h>

using namespace std;

// io.h and fcntl are used to ensure binary read from streams on windows
#if _MSC_VER >= 1300
#include <io.h>
#include <fcntl.h>
#endif

#define COCO_CHAR_MAX 65535
#define MIN_BUFFER_LENGTH 1024
#define MAX_BUFFER_LENGTH (64*MIN_BUFFER_LENGTH)
#define HEAP_BLOCK_SIZE (64*1024)
#define COCO_CPP_NAMESPACE_SEPARATOR ':'

/*---- Namespace Begin ----*/

struct charCmp {
	bool operator()(const char* s1, const char* s2 ) const{
        return strcmp(s1, s2) < 0;
	}
};

class Token  
{
public:
/*---- Options ----*/
    int numOptions;
    int kind;     // token kind
    int col;      // token column (starting at 1)
    int line;     // token line (starting at 1)
    char* val; // token value

    Token();
    ~Token();
};

class TagInfo {
public:
    int startToken;
    int endToken;
};

class XmlLangDefinition {
public:
    vector<bool> useVector;
    map<const char*, TagInfo*, charCmp> Tags;
    map<const char*, int, charCmp>      Attrs;
    map<const char*, int, charCmp>      PInstructions;

    XmlLangDefinition();
    ~XmlLangDefinition();

    void AddTag(const char* Name, int StartToken, int EndToken);
    void AddAttr(const char* Name, int AttrToken);
    void AddProcessingInstruction(const char* PIName, int PIToken);
};

class tagStackEle {
public:
    bool unknownNamespace;
    bool unknownTag;
    XmlLangDefinition *xldef;
};

class charDataEle {
public:
    char *s;
    int   len; 
};

/* expat callback function definition */
void XMLCALL startElementHandler(void *userData, const XML_Char *name, const XML_Char **atts);
void XMLCALL endElementHandler(void *userData, const XML_Char *name);
void XMLCALL charDataHandler(void *userData, const XML_Char *s, int len);
void XMLCALL processingInstructionHandler(void *userData, const XML_Char *target, const XML_Char *data);
void XMLCALL commentHandler(void *userData, const XML_Char *data);
void XMLCALL cdataHandler(void *userData);

class XmlScanner {
public:
    int eof;
/*---- Declarations ----*/
    map<const char*, XmlLangDefinition*, charCmp> XmlLangMap;
    stack<tagStackEle*>                    tagStack;
    vector<charDataEle*>                   charDatas;
    vector<Token*>                         tokens;
    unsigned int                           peek;
    FILE*                                  xmlstream;                                   
    XML_Parser                             xmlparser;
    
    XmlScanner (const char* fileName);
    ~XmlScanner ();
    void Init();
    int StartElement2Kind(const char* NamespaceURI, const char* TagName);
    int EndElement2Kind(const char* NamespaceURI, const char* TagName);
    int Attribute2Kind(const char* NamespaceURI, const char* AttrName);
    int ProcessingInstruction2Kind(const char* PIName);

    void AppendToken(int kind, int linenumber, int lineposition, char* value);
    void AppendTokens();
    Token* Scan ();
    Token* Peek ();
    void ResetPeek();
}; // end Scanner

/*---- Namespace End ----*/

#endif // !defined(COCO_SCANNER_H__)

/*---- Implementation ----*/
/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*---- Begin ----*/

#include <memory.h>
#include <string.h>
#include "XmlScanner.hxx"


using namespace std;

/*---- Namespace Begin ----*/

Token::Token() 
{
    kind = 0;
    col  = 0;
    line = 0;
    val  = NULL;

/*---- Init Tokens ----*/
}

Token::~Token() {
    free(val);
}

XmlLangDefinition::XmlLangDefinition() {
/*---- Init UseVector ----*/
}

void XmlLangDefinition::AddTag(const char* Name, int StartToken, int EndToken) {
    TagInfo *tinfo = new TagInfo();
    tinfo->startToken = StartToken;
    tinfo->endToken = EndToken;
    Tags.insert(make_pair(Name, tinfo));
}

void XmlLangDefinition::AddAttr(const char* Name, int AttrToken) {
    Attrs.insert(make_pair(Name, AttrToken));
}

void XmlLangDefinition::AddProcessingInstruction(const char* PIName, int PIToken) {
    PInstructions.insert(make_pair(PIName, PIToken));
}

XmlScanner::XmlScanner (const char* fileName) {
    xmlstream = fopen(fileName, "r");
    if(xmlstream){
       Init();
    }else{
       //throw new FatalError("Can not open file " + fileName);
    }
}

XmlScanner::~XmlScanner() {
    XML_ParserFree(xmlparser);
    if(xmlstream) fclose(xmlstream);
}

void XmlScanner::Init() {
    XmlLangDefinition *curXLDef;

    xmlparser = XML_ParserCreate("UTF-8");
    XML_SetUserData(xmlparser, this);

    XML_SetElementHandler(xmlparser, startElementHandler, endElementHandler);

    XML_SetCharacterDataHandler(xmlparser, charDataHandler);

    XML_SetProcessingInstructionHandler(xmlparser, processingInstructionHandler);
    
    XML_SetCommentHandler(xmlparser, commentHandler);

    XML_SetStartCdataSectionHandler(xmlparser, cdataHandler);

    eof = 0;
    peek = 0;

/*---- Initialization ----*/
    tagStackEle *tsEle = new tagStackEle();
    tsEle->unknownNamespace = false;
    tsEle->unknownTag = false;
    tsEle->xldef = XmlLangMap[""];
    tagStack.push(tsEle);
}

int XmlScanner::StartElement2Kind(const char* NamespaceURI, const char* TagName) {
    tagStackEle *curEle = tagStack.top();
    tagStackEle *newEle = new tagStackEle();

    map<const char*, XmlLangDefinition*>::iterator it1=XmlLangMap.find(NamespaceURI);
    if (it1 == XmlLangMap.end()) {
        newEle->unknownNamespace = true;
        newEle->unknownTag = false;
        newEle->xldef = curEle->xldef;
        tagStack.push(newEle);
        return useKindVector[Token::UNKNOWN_NAMESPACE];
    }
    newEle->unknownNamespace = false;
    newEle->xldef = XmlLangMap[NamespaceURI];
    map<const char*, TagInfo*>::iterator it2=newEle->xldef->Tags.find(TagName);
    if (it2 == newEle->xldef->Tags.end()) {
        newEle->unknownTag = true;
        tagStack.push(newEle);
        return useKindVector[Token::UNKNOWN_TAG];
    }
    newEle->unknownTag = false;
    tagStack.push(newEle);
    return newEle->xldef->Tags[TagName]->startToken;
}

int XmlScanner::EndElement2Kind(const char* NamespaceURI, const char* TagName) {
    tagStackEle* curEle = tagStack.top();
    tagStack.pop();

    if (curEle->unknownNamespace) {
        return useKindVector[(int)Token::END_UNKNOWN_NAMESPACE];
    }
    if (curEle->unknownTag)
        return useKindVector[(int)Token::END_UNKNOWN_TAG];
    return curEle->xldef->Tags[TagName]->endToken;
}

int XmlScanner::Attribute2Kind(const char* NamespaceURI, const char* AttrName) {
    XmlLangDefinition *xldef;
    tagStackEle *curEle = tagStack.top();

    if (!strcmp(NamespaceURI, ""))
        xldef = curEle->xldef;
    else {
        map<const char*, XmlLangDefinition*>::iterator it1=XmlLangMap.find(NamespaceURI);
        if (it1 == XmlLangMap.end())
            return useKindVector[(int)Token::UNKNOWN_ATTR_NAMESPACE];
        else 
            xldef = XmlLangMap[NamespaceURI];
    }
    map<const char*, int>::iterator it2=xldef->Attrs.find(AttrName);
    if (it2 == xldef->Attrs.end())
        return useKindVector[(int)Token::UNKNOWN_ATTR];
    return xldef->Attrs[AttrName];
}

int XmlScanner::ProcessingInstruction2Kind(const char* PIName) {
    tagStackEle *curEle = tagStack.top();

    map<const char*, int>::iterator it=curEle->xldef->PInstructions.find(PIName);
    if (it == curEle->xldef->PInstructions.end())
        return useKindVector[(int)Token::UNKNOWN_PROCESSING_INSTRUCTION];
    return curEle->xldef->PInstructions[PIName];
}


int is_xml_whitespace(const char *s, int len)
{
    int ret=0, i;
    for(i=0; i<len; i++){
        if(('\r' == s[i]) ||
           ('\n' == s[i]) ||
           ('\t' == s[i]) ||
           (' ' == s[i]))
            ret++;
        else{
            ret = 0;
            break;
        }
    }
    return ret;
}

void XMLCALL startElementHandler(void *userData, const char *name, const char **atts)
{
    XmlScanner *scanner=(XmlScanner *)userData;
    char *wname = strdup(name);
    char *nm=NULL, *elename=NULL;
    int kind;

    /* clear text string */
    scanner->charDatas.clear();

    /* append start element */
    char* p = strchr(wname, ':');
    int inx = -1;
    if(p){
        inx = p - wname;
    }

    if(inx>0){
        /* have namespace indication */
        nm = strdup(wname);
        nm[inx] = '\0'; 

        elename = strdup(wname+inx+1);
    }else{
        /* No namespace */
        nm = strdup("");
        elename = strdup(wname);
    }
    kind = scanner->StartElement2Kind(nm, elename);
    //printf("Start(%s:%d)get namespace:[%s], start elename:[%s]\n", name, kind, nm, elename);
    scanner->AppendToken(kind, 0, 0, elename);

    if (kind < 0) 
        goto out;
    
    inx = 0;
    while(*(atts+inx)){
        char *wkey=NULL, *wvalue=NULL;

        wkey = strdup(atts[inx+0]);
        wvalue = strdup(atts[inx+1]);
        //printf("\t key:%s, value:%s\n", wkey, wvalue);
        inx += 2;
        
        kind = scanner->Attribute2Kind(nm, wkey);

        scanner->AppendToken(kind, 0/*line number*/, 0/*line position*/, wvalue);
        free(wkey);
        free(wvalue);        
    }

out:
    free(wname);
    free(nm);
    free(elename);
}

void XMLCALL endElementHandler(void *userData, const char *name)
{
    XmlScanner *scanner=(XmlScanner *)userData;
    char *wname = strdup(name);
    char *nm=NULL, *elename=NULL;
    int kind;

    /* append text string */
    if(!scanner->charDatas.empty()){
        tagStackEle* curEle = scanner->tagStack.top();
        char* value;
        int len = 0, opt;
        unsigned int i;
        char *buf;
        for(i=0;i<scanner->charDatas.size();i++){
            charDataEle *ele = scanner->charDatas[i];
            len += ele->len;
        }
        buf = (char*)malloc(len+1);
        int off=0;
        for(i=0;i<scanner->charDatas.size();i++){
            charDataEle *ele = scanner->charDatas[i];
            memcpy(buf+off, ele->s, ele->len);
            off += ele->len;
        }
        buf[len] = 0;
        value = strdup(buf);
        /* clear text string */
        scanner->charDatas.clear();

        if(is_xml_whitespace(buf, len)){
            if (curEle->unknownNamespace) opt = Token::UNS_WHITESPACE;
            else if (curEle->unknownTag) opt = Token::UT_WHITESPACE;
            else opt = Token::WHITESPACE;
        }else{
            if (curEle->unknownNamespace) opt = Token::UNS_TEXT;
            else if (curEle->unknownTag) opt = Token::UT_TEXT;
            else opt = Token::TEXT;
        }
        kind = curEle->xldef->useVector[(int)opt] ? scanner->useKindVector[(int)opt] : -1;
        scanner->AppendToken(kind, 0, 0, value);

        free(value);
    }

    /* append end element */
    char* p = strchr(wname, ':');
    int inx = -1;
    if(p){
        inx = p - wname;
    }
    if(inx>0){
        /* have namespace indication */
        nm = strdup(wname);
        nm[inx] = '\0';

        elename = strdup(wname+inx+1);
    }else{
        /* No namespace */
        nm = strdup("");
        elename = strdup(wname);
    }
    kind = scanner->EndElement2Kind(nm, elename);
    //printf("End(%s:%d)get namespace:[%s], start elename:[%s]\n", name, kind, nm, elename);
    scanner->AppendToken(kind, 0, 0, elename);

    free(wname);
    free(nm);
    free(elename);
}

void XMLCALL charDataHandler(void *userData, const XML_Char *s, int len)
{
    XmlScanner *scanner=(XmlScanner *)userData;
    charDataEle *ele;
    
    ele = new(charDataEle);
    ele->s = (char *)malloc(len);
    memcpy(ele->s, s, len);
    ele->len = len;
    scanner->charDatas.push_back(ele);
}

void XMLCALL processingInstructionHandler(void *userData, const XML_Char *target, const XML_Char *data)
{
    XmlScanner *scanner=(XmlScanner *)userData;
    char *wtarget, *wdata;
    int kind;
    
    wtarget = strdup(target);
    wdata = strdup(data);
    
    kind = scanner->ProcessingInstruction2Kind(wtarget);
    scanner->AppendToken(kind, 0, 0, wdata);

    free(wtarget);
    free(wdata);
}

void XMLCALL commentHandler(void *userData, const XML_Char *data)
{
    XmlScanner *scanner=(XmlScanner *)userData;
    int opt;
    tagStackEle* curEle = scanner->tagStack.top();
    char *value = strdup(data);
    int kind;

    if (curEle->unknownNamespace) opt = Token::UNS_CDATA;
    else if (curEle->unknownTag) opt = Token::UT_CDATA;
    else opt = Token::CDATA;
    
    kind = curEle->xldef->useVector[(int)opt] ? scanner->useKindVector[(int)opt] : -1;
    
    scanner->AppendToken(kind, 0, 0, value);
    
    free(value);
}

void XMLCALL cdataHandler(void *userData)
{
    XmlScanner *scanner=(XmlScanner *)userData;
    int opt;
    tagStackEle* curEle = scanner->tagStack.top();
    char *value = strdup((char *)userData);
    int kind;

    if (curEle->unknownNamespace) opt = Token::UNS_CDATA;
    else if (curEle->unknownTag) opt = Token::UT_CDATA;
    else opt = Token::CDATA;

    kind = curEle->xldef->useVector[(int)opt] ? scanner->useKindVector[(int)opt] : -1;
    
    scanner->AppendToken(kind, 0, 0, value);
    
    free(value);
}

void XmlScanner::AppendToken(int kind, int linenumber, int lineposition, char* value)
{    
    Token* new_token = NULL;

    if(kind < 0) return;

    new_token = new Token();
    new_token->kind = kind;
    new_token->line = linenumber;
    new_token->col = lineposition;
    new_token->val = value?strdup(value):NULL;
    //printf("F:%s,%d, append:%s(%d)\n", __FUNCTION__, __LINE__, new_token->val, kind);
    tokens.push_back(new_token);
}

#define BUFF_SIZE 1024
void XmlScanner::AppendTokens() {
    if(eof) {
        AppendToken(0, 0, 0, NULL);
        return;
    }

    for (;;) {
        int bytes_read;
        void *buff = XML_GetBuffer(xmlparser, BUFF_SIZE);
        if (buff == NULL) {
            /* handle error */
        }

        bytes_read = fread(buff, 1, BUFF_SIZE, xmlstream);
        if (bytes_read < 0) {
            /* handle error */
        }

        if (!XML_ParseBuffer(xmlparser, bytes_read, bytes_read==0)) {
            /* handle parse error */
        }

        if (bytes_read == 0){
            break;
        }
    }

    AppendToken(0, 0, 0, NULL);
    eof = 1;
}

Token* XmlScanner::Scan () {
    Token* token;
    if (tokens.size() == 0) AppendTokens();
    token = tokens.front();
    //printf("F:%s,%d, token->kind:%d\n", __FUNCTION__, __LINE__, token->kind);
    tokens.erase(tokens.begin());
    return token;
}

Token* XmlScanner::Peek () {
    if (peek == tokens.size()) AppendTokens();
    return tokens[peek ++];
}

void XmlScanner::ResetPeek () { peek = 0; }

/*---- Namespace End ----*/

/*---- $$$ ----*/
