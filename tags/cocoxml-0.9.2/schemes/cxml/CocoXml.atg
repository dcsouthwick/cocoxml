SECTION license
/*-------------------------------------------------------------------------
 Coco.ATG -- Attributed Grammar
 Compiler Generator Coco/R,
 Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
 extended by M. Loeberbauer & A. Woess, Univ. of Linz
 with improvements by Pat Terry, Rhodes University.
 ported to C by Charles Wang <charlesw123456@gmail.com>

 This program is free software; you can redistribute it and/or modify it 
 under the terms of the GNU General Public License as published by the 
 Free Software Foundation; either version 2, or (at your option) any 
 later version.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 for more details.

 You should have received a copy of the GNU General Public License along 
 with this program; if not, write to the Free Software Foundation, Inc., 
 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

 As an exception, it is allowed to write an extension of Coco/R that is
 used as a plugin in non-free software.

 If not otherwise stated, any source code generated by Coco/R (other than 
 Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
END.

SCHEME c CcsXml

SECTION hIncludes
#ifndef  COCO_GLOBALS_H
#include  "Globals.h"
#endif
END.

SECTION cIncludes
#include  "XmlSpec.h"
#include  "Globals.h"
#include  "syntax/Nodes.h"
END.

COMPILER CocoXml

MEMBERS
    CcGlobals_t       globals;

    /* Shortcut pointers */
    CcSymbolTable_t * symtab;
    CcXmlSpecMap_t  * xmlspecmap;
    CcSyntax_t      * syntax;

CONSTRUCTOR
    if (!CcGlobalsXml(&self->globals, &self->errpool)) return FALSE;
    self->symtab = &self->globals.symtab;
    self->xmlspecmap = self->globals.xmlspecmap;
    self->syntax = &self->globals.syntax; 

DESTRUCTOR
    CcGlobals_Destruct(&self->globals);

CHARACTERS
    letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
    digit     = "0123456789".
    cr        = '\r'.
    lf        = '\n'.
    tab       = '\t'.
    stringCh  = ANY - '"' - '\\' - cr - lf.
    charCh    = ANY - '\'' - '\\' - cr - lf.
    printable =  '\x20' .. '\x7e'.
    hex       = "0123456789abcdef".

TOKENS
    ident     = letter { letter | digit }.
    number    = digit { digit }.
    string    = '"' { stringCh | '\\' printable } '"'.
    badString = '"' { stringCh | '\\' printable } (cr | lf).
    char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

CocoXml                         (. CcSymbol_t  * sym;
				   CcGraph_t   * g;
				   char        * gramName = NULL;
				   CcXmlSpec_t * xsdef;
				   CcsToken_t  * beg;
				   CcsBool_t     undef;
				   CcsBool_t     noAttrs; .)
=
  { SchemeDecl | SectionDecl }
  "COMPILER"
  ident                         (. gramName = CcStrdup(self->t->val); .)
  [ "MEMBERS"                   (. CcsXmlScanner_TokenIncRef(&self->scanner, beg = self->la); .)
    { ANY }                     (. self->syntax->members = CcsXmlScanner_GetPosition(&self->scanner, beg, self->la);
      	  			   CcsXmlScanner_TokenDecRef(&self->scanner, beg); .)
    ]
  [ "CONSTRUCTOR"               (. CcsXmlScanner_TokenIncRef(&self->scanner, beg = self->la); .)
    { ANY }			(. self->syntax->constructor = CcsXmlScanner_GetPosition(&self->scanner, beg, self->la);
      	  			   CcsXmlScanner_TokenDecRef(&self->scanner, beg); .)
    ]
  [ "DESTRUCTOR"                (. CcsXmlScanner_TokenIncRef(&self->scanner, beg = self->la); .)
    { ANY }			(. self->syntax->destructor = CcsXmlScanner_GetPosition(&self->scanner, beg, self->la);
      	  			   CcsXmlScanner_TokenDecRef(&self->scanner, beg); .)
    ]

  XmlSpecDecl<&xsdef>           (. CcXmlSpecMap_Add(self->xmlspecmap, "", xsdef); .)
  { XmlNamespaceDecl }

  SYNC 
  "PRODUCTIONS"                 (. CcXmlSpecMap_MakeTerminals(self->xmlspecmap, &self->globals);
  				   CcEBNF_Clear(&self->syntax->base); .)
  { ident                       (. sym = CcSymbolTable_FindSym(self->symtab, self->t->val);
                                   undef = (sym == NULL);
				   if (undef) {
				       sym = CcSymbolTable_NewNonTerminal(self->symtab,
									  self->t->val, self->t->loc.line);
                                   } else {
				       if (sym->base.type == symbol_nt) {
					   if (((CcSymbolNT_t *)sym)->graph != NULL)
					       CcsXmlParser_SemErrT(self, "name declared twice");
				       } else {
					   CcsXmlParser_SemErrT(self, "this symbol kind not allowed on left side of production");
				       }
				       sym->line = self->t->loc.line;
                                   }
				   CcsAssert(sym->base.type == symbol_nt);
                                   noAttrs = (((CcSymbolNT_t *)sym)->attrPos == NULL);
				   if (!noAttrs) {
				       CcsPosition_Destruct(((CcSymbolNT_t *)sym)->attrPos);
				       ((CcSymbolNT_t *)sym)->attrPos = NULL; 
				   } .)
    [ AttrDecl<(CcSymbolNT_t *)sym> ]  (. if (!undef && noAttrs != (((CcSymbolNT_t *)sym)->attrPos == NULL))
                                              CcsXmlParser_SemErrT(self, "attribute mismatch between declaration and use of this symbol"); .)
    [ SemText<.&((CcSymbolNT_t *)sym)->semPos.> ] WEAK
    '='
    Expression<&g>              (. ((CcSymbolNT_t *)sym)->graph = g->head;
				   CcGraph_Finish(g);
				   CcGraph_Destruct(g); .)
                                WEAK
    '.'
  }
  "END" ident                   (. if (strcmp(gramName, self->t->val))
				       CcsXmlParser_SemErrT(self, "name does not match grammar name");
				   self->syntax->gramSy = CcSymbolTable_FindSym(self->symtab, gramName);
				   CcFree(gramName);
				   if (self->syntax->gramSy == NULL) {
                                       CcsXmlParser_SemErrT(self, "missing production for grammar name");
                                   } else {
                                       sym = self->syntax->gramSy;
                                       if (((CcSymbolNT_t *)sym)->attrPos != NULL)
					   CcsXmlParser_SemErrT(self, "grammar symbol must not have attributes");
                                   }
				   /* noSym gets highest number */
				   self->syntax->noSy = CcSymbolTable_NewTerminal(self->symtab, "???", 0);
				   CcSyntax_SetupAnys(self->syntax); .)
  '.'
.

/*------------------------------------------------------------------------------------*/

SchemeDecl
=
  "SCHEME" ident  (. if (self->syntax->schemeName) CcFree(self->syntax->schemeName);
  	   	     self->syntax->schemeName = CcStrdup(self->t->val); .)
  ident           (. if (self->syntax->grammarPrefix) CcFree(self->syntax->grammarPrefix);
  		     self->syntax->grammarPrefix = CcStrdup(self->t->val); .)
.

/*------------------------------------------------------------------------------------*/

SectionDecl       (. char * secname; CcsToken_t * beg; .)
=
  "SECTION" ident (. secname = CcStrdup(self->t->val);
  	    	     CcsXmlScanner_TokenIncRef(&self->scanner, beg = self->t); .)
  { ANY }         (. CcGlobals_NewSection(&self->globals, secname,
    		     			  CcsXmlScanner_GetPositionBetween(&self->scanner, beg, self->la));
		     CcsXmlScanner_TokenDecRef(&self->scanner, beg);
		     CcFree(secname); .)
  "END" '.'
.

/*------------------------------------------------------------------------------------*/

XmlNamespaceDecl            (. char * nsURI; CcXmlSpec_t * xsdef; .)
=
  "NAMESPACE" string        (. nsURI = CcStrdup(self->t->val); .)
  XmlSpecDecl<&xsdef>       (. if (!CcXmlSpecMap_Add(self->xmlspecmap, nsURI, xsdef))
      			           CcsXmlParser_SemErrT(self, "The namespace '%s' is defined more than once.", nsURI); .)
  "END"                     (. CcFree(nsURI); .)
.

/*------------------------------------------------------------------------------------*/

XmlSpecDecl<CcXmlSpec_t ** xsdef> (. *xsdef = CcXmlSpec(&self->globals); .)
=
  [ "IGNORECASE"                  (. CcXmlSpec_SetCaseSensitive(*xsdef, FALSE); .) ]
  [ "OPTIONS" { OptionDecl<*xsdef> } ]
  [ "TAGS" { XmlTagDecl<*xsdef> } ]
  [ "ATTRS" { XmlAttrDecl<*xsdef> } ]
  [ "PROCESSING_INSTRUCTIONS" { XmlPIDecl<*xsdef> } ]
.

/*------------------------------------------------------------------------------------*/

OptionDecl<CcXmlSpec_t * xsdef>
=
  ident (. CcXmlSpec_SetOption(xsdef, self->t); .)
.

/*------------------------------------------------------------------------------------*/

XmlTagDecl<CcXmlSpec_t * xsdef>    (. char * tagname; .)
=
  ident                            (. tagname = CcStrdup(self->t->val); .)
  "="
  string                           (. CcXmlSpec_AddTag(xsdef, tagname, self->t);
  				      CcFree(tagname); .)
.

/*------------------------------------------------------------------------------------*/

XmlAttrDecl<CcXmlSpec_t * xsdef>   (. char * attrname; .)
=
  ident                            (. attrname = CcStrdup(self->t->val); .)
  "="
  string                           (. CcXmlSpec_AddAttr(xsdef, attrname, self->t);
  				      CcFree(attrname); .)
.

/*------------------------------------------------------------------------------------*/

XmlPIDecl<CcXmlSpec_t * xsdef>     (. char * target; .)
=
  ident                            (. target = CcStrdup(self->t->val); .)
  "="
  string                           (. CcXmlSpec_AddProcessInstruction(xsdef, target, self->t);
  				      CcFree(target); .)
.

/*------------------------------------------------------------------------------------*/

AttrDecl<CcSymbolNT_t * sym>    (. CcsToken_t * beg; .)
=
  '<'                           (. CcsXmlScanner_TokenIncRef(&self->scanner, beg = self->la); .)
  { ANY
  | badString                   (. CcsXmlParser_SemErrT(self, "bad string in attributes"); .)
  }
  '>'                           (. sym->attrPos = CcsXmlScanner_GetPosition(&self->scanner, beg, self->t);
  				   CcsXmlScanner_TokenDecRef(&self->scanner, beg); .)
| "<."                          (. CcsXmlScanner_TokenIncRef(&self->scanner, beg = self->la); .)
  { ANY
  | badString                   (. CcsXmlParser_SemErrT(self, "bad string in attributes"); .)
  }
  ".>"                          (. sym->attrPos = CcsXmlScanner_GetPosition(&self->scanner, beg, self->t);
     				   CcsXmlScanner_TokenDecRef(&self->scanner, beg); .)
.

/*------------------------------------------------------------------------------------*/

Expression<CcGraph_t ** g>      (. CcGraph_t * g2; CcsBool_t first; .)
= 
  Term<g>                       (. first = TRUE; .)
  {                             WEAK
    '|'
  Term<&g2>                     (. if (first) { CcEBNF_MakeFirstAlt(&self->syntax->base, *g); first = FALSE; }
                                   CcEBNF_MakeAlternative(&self->syntax->base, *g, g2);
				   CcGraph_Destruct(g2); .)
  }
.

/*------------------------------------------------------------------------------------*/

Term<CcGraph_t ** g>            (. CcGraph_t * g2; CcsPosition_t * pos; CcNode_t * rslv = NULL;
                                   *g = NULL; .)
=
  ( [
  Resolver<.&pos.>              (. rslv = CcEBNF_NewNode(&self->syntax->base,
							 CcNodeRslvP(self->la->loc.line, pos));
                                   *g = CcGraphP(rslv); .)
  ]
  Factor<&g2>                   (. if (rslv == NULL) *g = g2;
   				   else {
				       CcEBNF_MakeSequence(&self->syntax->base, *g, g2);
				       CcGraph_Destruct(g2);
				   } .)
  { Factor<&g2>                 (. CcEBNF_MakeSequence(&self->syntax->base, *g, g2);
    				   CcGraph_Destruct(g2); .)
  }
|                               (. *g = CcGraphP(CcEBNF_NewNode(&self->syntax->base, CcNodeEps(0))); .)
)                               (. if (*g == NULL) /* invalid start of Term */
				       *g = CcGraphP(CcEBNF_NewNode(&self->syntax->base, CcNodeEps(0))); .)
.

/*------------------------------------------------------------------------------------*/

Factor<CcGraph_t ** g>          (. char * name = NULL;
		    		   CcsPosition_t * pos;
				   CcsBool_t weak = FALSE;
				   CcsBool_t undef;
				   CcSymbol_t * sym;
				   CcNode_t * p;
                                   *g = NULL; .)
=
( [ "WEAK"                      (. weak = TRUE; .)
  ]
  Sym<&name>                    (. sym = CcSymbolTable_FindSym(self->symtab, name);
                                   undef = (sym == NULL);
                                   if (undef) { /* forward nt */
				        sym = CcSymbolTable_NewNonTerminal(self->symtab, name, 0);
                                   }
				   CcFree(name);
                                   if (sym->base.type != symbol_t && sym->base.type != symbol_nt)
                                       CcsXmlParser_SemErrT(self, "this symbol kind is not allowed in a production");
                                   if (weak) {
				       if (sym->base.type != symbol_t)
				           CcsXmlParser_SemErrT(self, "only terminals may be weak");
				   }

				   p = CcSyntax_NodeFromSymbol(self->syntax, sym, self->t->loc.line, weak);
				   *g = CcGraphP(p); .)
  [ Attribs<p>
  ]                             (. if (undef) {
                                       if (sym->base.type == symbol_nt)
				           ((CcSymbolNT_t *)sym)->attrPos = CcsPosition_Clone(((CcNodeNT_t *)p)->pos);
                                   } else if (sym->base.type == symbol_nt &&
				              (((CcNodeNT_t *)p)->pos == NULL) !=
					      (((CcSymbolNT_t *)sym)->attrPos == NULL))
				       CcsXmlParser_SemErrT(self, "attribute mismatch between declaration and use of this symbol"); .)
| '(' Expression<g> ')'
| '[' Expression<g> ']'         (. CcEBNF_MakeOption(&self->syntax->base, *g); .)
| '{' Expression<g> '}'         (. CcEBNF_MakeIteration(&self->syntax->base, *g); .)
| SemText<&pos>                 (. p = CcEBNF_NewNode(&self->syntax->base, CcNodeSem(0));
                                   ((CcNodeSEM_t *)p)->pos = pos;
				   *g = CcGraphP(p); .)
| "ANY"                         (. /* p.set is set in Tab_SetupAnys */
                                   p = CcEBNF_NewNode(&self->syntax->base, CcNodeAny(0));
				   *g = CcGraphP(p); .)
| "SYNC"                        (. p = CcEBNF_NewNode(&self->syntax->base, CcNodeSync(0));
				   *g = CcGraphP(p);
                                .)
)                               (. if (*g == NULL) /* invalid start of Factor */
				       *g = CcGraphP(CcEBNF_NewNode(&self->syntax->base, CcNodeEps(0))); .)
.

/*------------------------------------------------------------------------------------*/

Resolver<CcsPosition_t ** pos>   (. CcsToken_t * beg; .)
=
  "IF" "("                       (. CcsXmlScanner_TokenIncRef(&self->scanner, beg = self->la); .)
  Condition                      (. *pos = CcsXmlScanner_GetPosition(&self->scanner, beg, self->t);
                                    CcsXmlScanner_TokenDecRef(&self->scanner, beg); .)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

Sym<char ** name>
=
 ident                          (. *name = CcStrdup(self->t->val); .)
.

/*------------------------------------------------------------------------------------*/

Attribs<CcNode_t * p>           (. CcsToken_t * beg; .)
=
  '<'                           (. CcsXmlScanner_TokenIncRef(&self->scanner, beg = self->la); .)
  { ANY 
  | badString                   (. CcsXmlParser_SemErrT(self, "bad string in attributes"); .)
  }
  '>'                           (. CcNode_SetPosition(p, CcsXmlScanner_GetPosition(&self->scanner, beg, self->t));
                                   CcsXmlScanner_TokenDecRef(&self->scanner, beg); .)
| "<."                          (. CcsXmlScanner_TokenIncRef(&self->scanner, beg = self->la); .)
  { ANY 
  | badString                   (. CcsXmlParser_SemErrT(self, "bad string in attributes"); .)
  }
  ".>"                          (. CcNode_SetPosition(p, CcsXmlScanner_GetPosition(&self->scanner,
                                                                                beg, self->t));
                                   CcsXmlScanner_TokenDecRef(&self->scanner, beg); .)
.

/*------------------------------------------------------------------------------------*/

SemText<CcsPosition_t ** pos>   (. CcsToken_t * beg; .)
=
  "(."                          (. CcsXmlScanner_TokenIncRef(&self->scanner, beg = self->la); .)
  { ANY
  | badString                   (. CcsXmlParser_SemErrT(self, "bad string in semantic action"); .)
  | "(."                        (. CcsXmlParser_SemErrT(self, "missing end of previous semantic action"); .)
  }
  ".)"                          (. *pos = CcsXmlScanner_GetPosition(&self->scanner, beg, self->t);
                                   CcsXmlScanner_TokenDecRef(&self->scanner, beg); .)
.

/*------------------------------------------------------------------------------------*/
  
END CocoXml.
