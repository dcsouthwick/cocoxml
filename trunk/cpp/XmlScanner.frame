/*----------------------------------------------------------------------
Compiler Generator CocoXml/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

/*---- Begin ----*/
#if !defined(COCOXML_SCANNER_H__)
#define COCOXML_SCANNER_H__

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

// io.h and fcntl are used to ensure binary read from streams on windows
#if _MSC_VER >= 1300
#include <io.h>
#include <fcntl.h>
#endif

#if _MSC_VER >= 1400
#define coco_swprintf swprintf_s
#elif _MSC_VER >= 1300
#define coco_swprintf _snwprintf
#elif defined __GNUC__
#define coco_swprintf swprintf
#else 
#error unknown compiler!
#endif 

#define COCO_WCHAR_MAX 65535
#define MIN_BUFFER_LENGTH 1024
#define MAX_BUFFER_LENGTH (64*MIN_BUFFER_LENGTH)
#define HEAP_BLOCK_SIZE (64*1024)
#define COCO_CPP_NAMESPACE_SEPARATOR L':'

// string handling, wide character
wchar_t* coco_string_create(const wchar_t *value);
wchar_t* coco_string_create(const wchar_t *value, int startIndex, int length);
wchar_t* coco_string_create_upper(const wchar_t* data);
wchar_t* coco_string_create_lower(const wchar_t* data);
wchar_t* coco_string_create_lower(const wchar_t* data, int startIndex, int dataLen);
wchar_t* coco_string_create_append(const wchar_t* data1, const wchar_t* data2);
wchar_t* coco_string_create_append(const wchar_t* data, const wchar_t value);
void  coco_string_delete(wchar_t* &data);
int   coco_string_length(const wchar_t* data);
bool  coco_string_endswith(const wchar_t* data, const wchar_t *value);
int   coco_string_indexof(const wchar_t* data, const wchar_t value);
int   coco_string_lastindexof(const wchar_t* data, const wchar_t value);
void  coco_string_merge(wchar_t* &data, const wchar_t* value);
bool  coco_string_equal(const wchar_t* data1, const wchar_t* data2);
int   coco_string_compareto(const wchar_t* data1, const wchar_t* data2);
int   coco_string_hash(const wchar_t* data);

// string handling, ascii character
wchar_t* coco_string_create(const char *value);
char* coco_string_create_char(const wchar_t *value);
void  coco_string_delete(char* &data);


/*---- Namespace ----*/

class Token  
{
/*---- Options ----*/
public:
    int kind;     // token kind
    int col;      // token column (starting at 1)
    int line;     // token line (starting at 1)
    wchar_t* val; // token value

    Token();
    ~Token();
};

class TagInfo {
    int startToken;
    int endToken;
}

class XmlLangDefinition {
    vector<bool>            useVector;
    map<wchar_t*, *TagInfo> Tags;
    map<wchar_t*, int>      Attrs;
    map<wchar_t*, int>      PInstructions;

    XmlLangDefinition();
    ~XmlLangDefinition();

    void AddTag(const wchar_t* Name, int StartToken, int EndToken);
    void AddAttr(const wchar_t* Name, int AttrToken);
    void AddProcessingInstruction(wchar_t* PIName, int PIToken);
}

public class tagStackEle {
    bool unknownNamespace;
    bool unknownTag;
    XmlLangDefinition *xldef;
}

class XmlScanner {
    enum XSStatus { XSCommon, XSFirstAttr, XSNextAttr };

    const char EOL = '\n';
    const int eofSym = 0;
/*---- Declarations ----*/
    map<const wchar_t*, XmlLangDefinition*> XmlLangMap;
    stack<tagStackEle*>                    tagStack;
    XSStatus                               status;
    bool                                   inEmptyElement;
    wchar_t*                               emptyNSURI;
    wchar_t*                               emptyLName;
    vector<Token*>                         tokens;
    int                                    peek;
    FILE*                                  xmlfile;                                   
    XML_Parser                             xmlparser;
    
    XmlScanner (const char* fileName);
    XmlScanner (Stream s);
    void Init();
    int StartElement2Kind(wchar_t* NamespaceURI, wchar_t* TagName);
    int EndElement2Kind(wchar_t* NamespaceURI, wchar_t* TagName);
    int Attribute2Kind(wchar_t* NamespaceURI, wchar_t* AttrName);
    int ProcessingInstruction2Kind(wchar_t* PIName);
    int Others2Kind(XmlNodeType *ntype);
    void AppendToken();
    Token Scan ();
    Token Peek ();
    void ResetPeek();
}; // end Scanner

-->namespace_close

#endif // !defined(COCO_SCANNER_H__)

-->implementation
/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
-->begin

#include <memory.h>
#include <string.h>
#include "Scanner.h"

// string handling, wide character

wchar_t* coco_string_create(const wchar_t* value) {
    wchar_t* data;
    int len = 0;
    if (value) { len = wcslen(value); }
    data = new wchar_t[len + 1];
    wcsncpy(data, value, len);
    data[len] = 0;
    return data;
}

wchar_t* coco_string_create(const wchar_t *value , int startIndex, int length) {
    int len = 0;
    wchar_t* data;

    if (value) { len = length; }
    data = new wchar_t[len + 1];
    wcsncpy(data, &(value[startIndex]), len);
    data[len] = 0;

    return data;
}

wchar_t* coco_string_create_upper(const wchar_t* data) {
    if (!data) { return NULL; }

    int dataLen = 0;
    if (data) { dataLen = wcslen(data); }

    wchar_t *newData = new wchar_t[dataLen + 1];

    for (int i = 0; i <= dataLen; i++) {
        if ((L'a' <= data[i]) && (data[i] <= L'z')) {
            newData[i] = data[i] + (L'A' - L'a');
        }
        else { newData[i] = data[i]; }
    }

    newData[dataLen] = L'\0';
    return newData;
}

wchar_t* coco_string_create_lower(const wchar_t* data) {
    if (!data) { return NULL; }
    int dataLen = wcslen(data);
    return coco_string_create_lower(data, 0, dataLen);
}

wchar_t* coco_string_create_lower(const wchar_t* data, int startIndex, int dataLen) {
    if (!data) { return NULL; }

    wchar_t* newData = new wchar_t[dataLen + 1];

    for (int i = 0; i <= dataLen; i++) {
        wchar_t ch = data[startIndex + i];
        if ((L'A' <= ch) && (ch <= L'Z')) {
            newData[i] = ch - (L'A' - L'a');
        }
        else { newData[i] = ch; }
    }
    newData[dataLen] = L'\0';
    return newData;
}

wchar_t* coco_string_create_append(const wchar_t* data1, const wchar_t* data2) {
    wchar_t* data;
    int data1Len = 0;
    int data2Len = 0;

    if (data1) { data1Len = wcslen(data1); }
    if (data2) {data2Len = wcslen(data2); }

    data = new wchar_t[data1Len + data2Len + 1];

    if (data1) { wcscpy(data, data1); }
    if (data2) { wcscpy(data + data1Len, data2); }

    data[data1Len + data2Len] = 0;

    return data;
}

wchar_t* coco_string_create_append(const wchar_t *target, const wchar_t appendix) {
    int targetLen = coco_string_length(target);
    wchar_t* data = new wchar_t[targetLen + 2];
    wcsncpy(data, target, targetLen);
    data[targetLen] = appendix;
    data[targetLen + 1] = 0;
    return data;
}

void coco_string_delete(wchar_t* &data) {
    delete [] data;
    data = NULL;
}

int coco_string_length(const wchar_t* data) {
    if (data) { return wcslen(data); }
    return 0;
}

bool coco_string_endswith(const wchar_t* data, const wchar_t *end) {
    int dataLen = wcslen(data);
    int endLen = wcslen(end);
    return (endLen <= dataLen) && (wcscmp(data + dataLen - endLen, end) == 0);
}

int coco_string_indexof(const wchar_t* data, const wchar_t value) {
    const wchar_t* chr = wcschr(data, value);

    if (chr) { return (chr-data); }
    return -1;
}

int coco_string_lastindexof(const wchar_t* data, const wchar_t value) {
    const wchar_t* chr = wcsrchr(data, value);

    if (chr) { return (chr-data); }
    return -1;
}

void coco_string_merge(wchar_t* &target, const wchar_t* appendix) {
    if (!appendix) { return; }
    wchar_t* data = coco_string_create_append(target, appendix);
    delete [] target;
    target = data;
}

bool coco_string_equal(const wchar_t* data1, const wchar_t* data2) {
    return wcscmp( data1, data2 ) == 0;
}

int coco_string_compareto(const wchar_t* data1, const wchar_t* data2) {
    return wcscmp(data1, data2);
}

int coco_string_hash(const wchar_t *data) {
    int h = 0;
    if (!data) { return 0; }
    while (*data != 0) {
        h = (h * 7) ^ *data;
        ++data;
    }
    if (h < 0) { h = -h; }
    return h;
}

// string handling, ascii character

wchar_t* coco_string_create(const char* value) {
    int len = 0;
    if (value) { len = strlen(value); }
    wchar_t* data = new wchar_t[len + 1];
    for (int i = 0; i < len; ++i) { data[i] = (wchar_t) value[i]; }
    data[len] = 0;
    return data;
}

char* coco_string_create_char(const wchar_t *value) {
    int len = coco_string_length(value);
    char *res = new char[len + 1];
    for (int i = 0; i < len; ++i) { res[i] = (char) value[i]; }
    res[len] = 0;
    return res;
}

void coco_string_delete(char* &data) {
    delete [] data;
    data = NULL;
}


-->namespace_open

Token::Token() {
    kind = 0;
    col  = 0;
    line = 0;
    val  = NULL;
}

Token::~Token() {
    coco_string_delete(val);
}

XmlLangDefinition::XmlLangDefinition() {
    useVector.resize(Token.numOptions);
}

void XmlLangDefinition::AddTag(const wchar_t* Name, int StartToken, int EndToken) {
    TagInfo *tinfo = new TagInfo();
    tinfo->startToken = StartToken;
    tinfo->endToken = EndToken;
    Tags.insert(make_pair(Name, tinfo));
}

void XmlLangDefinition::AddAttr(const wchar_t* Name, int AttrToken) {
    Attrs.insert(make_pair(Name, AttrToken));
}

void XmlLangDefinition::AddProcessingInstruction(const wchar_t* PIName, int PIToken) {
    PInstructions.insert(make_pair(PIName, PIToken));
}

XmlScanner::XmlScanner (const char* fileName) {
    xmlfile = fopen(fileName, "r");
    if(xmlfile){
       Init();
    }else{
       throw new FatalError("Can not open file " + fileName);
    }
}

XmlScanner::XmlScanner (Stream s) {
    Init();
}

XmlScanner::~XmlScanner() {
    XML_ParserFree(xmlparser);
    if(xmlfile) fclose(xmlfile);
}

void XmlScanner::Init() {
    xmlparser = XML_ParserCreate(NULL);
    XML_SetUserData(parser, this);

    XML_SetElementHandler(xmlparser, startElementHandler, endElementHandler);

    XML_SetNamespaceDeclHandler(parser, startNamespaceHandler, endNamespaceHandler);

    XML_SetCharacterDataHandler(parser, charDataHandler);

    XML_SetProcessingInstructionHandler(parser, processingInstructionHandler);

    status = XSStatus.XSCommon;
    inEmptyElement = false;
    peek = 0;

/*---- Initialization ----*/
    tagStackEle *tsEle = new tagStackEle();
    tsEle->unknownNamespace = false;
    tsEle->unknownTag = false;
    tsEle->xldef = XmlLangMap[coco_string_create("")];
    tagStack.push(tsEle);
}

int XmlScanner::StartElement2Kind(const wchar_t* NamespaceURI, const wchar_t* TagName) {
    tagStackEle *curEle = tagStack.top();
    tagStackEle *newEle = new tagStackEle();

    if (!XmlLangMap.find(NamespaceURI)) {
        newEle->unknownNamespace = true;
        newEle->unknownTag = false;
        newEle->xldef = curEle->xldef;
        tagStack.push(newEle);
        return useKindVector[(int)Token.Options.UNKNOWN_NAMESPACE];
    }
    newEle->unknownNamespace = false;
    newEle->xldef = XmlLangMap[NamespaceURI];
    if (!newEle.xldef->Tags.find(TagName)) {
        newEle->unknownTag = true;
        tagStack.push(newEle);
        return useKindVector[(int)Token.Options.UNKNOWN_TAG];
    }
    newEle->unknownTag = false;
    tagStack.push(newEle);
    return newEle->xldef->Tags[TagName].startToken;
}

int XmlScanner::EndElement2Kind(const wchar_t* NamespaceURI, const wchar_t* TagName) {
    tagStackEle* curEle = tagStack.pop();

    if (curEle->unknownNamespace) {
        return useKindVector[(int)Token.Options.END_UNKNOWN_NAMESPACE];
    }
    if (curEle->unknownTag)
        return useKindVector[(int)Token.Options.END_UNKNOWN_TAG];
    return curEle->xldef->Tags[TagName].endToken;
}

int XmlScanner::Attribute2Kind(const wchar_t* NamespaceURI, const wchar_t* AttrName) {
    XmlLangDefinition *xldef;
    tagStackEle *curEle = tagStack.top();

    // assert(!curEle.unknownNamespace and !curEle.unknownTag);
    if (NamespaceURI == "") xldef = curEle->xldef;
    else if (!XmlLangMap.find(NamespaceURI))
        return useKindVector[(int)Token.Options.UNKNOWN_ATTR_NAMESPACE];
    else xldef = XmlLangMap[NamespaceURI];
    if (!xldef->Attrs.find(AttrName))
        return useKindVector[(int)Token.Options.UNKNOWN_ATTR];
    return xldef->Attrs[AttrName];
}

int XmlScanner::ProcessingInstruction2Kind(const wchar_t* PIName) {
    tagStackEle *curEle = tagStack.top();
    // Should I always use 'XmlLangMap[""]' but not 'curEle.xldef' here?
    if (!curEle->xldef->PInstructions.ContainsKey(PIName))
        return useKindVector[(int)Token.Options.UNKNOWN_PROCESSING_INSTRUCTION];
    return curEle->xldef->PInstructions[PIName];
}

int XmlScanner::Others2Kind(XmlNodeType ntype) {
    Token.Options opt;
    tagStackEle* curEle = tagStack->top();

    switch (ntype) {
    case XmlNodeType.Text:
        if (curEle.unknownNamespace) opt = Token.Options.UNS_TEXT;
        else if (curEle.unknownTag) opt = Token.Options.UT_TEXT;
        else opt = Token.Options.TEXT;
        break;
    case XmlNodeType.CDATA:
        if (curEle.unknownNamespace) opt = Token.Options.UNS_CDATA;
        else if (curEle.unknownTag) opt = Token.Options.UT_CDATA;
        else opt = Token.Options.CDATA;
        break;
    case XmlNodeType.Whitespace:
        if (curEle.unknownNamespace) opt = Token.Options.UNS_WHITESPACE;
        else if (curEle.unknownTag) opt = Token.Options.UT_WHITESPACE;
        else opt = Token.Options.WHITESPACE;
        break;
    case XmlNodeType.Comment:
        if (curEle.unknownNamespace) opt = Token.Options.UNS_COMMENT;
        else if (curEle.unknownTag) opt = Token.Options.UT_COMMENT;
        else opt = Token.Options.COMMENT;
        break;
    default:
        return -1;
    }
    return curEle->xldef->useVector[(int)opt] ? useKindVector[(int)opt] : -1;
}

void XMLCALL  XmlScanner::startElement(void *userData, 
                                       const char *name, 
                                       const char **atts)
{
        
}

void XMLCALL  XmlScanner::endElementHandler(void *userData, 
                                            const char *name, 
                                            const char **atts)
{
}

void XMLCALL XmlScanner::startNamespaceHandler(void *userData,
                                               const XML_Char *prefix,
                                               const XML_Char *uri)
{
}

void XMLCALL XmlScanner::endNamespaceHandler(void *userData,
                                             const XML_Char *prefix)
{
}

void XMLCALL XmlScanner::charDataHandler(void *userData,
                                         const XML_Char *s,
                                         int len)
{
}
void XMLCALL XmlScanner::processingInstructionHandler(void *userData,
                                                      const XML_Char *target,
                                                      const XML_Char *data)
{

}

void XMLCALL XmlScanner::commentHandler(void *userData,
                                        const XML_Char *data)
{
}

void XMLCALL XmlScanner::cdataHandler(void *userData);



void XmlScanner::AppendToken() {
    int kind = -1;
    Token* new_token = null;

    while (kind < 0) {
        switch (status) {
        case XSStatus.XSCommon:
        if (inEmptyElement) {
            kind = EndElement2Kind(emptyNSURI, emptyLName);
            inEmptyElement = false;
            break;
        } else if (!xmlreader.Read()) { kind = eofSym; break; }
        switch (xmlreader.NodeType) {
        case XmlNodeType.Element:
            kind = StartElement2Kind(xmlreader.NamespaceURI,
                         xmlreader.LocalName);
            if (xmlreader.IsEmptyElement) {
            emptyNSURI = xmlreader.NamespaceURI;
            emptyLName = xmlreader.LocalName;
            inEmptyElement = true;
            }
            if (kind >= 0) status = XSStatus.XSFirstAttr;
            break;
        case XmlNodeType.EndElement:
            kind = EndElement2Kind(xmlreader.NamespaceURI,
                       xmlreader.Name);
            break;
        case XmlNodeType.ProcessingInstruction:
            kind = ProcessingInstruction2Kind(xmlreader.Name);
            break;
        default:
            kind = Others2Kind(xmlreader.NodeType);
            break;
        }
        break;
        case XSStatus.XSFirstAttr:
        if (!xmlreader.MoveToFirstAttribute()) {
            status = XSStatus.XSCommon;
            kind = -1;
        } else {
            status = XSStatus.XSNextAttr;
            kind = Attribute2Kind(xmlreader.NamespaceURI,
                      xmlreader.LocalName);
        }
        break;
        case XSStatus.XSNextAttr:
        if (!xmlreader.MoveToNextAttribute()) {
            status = XSStatus.XSCommon;
            kind = -1;
        } else {
            kind = Attribute2Kind(xmlreader.NamespaceURI,
                      xmlreader.LocalName);
        }
        break;
        }
    }
    new_token = new Token();
    new_token->kind = kind;
    new_token->line = xmlreader.LineNumber;
    new_token->col = xmlreader.LinePosition;
    new_token->val = xmlreader.Value;
    tokens.push_back(new_token);
}

Token XmlScanner::Scan () {
    Token* token;
    if (tokens->size() == 0) AppendToken();
    token = tokens.front();
    tokens.pop_front();
    return token;
}

Token XmlScanner::Peek () {
    if (peek == tokens.size()) AppendToken();
    return tokens[peek ++];
}

void XmlScanner::ResetPeek () { peek = 0; }

/*---- $$$ ----*/
