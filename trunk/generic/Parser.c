/*---- open(Parser.c) S ----*/
/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*---- enable ----*/
#include  <stdarg.h>
#include  <stdio.h>
#include  <stdlib.h>
#include  <string.h>
#include  "Parser.h"

Errors_t *
Errors(Errors_t * self, FILE * fp)
{
    if (!self && !(self = malloc(sizeof(Errors_t)))) return NULL;
    self->count = 0;
    self->fp = fp;
    return self;
}

void
Errors_Destruct(Errors_t * self)
{
}

void
Errors_SynErr(Errors_t * self, int line, int col, int n)
{
    char * s, format[20];
    switch (n) {
	/*---- errors ----*/
	/*---- enable ----*/
    default:
	snprintf(format, sizeof(format), "error %d", n);
	s = format;
	break;
    }
    fprintf(self->fp, "-- line %d col %d: %s\n", line, col, s);
    ++self->count;
}

void
Errors_Error(Errors_t * self, int line, int col,
	     const char * format, va_list ap)
{
    fprintf(self->fp, "-- line %d col %d: ", line, col);
    vfprintf(self->fp, format, ap);
    fprintf(self->fp, "\n");
    ++self->count;
}

void
Errors_Warning(Errors_t * self, int line, int col, const char * s)
{
    fprintf(self->fp, "-- line %d col %d: %s\n", line, col, s);
}

void
Errors_WarningS(Errors_t * self, const char * s)
{
    fprintf(self->fp, "%s\n", s);
}

void
Errors_Exception(Errors_t * self, const char * s)
{
    fprintf(self->fp, "%s\n", s);
    exit(1);
}

typedef int CBool_t;
#define TRUE  1
#define FALSE 0

static void
Parser_SynErr(Parser_t * self, int n)
{
    if (self->errDist >= self->minErrDist)
	Errors_SynErr(&self->errors, self->la->line, self->la->col, n);
    self->errDist = 0;
}

static void
Parser_Get(Parser_t * self)
{
    for (;;) {
	self->t = self->la;
	self->la = Scanner_Scan(self->scanner);
	if (self->la->kind <= self->maxT) { ++self->errDist; break; }
	/*---- pragmas ----*/
	/*---- enable ----*/
	if (self->dummyToken != self->t) {
	    self->dummyToken->kind = self->t->kind;
	    self->dummyToken->pos = self->t->pos;
	    self->dummyToken->col = self->t->col;
	    self->dummyToken->line = self->t->line;
	    self->dummyToken->next = NULL;
	    free(self->dummyToken->val);
	    self->dummyToken->val = strdup(self->t->val);
	    self->t = self->dummyToken;
	}
	self->la = self->t;
    }
}

static void
Parser_Expect(Parser_t * self, int n)
{
    if (self->la->kind == n) Parser_Get(self);
    else Parser_SynErr(self, n);
}

/*---- initialization ----*/
static CBool_t set[1][1] = {
    { FALSE }
};
/*---- enable ----*/
static CBool_t
Parser_StartOf(Parser_t * self, int s)
{
    return set[s][self->la->kind];
}

static void
Parser_ExpectWeak(Parser_t * self, int n, int follow)
{
    if (self->la->kind == n) Parser_Get(self);
    else {
	Parser_SynErr(self, n);
	while (!Parser_StartOf(self, follow)) Parser_Get(self);
    }
}

static CBool_t
Parser_WeakSeparator(Parser_t * self, int n, int syFol, int repFol)
{
    if (self->la->kind == n) { Parser_Get(self); return TRUE; }
    else if (Parser_StartOf(self, repFol)) { return TRUE; }
    Parser_SynErr(self, n);
    while (!(Parser_StartOf(self, syFol) ||
	     Parser_StartOf(self, repFol) ||
	     Parser_StartOf(self, 0)))
	Parser_Get(self);
    return Parser_StartOf(self, syFol);
}

void
Parser_SemErr(Parser_t * self, const char * format, ...)
{
    va_list ap;
    if (self->errDist >= self->minErrDist) {
	va_start(ap, format);
	Errors_Error(&self->errors, self->t->line, self->t->col, format, ap);
	va_end(ap);
    }
    self->errDist = 0;
}

/*---- productions ----*/
/*---- enable ----*/

void
Parser_Parser(Parser_t * self)
{
    self->t = NULL;
    self->la = self->dummyToken = Token(NULL);
    self->la->val = strdup("Dummy Token");
    Parser_Get(self);
    /*---- parseRoot ----*/
    /*---- enable ----*/
    Parser_Expect(self, 0);
}

Parser_t *
Parser(Parser_t * self, Scanner_t * scanner)
{
    if (!self && !(self = malloc(sizeof(Parser_t)))) return NULL;
    /*---- constants ----*/
    /*---- enable ----*/
    self->dummyToken = NULL;
    self->t = self->la = NULL;
    self->minErrDist = 2;
    self->errDist = self->minErrDist;
    self->scanner = scanner;
    Errors(&self->errors, stderr);
    return self;
}

void
Parser_Destruct(Parser_t * self)
{
    Errors_Destruct(&self->errors);
    if (self->dummyToken) {
	Token_Destruct(self->dummyToken); free(self->dummyToken);
    }
}
