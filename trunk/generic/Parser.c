/*---- open(Parser.c) S ----*/
/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*---- enable ----*/
#include  <stdarg.h>
#include  <stdio.h>
#include  <stdlib.h>
#include  <string.h>
#include  "Parser.h"

Errors_t *
Errors(Errors_t * self, FILE * fp)
{
    if (!self && !(self = malloc(sizeof(Errors_t)))) return NULL;
    self->count = 0;
    self->fp = fp;
    return self;
}

void
Errors_Destruct(Errors_t * self)
{
}

void
Errors_SynErr(Errors_t * self, int line, int col, int n)
{
    const char * s; char format[20];
    switch (n) {
	/*---- errors ----*/
    case 0: s = "EOF expected"; break;
    case 1: s = "ident expected"; break;
    case 2: s = "number expected"; break;
    case 3: s = "string expected"; break;
    case 4: s = "badString expected"; break;
    case 5: s = "char expected"; break;
    case 6: s = "\"COMPILER\" expected"; break;
    case 7: s = "\"IGNORECASE\" expected"; break;
    case 8: s = "\"CHARACTERS\" expected"; break;
    case 9: s = "\"TOKENS\" expected"; break;
    case 10: s = "\"PRAGMAS\" expected"; break;
    case 11: s = "\"COMMENTS\" expected"; break;
    case 12: s = "\"FROM\" expected"; break;
    case 13: s = "\"TO\" expected"; break;
    case 14: s = "\"NESTED\" expected"; break;
    case 15: s = "\"IGNORE\" expected"; break;
    case 16: s = "\"PRODUCTIONS\" expected"; break;
    case 17: s = "\"=\" expected"; break;
    case 18: s = "\".\" expected"; break;
    case 19: s = "\"END\" expected"; break;
    case 20: s = "\"+\" expected"; break;
    case 21: s = "\"-\" expected"; break;
    case 22: s = "\"..\" expected"; break;
    case 23: s = "\"ANY\" expected"; break;
    case 24: s = "\"<\" expected"; break;
    case 25: s = "\">\" expected"; break;
    case 26: s = "\"<.\" expected"; break;
    case 27: s = "\".>\" expected"; break;
    case 28: s = "\"|\" expected"; break;
    case 29: s = "\"WEAK\" expected"; break;
    case 30: s = "\"(\" expected"; break;
    case 31: s = "\")\" expected"; break;
    case 32: s = "\"[\" expected"; break;
    case 33: s = "\"]\" expected"; break;
    case 34: s = "\"{\" expected"; break;
    case 35: s = "\"}\" expected"; break;
    case 36: s = "\"SYNC\" expected"; break;
    case 37: s = "\"IF\" expected"; break;
    case 38: s = "\"CONTEXT\" expected"; break;
    case 39: s = "\"(.\" expected"; break;
    case 40: s = "\".)\" expected"; break;
    case 41: s = "??? expected"; break;
    case 42: s = "this symbol not expected in Coco"; break;
    case 43: s = "this symbol not expected in TokenDecl"; break;
    case 44: s = "invalid TokenDecl"; break;
    case 45: s = "invalid AttrDecl"; break;
    case 46: s = "invalid SimSet"; break;
    case 47: s = "invalid Sym"; break;
    case 48: s = "invalid Term"; break;
    case 49: s = "invalid Factor"; break;
    case 50: s = "invalid Attribs"; break;
    case 51: s = "invalid TokenFactor"; break;
	/*---- enable ----*/
    default:
	snprintf(format, sizeof(format), "error %d", n);
	s = format;
	break;
    }
    fprintf(self->fp, "-- line %d col %d: %s\n", line, col, s);
    ++self->count;
}

void
Errors_Error(Errors_t * self, int line, int col,
	     const char * format, va_list ap)
{
    fprintf(self->fp, "-- line %d col %d: ", line, col);
    vfprintf(self->fp, format, ap);
    fprintf(self->fp, "\n");
    ++self->count;
}

void
Errors_Warning(Errors_t * self, int line, int col, const char * s)
{
    fprintf(self->fp, "-- line %d col %d: %s\n", line, col, s);
}

void
Errors_WarningS(Errors_t * self, const char * s)
{
    fprintf(self->fp, "%s\n", s);
}

void
Errors_Exception(Errors_t * self, const char * s)
{
    fprintf(self->fp, "%s\n", s);
    exit(1);
}

typedef int CBool_t;
#define TRUE  1
#define FALSE 0

static void
Parser_SynErr(Parser_t * self, int n)
{
    if (self->errDist >= self->minErrDist)
	Errors_SynErr(&self->errors, self->la->line, self->la->col, n);
    self->errDist = 0;
}

static void
Parser_Get(Parser_t * self)
{
    for (;;) {
	self->t = self->la;
	self->la = Scanner_Scan(self->scanner);
	if (self->la->kind <= self->maxT) { ++self->errDist; break; }
	/*---- pragmas ----*/
	/*---- enable ----*/
	if (self->dummyToken != self->t) {
	    self->dummyToken->kind = self->t->kind;
	    self->dummyToken->pos = self->t->pos;
	    self->dummyToken->col = self->t->col;
	    self->dummyToken->line = self->t->line;
	    self->dummyToken->next = NULL;
	    free(self->dummyToken->val);
	    self->dummyToken->val = strdup(self->t->val);
	    self->t = self->dummyToken;
	}
	self->la = self->t;
    }
}

static void
Parser_Expect(Parser_t * self, int n)
{
    if (self->la->kind == n) Parser_Get(self);
    else Parser_SynErr(self, n);
}


static const char * set[] = {
    /*---- initialization ----*/
    "**.*.*....**...***.....................*...",
    ".*****.***********************************.",
    ".******.....***..*************************.",
    "**.*.*....**...****....*....***.*.*.**.*...",
    "**.*.*....**...***.*...................*...",
    "**.*.*....**...***.....................*...",
    ".*.*.*....**...**......................*...",
    "...........*.****.*............*.*.*.......",
    ".*.*.*........................*.*.*........",
    ".************************.****************.",
    ".***.********************.****************.",
    ".**************************.**************.",
    ".***.**********************.**************.",
    ".***************************************.*.",
    ".***.**********************************..*.",
    "..................*............*.*.*.......",
    ".*.*.*............*....*....**********.*...",
    ".*.*.*.................*.....**.*.*.**.*...",
    ".*.*.*.................*.....**.*.*.*..*...",
    "..................*.........*..*.*.*.......",
    ".******************************.**********."
    /*---- enable ----*/
};
static int
Parser_StartOf(Parser_t * self, int s)
{
    return set[s][self->la->kind] == '*';
}

static void
Parser_ExpectWeak(Parser_t * self, int n, int follow)
{
    if (self->la->kind == n) Parser_Get(self);
    else {
	Parser_SynErr(self, n);
	while (!Parser_StartOf(self, follow)) Parser_Get(self);
    }
}

static CBool_t
Parser_WeakSeparator(Parser_t * self, int n, int syFol, int repFol)
{
    if (self->la->kind == n) { Parser_Get(self); return TRUE; }
    else if (Parser_StartOf(self, repFol)) { return TRUE; }
    Parser_SynErr(self, n);
    while (!(Parser_StartOf(self, syFol) ||
	     Parser_StartOf(self, repFol) ||
	     Parser_StartOf(self, 0)))
	Parser_Get(self);
    return Parser_StartOf(self, syFol);
}

void
Parser_SemErr(Parser_t * self, const char * format, ...)
{
    va_list ap;
    if (self->errDist >= self->minErrDist) {
	va_start(ap, format);
	Errors_Error(&self->errors, self->t->line, self->t->col, format, ap);
	va_end(ap);
    }
    self->errDist = 0;
}

/*---- productions ----*/
/*---- enable ----*/

void
Parser_Parse(Parser_t * self)
{
    self->t = NULL;
    self->la = self->dummyToken = Token(NULL);
    self->la->val = strdup("Dummy Token");
    Parser_Get(self);
    /*---- parseRoot ----*/
    /*---- enable ----*/
    Parser_Expect(self, 0);
}

Parser_t *
Parser(Parser_t * self, Scanner_t * scanner)
{
    if (!self && !(self = malloc(sizeof(Parser_t)))) return NULL;
    /*---- constants ----*/
    /*---- enable ----*/
    self->dummyToken = NULL;
    self->t = self->la = NULL;
    self->minErrDist = 2;
    self->errDist = self->minErrDist;
    self->scanner = scanner;
    Errors(&self->errors, stderr);
    return self;
}

void
Parser_Destruct(Parser_t * self)
{
    Errors_Destruct(&self->errors);
    if (self->dummyToken) {
	Token_Destruct(self->dummyToken); free(self->dummyToken);
    }
}


