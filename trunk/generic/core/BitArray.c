/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
#include  "BitArray.h"

#define NB2SZ(nb)   (((nb) + 7) >> 3)
static int bitmask[] = { 0xFF, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F };

CsBitArray_t *
CsBitArray(CsBitArray_t * self, int numbits)
{
    self = AllocObject(self, sizeof(CsBitArray_t));
    self->numbits = numbits;
    if (numbits) {
	self->data = CocoMalloc(NB2SZ(numbits));
	memset(self->data, 0, NB2SZ(numbits));
    } else {
	self->data = NULL;
    }
    return self;
}

CsBitArray_t *
CsBitArray1(CsBitArray_t * self, int numbits)
{
    self = AllocObject(self, sizeof(CsBitArray_t));
    self->numbits = numbits;
    if (numbits) {
	self->data = CocoMalloc(NB2SZ(numbits));
	memset(self->data, 0xFF, NB2SZ(numbits));
    } else {
	self->data = NULL;
    }
    return self;
}

CsBitArray_t *
CsBitArray_Clone(CsBitArray_t * self, const CsBitArray_t * value)
{
    self = AllocObject(self, sizeof(CsBitArray_t));
    if (value->data) {
	self->data = CocoMalloc(NB2SZ(value->numbits));
	memcpy(self->data, value->data, NB2SZ(value->numbits));
    } else {
	self->data = NULL;
    }
    self->numbits = value->numbits;
    return self;
}

void
CsBitArray_Destruct(CsBitArray_t * self)
{
    if (self->data) {
	CocoFree(self->data);
	self->data = NULL;
    }
    self->numbits = 0;
}

int
CsBitArray_getCount(const CsBitArray_t * self)
{
    return self->numbits;
}

int
CsBitArray_Elements(const CsBitArray_t * self)
{
    int bit;
    int elements = 0;
    int bits = self->numbits;
    const unsigned char * cur = self->data;
    while (bits >= 8) {
	for (bit = 0; bit < 8; ++bit)
	    if ((*cur & (1 << bit))) ++elements;
	bits = bits - 8;
	++cur;
    }
    for (bit = 0; bit < bits; ++bit)
	if ((*cur & (1 << bit))) ++elements;
    return elements;
}

CsBool_t
CsBitArray_Get(const CsBitArray_t * self, int index)
{
    if (index < 0 || index >= self->numbits) return -1;
    return (self->data[index >> 3] & (1 << (index & 0x07))) != 0;
}

void
CsBitArray_Set(CsBitArray_t * self, int index, CsBool_t value)
{
    if (value) self->data[index >> 3] |= 1 << (index & 0x07);
    else self->data[index >> 3] &= ~(1 << (index & 0x07));
}

void
CsBitArray_SetAll(CsBitArray_t * self, CsBool_t value)
{
    if (self->data) memset(self->data, value ? 0xFF : 0, NB2SZ(self->numbits));
}

CsBool_t
CsBitArray_Equal(const CsBitArray_t * self1, const CsBitArray_t * self2)
{
    int boffset, bmask;
    if (self1->numbits != self2->numbits) return FALSE;
    if (!self1->data && !self2->data) return TRUE;
    if (!self1->data || !self2->data) return FALSE;
    if (self1->numbits > 8 &&
	memcmp(self1->data, self2->data, NB2SZ(self1->numbits) - 1))
	return FALSE;
    boffset = NB2SZ(self1->numbits) - 1;
    bmask = bitmask[self1->numbits & 0x07];
    if ((self1->data[boffset] & bmask) != (self2->data[boffset] & bmask))
	return FALSE;
    return TRUE;
}

void
CsBitArray_Not(CsBitArray_t * self)
{
    unsigned char * cur;
    for (cur = self->data; cur - self->data < NB2SZ(self->numbits); ++cur)
	*cur ^= 0xFF;
}

int
CsBitArray_And(CsBitArray_t * self, const CsBitArray_t * value)
{
    unsigned char * cur0, * cur1;
    if (self->numbits > value->numbits) return -1;
    for (cur0 = self->data, cur1 = value->data;
	 cur0 - self->data < NB2SZ(self->numbits); ++cur0, ++cur1)
	*cur0 &= *cur1;
    return 0;
}

int
CsBitArray_Or(CsBitArray_t * self, const CsBitArray_t * value)
{
    unsigned char * cur0, * cur1;
    if (self->numbits > value->numbits) return -1;
    for (cur0 = self->data, cur1 = value->data;
	 cur0 - self->data < NB2SZ(self->numbits); ++cur0, ++cur1)
	*cur0 |= *cur1;
    return 0;
}

int
CsBitArray_Xor(CsBitArray_t * self, const CsBitArray_t * value)
{
    unsigned char * cur0, * cur1;
    if (self->numbits > value->numbits) return -1;
    for (cur0 = self->data, cur1 = value->data;
	 cur0 - self->data < NB2SZ(self->numbits); ++cur0, ++cur1)
	*cur0 ^= *cur1;
    return 0;
}

CsBool_t
CsBitArray_Intersect(const CsBitArray_t * self1, const CsBitArray_t * self2)
{
    /* assert(self1->numbits == self2->numbits2); */
    int idx, numbytes = NB2SZ(self1->numbits);
    if (numbytes == 0) return FALSE;
    for (idx = 0; idx < numbytes - 1; ++idx)
	if ((self1->data[idx] & self2->data[idx])) return TRUE;
    if ((self1->data[numbytes - 1] & self2->data[numbytes - 1] &
	 bitmask[self1->numbits & 0x07]))
	return TRUE;
    return FALSE;
}

void
CsBitArray_Subtract(CsBitArray_t * self, const CsBitArray_t * b)
{
    /* assert(self->numbits == b->numbits); */
    int idx;
    for (idx = 0; idx < NB2SZ(self->numbits); ++idx)
	self->data[idx] &= ~ b->data[idx];
}

/*
void
CsBitArray_Dump(const CsBitArray_t * self, DumpBuffer_t * buf)
{
    int idx, numbits = CsBitArray_getCount(self);
    for (idx = 0; idx < numbits; ++idx)
	DumpBuffer_Print(buf, "%c", CsBitArray_Get(self, idx) ? '1' : '.');
}
*/
