根据Coco/R、CocoXml的任务，我们大概可以把他们要做的事情分为三类。
一、生成、优化、检验词法(或 XmlLangDefinition)、语法状态机。这一部分纯粹是维护数据结构，根据数据本身的特征完成需要的计算操作。与输入、输出的形式无关。它们的输入是产生式规则、输出是状态机数据结构；
二、根据状态机数据结构，生成不同形式的输出。可以想象的是，相同的状态机可以为不同的编程语言生成源代码，也可以生成测试信息输出。这些输出的格式跟数据的运算是完全无关的；
三、作为状态机输出的一个特例，即输出针对某种编程语言的源代码。这些生成的源代码与前面两个部分是完全隔离的，甚至可能是属于不同编程语言的。所谓的完全隔离，就是说不能使用前两部分提供的任何代码，包括数据结构、算法，等等。

Coco/R的代码，包含了上述三个部分，但是没有加以明确的区分。为了使结构清晰化，我们有必要对其结构进行调整。只有清晰化的结构，我们才能轻松地实现一个Coco为所有目标语言生成源代码，或者是为Coco增加新的功能(即强化词法、语法状态机的功能)

这里我们把对状态机的一组相关输出，称为“输出方案”。输出源代码的输出方案，称为“源代码输出方案”。

根据上面对事情的分类，可以确定Coco应该含有：
* 数据结构和算法：
  * 词法分析类：用于维护词法分析状态机；
    * 一些内部数据结构，例如 CharSet_t；
  * 语法分析类：用于维护语法分析状态机；
    * 一些内部数据结构，例如 Node_t；
  * Xml 语言定义类：用于存储 XML 语言相关的数据；
* 子数据结构，用于表征基本对象，简化交互。例如 Symbol_t、Token_t；这类对象往往只是数据的集合，本身并没有什么复杂操作。
* 各种输出方案，拥有同一个基类：OutputScheme_t。各种源代码输出方案，拥有同一个基类：SourceOutputScheme_t。SourceOutputScheme_t 是 OutputScheme_t 的派生类。
* 在 OutputScheme_t 中，实现所有输出方案共有的特性。在 SourceOutputScheme_t 中，实现所有源码输出方案共有的特性。
* 支持类，提供一些大家都需要的特性，例如：报错、基本数据结构、UTF-8 字符串维护等等。

上述类和结构，都不包括生成的源代码。要知道生成的源代码甚至是完全不同的编程语言，所以代码完全不可通用。在编码过程中尤其要注意区分那些是生产者，那些是产品。

生成的源代码要做的事，包括：获取输入、把输入分解为 Token_t、根据 Token_t 和产生式，执行对应的语义操作。需要注意的是这里所有的数据结构，均与前面所述的数据结构无关。在 Coco/R 目前的代码里面，有些结构是共用的，没有加以明确的区分。现在必须明确区分。有一部分支持类也是共享的，这也导致一定的混乱出现。

为了便于区分，所有Coco本体的结构和函数，均以Cc为前缀。而生成的源代码，均以方案名或者方案名缩写为前缀。用于生成Coco自身的输出方案，我们以Ccs为前缀。

在源代码组织上，根目录下保存主程序入口 Coco.c 和 CocoXml.c。

core 子目录含有所有数据结构算法类及子数据结构。其中一个.c含有词法状态机、一个.c含有语法状态机、一个.c含有Xml 语言定义、一个.c含有各种支持类及工具函数、一个.c含有交互子数据结构。

schemes 子目录含有各种输出方案，不同的输出方案在 schemes 的子目录中。schemes 中一个 .c 定义 OutputScheme 类，一个 .c 定义 SourceOutputScheme 类。

在输出方案子目录中，输出生产者和产品模板被保存在一起。这里要特别注意对这两者加以区分。

要整理 Coco 的源代码，首先必须对现有的 Coco 类及其成员进行分类。首先必须区分是属于本体还是属于被生成的源代码。而后对于本体部分，再按照本体需完成的事务类别进行区分。
* Action_t
* ArrayList_t
* BitArray_t
* CharClass_t
* CharSet_t
* Comment_t
* Graph_t
* HashTable_t
* Melted_t
* Node_t
* ParserGen_t
* Position_t
* SortedList_t
* State_t
* Symbol_t
* Target_t

* DFA_t
* Parser_t
* ParserGen_t

* Errors_t(Parser.frame)
* Parser_t(Parser.frame)
* Token_t(Scanner.frame)
* Buffer_t(Scanner.frame)
* Scanner_t(Scanner.frame)

