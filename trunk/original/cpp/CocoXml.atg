/*-------------------------------------------------------------------------
CocoXml.ATG -- Attributed Grammar
Compiler Generator CocoR,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------
 compile with:
   Coco CocoXml.ATG -namespace CocoXml
-------------------------------------------------------------------------*/

#include "Tab.h"
#include "XSData.h"
#include "ParserGen.h"

COMPILER CocoXml

	int id;
	int str;

	FILE* trace;		// other Coco objects referenced in this ATG
	Tab *tab;
    XmlScannerData *xsdata;
	ParserGen *pgen;

	bool genScanner;

	void InitDeclarations() {
		id  = 0;
		str = 1;
	}

/*-------------------------------------------------------------------------*/

CHARACTERS
	letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
	digit     = "0123456789".
	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.
	stringCh  = ANY - '"' - '\\' - cr - lf.
	charCh    = ANY - '\'' - '\\' - cr - lf.
	printable =  '\u0020' .. '\u007e'.
	hex       = "0123456789abcdef".

TOKENS
	ident     = ( letter | '_' ) { letter | digit | '_' } .
	number    = digit { digit }.
	string    = '"' { stringCh | '\\' printable } '"'.
	badString = '"' { stringCh | '\\' printable } (cr | lf).
	char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
	ddtSym    = '$' { digit | letter }.  (. tab->SetDDT(la->val); .)

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

CocoXml                            (. Symbol *sym; Graph *g; wchar_t* gramName = NULL; XmlLangDefinition *xldef; 
                                   InitDeclarations(); .)
=
                                (. int beg = la->pos; .)
  { // this section can be used
    // for #include statements
    ANY
  }                             (. if (la->pos != beg) {
                                     pgen->usingPos = new Position(beg, t->pos - beg + coco_string_length(t->val), 0);
                                   }
                                .)
                                
  "COMPILER"                    (. genScanner = true; .)
  ident                         (. gramName = coco_string_create(t->val);
                                   beg = la->pos; 
                                 .)
  { ANY }                       (. tab->semDeclPos = new Position(beg, la->pos-beg, 0); .)
  XmlLangDefinitionDecl<.xldef.>  (. xsdata->Add(L"", xldef); .)

  { XmlNamespaceDeclaration }

  "PRODUCTIONS"                 (. tab->DeleteNodes(); .)
  { ident                       (. sym = tab->FindSym(t->val);
                                   bool undef = (sym == NULL);
                                   if (undef) sym = tab->NewSym(Node::nt, t->val, t->line);
                                   else {
                                     if (sym->typ == Node::nt) {
                                       if (sym->graph != NULL) SemErr(L"name declared twice");
                                   	 } else SemErr(L"this symbol kind not allowed on left side of production");
                                   	 sym->line = t->line;
                                   }
                                   bool noAttrs = (sym->attrPos == NULL);
                                   sym->attrPos = NULL;
                                 .)
    [ AttrDecl<sym> ]           (. if (!undef)
                                     if (noAttrs != (sym->attrPos == NULL))
                                       SemErr(L"attribute mismatch between declaration and use of this symbol");
                                 .)
    [ SemText<.sym->semPos.> ] WEAK
    '='
    Expression<g>               (. sym->graph = g->l;
                                   tab->Finish(g);
                                 .)
                                WEAK
    '.'
  }
  "END" ident                   (. if (!coco_string_equal(gramName, t->val))
                                     SemErr(L"name does not match grammar name");
                                   tab->gramSy = tab->FindSym(gramName);
                                   if (tab->gramSy == NULL)
                                     SemErr(L"missing production for grammar name");
                                   else {
                                     sym = tab->gramSy;
                                     if (sym->attrPos != NULL)
                                       SemErr(L"grammar symbol must not have attributes");
                                   }
                                   tab->noSym = tab->NewSym(Node::t, L"???", 0); // noSym gets highest number
                                   tab->SetupAnys();
                                   tab->RenumberPragmas();
                                   if (tab->ddt[2]) tab->PrintNodes();
                                   if (errors->count == 0) {
                                     wprintf(L"checking\n");
                                     tab->CompSymbolSets();
                                     if (tab->ddt[7]) tab->XRef();
                                     if (tab->GrammarOk()) {
                                       wprintf(L"parser");
                                       pgen->WriteXmlParser();
                                       if (genScanner) {
                                         wprintf(L" + scanner");
                                         xsdata->WriteXmlScanner();
                                         /* if (tab->ddt[0]) dfa->PrintStates(); */
                                       }
                                       wprintf(L" generated\n");
                                       if (tab->ddt[8]) pgen->WriteStatistics();
                                     }
                                   }
                                   if (tab->ddt[6]) tab->PrintSymbolTable();
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

XmlNamespaceDeclaration          (. wchar_t* namespace_name;
                                              XmlLangDefinition *xldef; .)
=
  "NAMESPACE"
  string                         (. namespace_name = t->val; .)
  "{"
  XmlLangDefinitionDecl<.xldef.>   (. xsdata->Add(namespace_name, xldef); .)
  "}"
.

/*------------------------------------------------------------------------------------*/

XmlLangDefinitionDecl<.XmlLangDefinition* &xldef.>
=  (. xldef = new XmlLangDefinition(tab, errors);  .)
  [ "OPTIONS" { OptionDecl<xldef> } ]
  [ "TAGS" { XmlTagDecl<xldef> } ]
  [ "ATTRS" { XmlAttrDecl<xldef> } ]
  [ "PROCESSING_INSTRUCTIONS" { ProcessingInstruction<xldef> } ]
.

/*------------------------------------------------------------------------------------*/

/* For the possible values, ses XSData.cpp. */
OptionDecl<XmlLangDefinition *xldef>
=
  ident (. xldef->AddOption(t->val, t->line); .)
.

/*------------------------------------------------------------------------------------*/

XmlTagDecl<XmlLangDefinition *xldef>   (. wchar_t* tokenName; .)
=
  ident    (. tokenName = coco_string_create(t->val); .)
  "="
  string   (. xldef->AddTag(t->val, tokenName, t->line); .)
.

/*------------------------------------------------------------------------------------*/

XmlAttrDecl<XmlLangDefinition *xldef>  (. wchar_t* tokenName; .)
=
  ident    (. tokenName = coco_string_create(t->val); .)
  "="
  string   (. xldef->AddAttr(t->val, tokenName, t->line); .)
.

/*------------------------------------------------------------------------------------*/

ProcessingInstruction<XmlLangDefinition *xldef>   (. wchar_t* tokenName; .)
=
  ident    (. tokenName = coco_string_create(t->val); .)
  "="
  string   (. xldef->AddProcessingInstruction(t->val, tokenName, t->line); .)
.

/*------------------------------------------------------------------------------------*/

AttrDecl<Symbol *sym>
=
  '<'                           (. int beg = la->pos; int col = la->col; .)
  { ANY
  | badString                   (. SemErr(L"bad string in attributes"); .)
  }
  '>'                           (. if (t->pos > beg)
                                     sym->attrPos = new Position(beg, t->pos - beg, col); .)
| "<."                          (. int beg = la->pos; int col = la->col; .)
  { ANY
  | badString                   (. SemErr(L"bad string in attributes"); .)
  }
  ".>"                          (. if (t->pos > beg)
                                     sym->attrPos = new Position(beg, t->pos - beg, col); .)
.

/*------------------------------------------------------------------------------------*/

Expression<Graph* &g>           (. Graph *g2; .)
= 
  Term<g>                       (. bool first = true; .)
  {                             WEAK
    '|'
    Term<g2>                    (. if (first) { tab->MakeFirstAlt(g); first = false; }
                                   tab->MakeAlternative(g, g2);
                                 .)
  }
.

/*------------------------------------------------------------------------------------*/

Term<Graph* &g>               (. Graph *g2; Node *rslv = NULL; g = NULL; .)
=
( [                           (. rslv = tab->NewNode(Node::rslv, (Symbol*)NULL, la->line); .)
    Resolver<.rslv->pos.>       (. g = new Graph(rslv); .)
  ]
  Factor<g2>                  (. if (rslv != NULL) tab->MakeSequence(g, g2);
                                 else g = g2; .)
  { Factor<g2>                (. tab->MakeSequence(g, g2); .)
  }
|                             (. g = new Graph(tab->NewNode(Node::eps, (Symbol*)NULL, 0)); .)
)                             (. if (g == NULL) // invalid start of Term
                                 g = new Graph(tab->NewNode(Node::eps, (Symbol*)NULL, 0)); .)
.

/*------------------------------------------------------------------------------------*/

Factor<Graph* &g>             (. wchar_t* name = NULL; int kind; Position *pos; bool weak = false; 
                                   g = NULL;
                                 .)
=
( [ "WEAK"                      (. weak = true; .)
  ]
  Sym<name, kind>             (. Symbol *sym = tab->FindSym(name);
                                   if (sym == NULL && kind == str)
                                     sym = (Symbol*)((*(tab->literals))[name]);
                                   bool undef = (sym == NULL);
                                   if (undef) {
                                     if (kind == id)
                                       sym = tab->NewSym(Node::nt, name, 0);  // forward nt
                                     else if (genScanner) { 
                                       sym = tab->NewSym(Node::t, name, t->line);
                                     } else {  // undefined string in production
                                       SemErr(L"undefined string in production");
                                       sym = tab->eofSy;  // dummy
                                     }
                                   }
                                   int typ = sym->typ;
                                   if (typ != Node::t && typ != Node::nt)
                                     SemErr(L"this symbol kind is not allowed in a production");
                                   if (weak)
                                     if (typ == Node::t) typ = Node::wt;
                                     else SemErr(L"only terminals may be weak");
                                   Node *p = tab->NewNode(typ, sym, t->line);
                                   g = new Graph(p);
                                 .)
  [ Attribs<p>                  (. if (kind != id) SemErr(L"a literal must not have attributes"); .)
  ]                             (. if (undef)
                                     sym->attrPos = p->pos;  // dummy
                                   else if ((p->pos == NULL) != (sym->attrPos == NULL))
                                     SemErr(L"attribute mismatch between declaration and use of this symbol");
                                 .)
| '(' Expression<g> ')'
| '[' Expression<g> ']'     (. tab->MakeOption(g); .)
| '{' Expression<g> '}'     (. tab->MakeIteration(g); .)
| SemText<pos>              (. Node *p = tab->NewNode(Node::sem, (Symbol*)NULL, 0);
                                   p->pos = pos;
                                   g = new Graph(p);
                                 .)
| "ANY"                         (. Node *p = tab->NewNode(Node::any, (Symbol*)NULL, 0);  // p.set is set in tab->SetupAnys
                                   g = new Graph(p);
                                 .)
| "SYNC"                        (. Node *p = tab->NewNode(Node::sync, (Symbol*)NULL, 0);
                                   g = new Graph(p);
                                 .)
)                               (. if (g == NULL) // invalid start of Factor
                                     g = new Graph(tab->NewNode(Node::eps, (Symbol*)NULL, 0));
                                 .)
.

/*------------------------------------------------------------------------------------*/

Resolver<Position* &pos>   
=
  "IF" "("                       (. int beg = la->pos; int col = la->col; .)
  Condition                      (. pos = new Position(beg, t->pos - beg, col); .)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

Sym<wchar_t* &name, int &kind>
=                               (. name = coco_string_create(L"???"); kind = id; .)
( ident                         (. kind = id; coco_string_delete(name); name = coco_string_create(t->val); .)
| (string                       (. coco_string_delete(name); name = coco_string_create(t->val); .)
  | char                        (.
								   wchar_t *subName = coco_string_create(t->val, 1, coco_string_length(t->val)-2);
								   coco_string_delete(name); 
								   name = coco_string_create_append(L"\"", subName);
								   coco_string_delete(subName);
								   coco_string_merge(name, L"\""); 
							    .)
  )                             (. kind = str;
                                   if (coco_string_indexof(name, ' ') >= 0)
                                     SemErr(L"literal tokens must not contain blanks"); .)
)
.

/*------------------------------------------------------------------------------------*/

Attribs<Node *p>
=
  '<'                           (. int beg = la->pos; int col = la->col; .)
  { ANY 
  | badString                   (. SemErr(L"bad string in attributes"); .)
  }
  '>'                           (. if (t->pos > beg) p->pos = new Position(beg, t->pos - beg, col); .)
| "<."                          (. int beg = la->pos; int col = la->col; .)
  { ANY 
  | badString                   (. SemErr(L"bad string in attributes"); .)
  }
  ".>"                          (. if (t->pos > beg) p->pos = new Position(beg, t->pos - beg, col); .)
.

/*------------------------------------------------------------------------------------*/

SemText<Position* &pos>
=
  "(."                          (. int beg = la->pos; int col = la->col; .)
  { ANY
  | badString                   (. SemErr(L"bad string in semantic action"); .)
  | "(."                        (. SemErr(L"missing end of previous semantic action"); .)
  }
  ".)"                          (. pos = new Position(beg, t->pos - beg, col); .)
.

/*------------------------------------------------------------------------------------*/
  
END CocoXml.
