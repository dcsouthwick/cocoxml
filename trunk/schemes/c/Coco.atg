SECTION license
/*-------------------------------------------------------------------------
 Coco.ATG -- Attributed Grammar
 Compiler Generator Coco/R,
 Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
 extended by M. Loeberbauer & A. Woess, Univ. of Linz
 with improvements by Pat Terry, Rhodes University.
 ported to C by Charles Wang <charlesw123456@gmail.com>

 This program is free software; you can redistribute it and/or modify it 
 under the terms of the GNU General Public License as published by the 
 Free Software Foundation; either version 2, or (at your option) any 
 later version.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 for more details.

 You should have received a copy of the GNU General Public License along 
 with this program; if not, write to the Free Software Foundation, Inc., 
 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

 As an exception, it is allowed to write an extension of Coco/R that is
 used as a plugin in non-free software.

 If not otherwise stated, any source code generated by Coco/R (other than 
 Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
END.

SCHEME c Ccs

SECTION hIncludes
#ifndef  COCO_GLOBALS_H
#include  "Globals.h"
#endif
END.

SECTION cIncludes
#include  <ctype.h>
#include  "Globals.h"
#include  "lexical/CharSet.h"
#include  "lexical/CharClass.h"
#include  "lexical/Nodes.h"
#include  "syntax/Nodes.h"
static const int CcsParser_id = 0;
static const int CcsParser_str = 1;
static const char * noString = "~none~";
END.

COMPILER Coco

MEMBERS
    CcGlobals_t       globals;
    char            * tokenString;
    CcsBool_t         genScanner;

    /* Shortcut pointers */
    CcSymbolTable_t * symtab;
    CcLexical_t     * lexical;
    CcSyntax_t      * syntax;

CONSTRUCTOR
    if (!CcGlobals(&self->globals, &self->errpool)) return FALSE;
    self->tokenString = NULL;
    self->genScanner = FALSE;
    self->symtab = &self->globals.symtab;
    self->lexical = self->globals.lexical;
    self->syntax = &self->globals.syntax;

DESTRUCTOR
    if (self->tokenString && self->tokenString != noString)
        CcFree(self->tokenString);
    CcGlobals_Destruct(&self->globals);

CHARACTERS
    letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
    digit     = "0123456789".
    cr        = '\r'.
    lf        = '\n'.
    tab       = '\t'.
    stringCh  = ANY - '"' - '\\' - cr - lf.
    charCh    = ANY - '\'' - '\\' - cr - lf.
    printable =  '\x20' .. '\x7e'.
    hex       = "0123456789abcdef".

TOKENS
    ident     = letter { letter | digit }.
    number    = digit { digit }.
    string    = '"' { stringCh | '\\' printable } '"'.
    badString = '"' { stringCh | '\\' printable } (cr | lf).
    char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
    ddtSym    = '$' { digit | letter }.  (. .)

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

Coco                            (. CcSymbol_t  * sym;
				   CcGraph_t   * g, * g1, * g2;
				   char        * gramName = NULL;
				   CcCharSet_t * s; 
				   CcsToken_t  * beg;
				   CcsBool_t     nested;
				   CcsBool_t     undef;
				   CcsBool_t     noAttrs;
				   self->tokenString = NULL; .)
=
  { SchemeDecl | SectionDecl }
  "COMPILER"                    (. self->genScanner = TRUE; .)
  ident                         (. gramName = CcStrdup(self->t->val); .)
  [ "MEMBERS"                   (. CcsScanner_TokenIncRef(&self->scanner, beg = self->la); .)
    { ANY }                     (. self->syntax->members = CcsScanner_GetPosition(&self->scanner, beg, self->la);
      	  			   CcsScanner_TokenDecRef(&self->scanner, beg); .)
    ]
  [ "CONSTRUCTOR"               (. CcsScanner_TokenIncRef(&self->scanner, beg = self->la); .)
    { ANY }			(. self->syntax->constructor = CcsScanner_GetPosition(&self->scanner, beg, self->la);
      	  			   CcsScanner_TokenDecRef(&self->scanner, beg); .)
    ]
  [ "DESTRUCTOR"                (. CcsScanner_TokenIncRef(&self->scanner, beg = self->la); .)
    { ANY }			(. self->syntax->destructor = CcsScanner_GetPosition(&self->scanner, beg, self->la);
      	  			   CcsScanner_TokenDecRef(&self->scanner, beg); .)
    ]
  [ "OPTIONS" { ident           (. CcLexical_SetOption(self->lexical, self->t, TRUE); .)
    	        | string        (. CcLexical_SetOption(self->lexical, self->t, FALSE); .) } ]
  [ "TERMINALS" { ident         (. CcLexical_AddTerminal(self->lexical, self->t); .) } ]
  [ "CHARACTERS" { SetDecl }]
  [ "TOKENS"  { TokenDecl<symbol_t> }]
  [ "PRAGMAS" { TokenDecl<symbol_pr> }]
  { "COMMENTS"                  (. nested = FALSE; .)
    "FROM" TokenExpr<&g1> 
    "TO" TokenExpr<&g2>
    [ "NESTED"                  (. nested = TRUE; .)
    ]                           (. CcLexical_NewComment(self->lexical, self->t,
    				   			g1->head, g2->head, nested);
				   CcGraph_Destruct(g1); CcGraph_Destruct(g2); .)
  }
  { "IGNORE" Set<&s>            (. CcCharSet_Or(self->lexical->ignored, s);
    	     			   CcCharSet_Destruct(s); .)
  }

  SYNC 
  "PRODUCTIONS"                 (. if (self->genScanner) CcLexical_MakeDeterministic(self->lexical);
  				   CcEBNF_Clear(&self->lexical->base);
  				   CcEBNF_Clear(&self->syntax->base); .)
  { ident                       (. sym = CcSymbolTable_FindSym(self->symtab, self->t->val);
                                   undef = (sym == NULL);
				   if (undef) {
				       sym = CcSymbolTable_NewNonTerminal(self->symtab,
									  self->t->val, self->t->loc.line);
                                   } else {
				       if (sym->base.type == symbol_nt) {
					   if (((CcSymbolNT_t *)sym)->graph != NULL)
					       CcsParser_SemErrT(self, "name declared twice");
				       } else {
					   CcsParser_SemErrT(self, "this symbol kind not allowed on left side of production");
				       }
				       sym->line = self->t->loc.line;
                                   }
				   CcsAssert(sym->base.type == symbol_nt);
                                   noAttrs = (((CcSymbolNT_t *)sym)->attrPos == NULL);
				   if (!noAttrs) {
				       CcsPosition_Destruct(((CcSymbolNT_t *)sym)->attrPos);
				       ((CcSymbolNT_t *)sym)->attrPos = NULL; 
				   } .)
    [ AttrDecl<(CcSymbolNT_t *)sym> ]  (. if (!undef && noAttrs != (((CcSymbolNT_t *)sym)->attrPos == NULL))
                                              CcsParser_SemErrT(self, "attribute mismatch between declaration and use of this symbol"); .)
    [ SemText<.&((CcSymbolNT_t *)sym)->semPos.> ] WEAK
    '='
    Expression<&g>              (. ((CcSymbolNT_t *)sym)->graph = g->head;
				   CcGraph_Finish(g);
				   CcGraph_Destruct(g); .)
                                WEAK
    '.'
  }
  "END" ident                   (. if (strcmp(gramName, self->t->val))
				       CcsParser_SemErrT(self, "name does not match grammar name");
				   self->syntax->gramSy = CcSymbolTable_FindSym(self->symtab, gramName);
				   CcFree(gramName);
				   if (self->syntax->gramSy == NULL) {
                                       CcsParser_SemErrT(self, "missing production for grammar name");
                                   } else {
                                       sym = self->syntax->gramSy;
                                       if (((CcSymbolNT_t *)sym)->attrPos != NULL)
					   CcsParser_SemErrT(self, "grammar symbol must not have attributes");
                                   }
				   /* noSym gets highest number */
				   self->syntax->noSy = CcSymbolTable_NewTerminal(self->symtab, "???", 0);
				   CcSyntax_SetupAnys(self->syntax); .)
  '.'
.

/*------------------------------------------------------------------------------------*/

SchemeDecl
=
  "SCHEME" ident  (. if (self->syntax->schemeName)
  	   	         CcFree(self->syntax->schemeName);
  	   	     self->syntax->schemeName = CcStrdup(self->t->val); .)
  ident           (. if (self->syntax->grammarPrefix)
  		     	 CcFree(self->syntax->grammarPrefix);
  		     self->syntax->grammarPrefix = CcStrdup(self->t->val); .)
.

/*------------------------------------------------------------------------------------*/

SectionDecl       (. char * secname; CcsToken_t * beg; .)
=
  "SECTION" ident (. secname = CcStrdup(self->t->val);
  	    	     CcsScanner_TokenIncRef(&self->scanner, beg = self->t); .)
  { ANY }         (. CcGlobals_NewSection(&self->globals, secname,
    		     			  CcsScanner_GetPositionBetween(&self->scanner, beg, self->la));
		     CcsScanner_TokenDecRef(&self->scanner, beg);
		     CcFree(secname); .)
  "END" '.'
.

/*------------------------------------------------------------------------------------*/

SetDecl                         (. CcCharSet_t * s; CcsToken_t * nameToken;
				   const char * name; CcCharClass_t * c; .)
=
  ident                         (. name = self->t->val;
				   CcsScanner_TokenIncRef(&self->scanner, nameToken = self->t);
				   c = CcLexical_FindCharClassN(self->lexical, name);
				   if (c != NULL)
				       CcsParser_SemErrT(self, "name '%s' declared twice", name); .)
  '=' Set<&s>                   (. if (CcCharSet_Elements(s) == 0)
				       CcsParser_SemErrT(self, "character set must not be empty");
				   CcLexical_NewCharClass(self->lexical, name, s);
				   CcsScanner_TokenDecRef(&self->scanner, nameToken); .)
  '.'
.

/*------------------------------------------------------------------------------------*/

Set<CcCharSet_t ** s>           (. CcCharSet_t * s2; .)
=
  SimSet<s>
  { '+' SimSet<&s2>             (. CcCharSet_Or(*s, s2);
    				   CcCharSet_Destruct(s2); .)
  | '-' SimSet<&s2>             (. CcCharSet_Subtract(*s, s2);
    				   CcCharSet_Destruct(s2); .)
  }
.

/*------------------------------------------------------------------------------------*/

SimSet<CcCharSet_t ** s>        (. int n1, n2;
		      		   CcCharClass_t * c;
		      		   const char * cur0;
				   int ch;
				   char * cur, * name;
				   int idx; .)
=                               (. *s = CcCharSet(); .)
( ident                         (. c = CcLexical_FindCharClassN(self->lexical, self->t->val);
				   if (c != NULL) CcCharSet_Or(*s, c->set);
				   else CcsParser_SemErrT(self, "undefined name '%s'", self->t->val); .)
| string                        (. name = CcUnescape(self->t->val);
				   if (self->lexical->ignoreCase) {
				       for (cur = name; *cur; ++cur) *cur = tolower(*cur);
				   }
				   cur0 = name;
				   while (*cur0) {
				       ch = CcsUTF8GetCh(&cur0, name + strlen(name));
				       CcsAssert(ch >= 0);
				       CcCharSet_Set(*s, ch);
                                   }
				   CcFree(name); .)
| Char<&n1>                     (. CcCharSet_Set(*s, n1); .)
  [ ".." Char<&n2>              (. for (idx = n1; idx <= n2; ++idx) CcCharSet_Set(*s, idx); .)
  ]
| "ANY"                         (. CcCharSet_Fill(*s, COCO_WCHAR_MAX); .)
)
.

/*--------------------------------------------------------------------------------------*/

Char<int * n>          (. char * name; const char * cur; .)
=
  char                 (. *n = 0;
		          cur = name = CcUnescape(self->t->val);
			  *n = CcsUTF8GetCh(&cur, name + strlen(name));
			  if (*cur != 0)
			      CcsParser_SemErrT(self, "unacceptable character value: '%s'", self->t->val);
			  CcFree(name);
			  if (self->lexical->ignoreCase) *n = tolower(*n); .)
.

/*------------------------------------------------------------------------------------*/

TokenDecl<const CcObjectType_t * typ> (. char * name = NULL; int kind; CcSymbol_t * sym; CcGraph_t * g; .)
=
  Sym<&name, &kind>             (. sym = CcSymbolTable_FindSym(self->symtab, name);
				   if (sym != NULL) {
				       CcsParser_SemErrT(self, "name '%s' declared twice", name);
                                   } else if (typ == symbol_t) {
				       sym = CcSymbolTable_NewTerminal(self->symtab, name, self->t->loc.line);
				       ((CcSymbolT_t *)sym)->tokenKind = symbol_fixedToken;
				   } else if (typ == symbol_pr) {
				       sym = CcSymbolTable_NewPragma(self->symtab, name, self->t->loc.line);
				       ((CcSymbolPR_t *)sym)->tokenKind = symbol_fixedToken;
				       ((CcSymbolPR_t *)sym)->semPos = NULL;
                                   }
				   if (self->tokenString && self->tokenString != noString)
				       CcFree(self->tokenString);
				   self->tokenString = NULL;
				   CcFree(name); .)
  SYNC
  ( '=' TokenExpr<&g> '.'       (. if (kind == CcsParser_str)
				       CcsParser_SemErrT(self, "a literal must not be declared with a structure");
				   CcGraph_Finish(g);
				   if (self->tokenString == NULL || self->tokenString == noString) {
				       CcLexical_ConvertToStates(self->lexical, g->head, sym);
                                   } else { /* CcsParser_TokenExpr is a single string */
				       if (CcHashTable_Get(&self->lexical->literals,
							   self->tokenString) != NULL)
					   CcsParser_SemErrT(self, "token string '%s' declared twice", self->tokenString);
				       if (!CcHashTable_Set(&self->lexical->literals,
				                            self->tokenString, (CcObject_t *)sym))
					   CcsParser_SemErrT(self, "Too many literals, recompile Coco with enlarged literal hash table.");
				       CcLexical_MatchLiteral(self->lexical, self->t,
				                              self->tokenString, sym);
				       CcFree(self->tokenString);
                                   }
				   self->tokenString = NULL;
				   CcGraph_Destruct(g); .)
  |                             (. if (kind == CcsParser_id) self->genScanner = FALSE;
				   else CcLexical_MatchLiteral(self->lexical, self->t, sym->name, sym); .)
  )
  [ SemText<.&((CcSymbolPR_t *)sym)->semPos.> (. if (typ != symbol_pr)
    			     		      	     CcsParser_SemErrT(self, "semantic action not allowed here"); .)
  ]
.

/*------------------------------------------------------------------------------------*/

AttrDecl<CcSymbolNT_t * sym>    (. CcsToken_t * beg; .)
=
  '<'                           (. CcsScanner_TokenIncRef(&self->scanner, beg = self->la); .)
  { ANY
  | badString                   (. CcsParser_SemErrT(self, "bad string in attributes"); .)
  }
  '>'                           (. sym->attrPos = CcsScanner_GetPosition(&self->scanner, beg, self->t);
  				   CcsScanner_TokenDecRef(&self->scanner, beg); .)
| "<."                          (. CcsScanner_TokenIncRef(&self->scanner, beg = self->la); .)
  { ANY
  | badString                   (. CcsParser_SemErrT(self, "bad string in attributes"); .)
  }
  ".>"                          (. sym->attrPos = CcsScanner_GetPosition(&self->scanner, beg, self->t);
     				   CcsScanner_TokenDecRef(&self->scanner, beg); .)
.

/*------------------------------------------------------------------------------------*/

Expression<CcGraph_t ** g>      (. CcGraph_t * g2; CcsBool_t first; .)
= 
  Term<g>                       (. first = TRUE; .)
  {                             WEAK
    '|'
  Term<&g2>                     (. if (first) { CcEBNF_MakeFirstAlt(&self->syntax->base, *g); first = FALSE; }
                                   CcEBNF_MakeAlternative(&self->syntax->base, *g, g2);
				   CcGraph_Destruct(g2); .)
  }
.

/*------------------------------------------------------------------------------------*/

Term<CcGraph_t ** g>            (. CcGraph_t * g2; CcsPosition_t * pos; CcNode_t * rslv = NULL;
                                   *g = NULL; .)
=
  ( [
  Resolver<.&pos.>              (. rslv = CcEBNF_NewNode(&self->syntax->base,
							 CcNodeRslvP(self->la->loc.line, pos));
                                   *g = CcGraphP(rslv); .)
  ]
  Factor<&g2>                   (. if (rslv == NULL) *g = g2;
   				   else {
				       CcEBNF_MakeSequence(&self->syntax->base, *g, g2);
				       CcGraph_Destruct(g2);
				   } .)
  { Factor<&g2>                 (. CcEBNF_MakeSequence(&self->syntax->base, *g, g2);
    				   CcGraph_Destruct(g2); .)
  }
|                               (. *g = CcGraphP(CcEBNF_NewNode(&self->syntax->base, CcNodeEps(0))); .)
)                               (. if (*g == NULL) /* invalid start of Term */
				       *g = CcGraphP(CcEBNF_NewNode(&self->syntax->base, CcNodeEps(0))); .)
.

/*------------------------------------------------------------------------------------*/

Factor<CcGraph_t ** g>          (. char * name = NULL;
		    		   int kind;
		    		   CcsPosition_t * pos;
		    		   CcsBool_t weak = FALSE; 
				   CcSymbol_t * sym;
				   CcsBool_t undef;
				   CcNode_t * p;
                                   *g = NULL; .)
=
( [ "WEAK"                      (. weak = TRUE; .)
  ]
  Sym<&name, &kind>             (. sym = CcSymbolTable_FindSym(self->symtab, name);
                                   if (sym == NULL && kind == CcsParser_str)
                                       sym = (CcSymbol_t *)CcHashTable_Get(&self->lexical->literals, name);
                                   undef = (sym == NULL);
                                   if (undef) {
                                       if (kind == CcsParser_id) {
				           /* forward nt */
                                           sym = CcSymbolTable_NewNonTerminal(self->symtab, name, 0);
				       } else if (self->genScanner) {
					   sym = CcSymbolTable_NewTerminal(self->symtab, name, self->t->loc.line);
					   CcLexical_MatchLiteral(self->lexical, self->t, sym->name, sym);
				       } else {  /* undefined string in production */
					   CcsParser_SemErrT(self, "undefined string in production");
					   sym = self->syntax->eofSy;  /* dummy */
				       }
                                   } else {
				       if (kind == CcsParser_str) {
				       	   if (sym->base.type != symbol_t) {
				               CcsParser_SemErrT(self, "%s should be terminal, but it is not.", name);
					   } else if (((CcSymbolT_t *)sym)->tokenKind != symbol_litToken &&
					     	      ((CcSymbolT_t *)sym)->tokenKind != symbol_fixedToken) {
					       CcsParser_SemErrT(self, "%s should be literal, but it is not.", name);
					   }
				       }
				   }
				   CcFree(name);
                                   if (sym->base.type != symbol_t && sym->base.type != symbol_nt)
                                       CcsParser_SemErrT(self, "this symbol kind is not allowed in a production");
                                   if (weak) {
				       if (sym->base.type != symbol_t)
				           CcsParser_SemErrT(self, "only terminals may be weak");
				   }

				   p = CcSyntax_NodeFromSymbol(self->syntax, sym, self->t->loc.line, weak);
				   *g = CcGraphP(p); .)
  [ Attribs<p>                  (. if (kind != CcsParser_id)
                                       CcsParser_SemErrT(self, "a literal must not have attributes"); .)
  ]                             (. if (undef) {
                                       if (sym->base.type == symbol_nt)
				           ((CcSymbolNT_t *)sym)->attrPos = CcsPosition_Clone(((CcNodeNT_t *)p)->pos);
                                   } else if (sym->base.type == symbol_nt &&
				              (((CcNodeNT_t *)p)->pos == NULL) !=
					      (((CcSymbolNT_t *)sym)->attrPos == NULL))
				       CcsParser_SemErrT(self, "attribute mismatch between declaration and use of this symbol"); .)
| '(' Expression<g> ')'
| '[' Expression<g> ']'         (. CcEBNF_MakeOption(&self->syntax->base, *g); .)
| '{' Expression<g> '}'         (. CcEBNF_MakeIteration(&self->syntax->base, *g); .)
| SemText<&pos>                 (. p = CcEBNF_NewNode(&self->syntax->base, CcNodeSem(0));
                                   ((CcNodeSEM_t *)p)->pos = pos;
				   *g = CcGraphP(p); .)
| "ANY"                         (. /* p.set is set in Tab_SetupAnys */
                                   p = CcEBNF_NewNode(&self->syntax->base, CcNodeAny(0));
				   *g = CcGraphP(p); .)
| "SYNC"                        (. p = CcEBNF_NewNode(&self->syntax->base, CcNodeSync(0));
				   *g = CcGraphP(p);
                                .)
)                               (. if (*g == NULL) /* invalid start of Factor */
				       *g = CcGraphP(CcEBNF_NewNode(&self->syntax->base, CcNodeEps(0))); .)
.

/*------------------------------------------------------------------------------------*/

Resolver<CcsPosition_t ** pos>   (. CcsToken_t * beg; .)
=
  "IF" "("                       (. CcsScanner_TokenIncRef(&self->scanner, beg = self->la); .)
  Condition                      (. *pos = CcsScanner_GetPosition(&self->scanner, beg, self->t);
                                    CcsScanner_TokenDecRef(&self->scanner, beg); .)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

TokenExpr<CcGraph_t ** g>       (. CcGraph_t * g2; CcsBool_t first; .)
=
  TokenTerm<g>                  (. first = TRUE; .)
  {                             WEAK
    '|'
    TokenTerm<&g2>              (. if (first) { CcEBNF_MakeFirstAlt(&self->lexical->base, *g); first = FALSE; }
                                   CcEBNF_MakeAlternative(&self->lexical->base, *g, g2);
				   CcGraph_Destruct(g2); .)
  }
.

/*------------------------------------------------------------------------------------*/

TokenTerm<CcGraph_t ** g>       (. CcGraph_t * g2; .)
=
  TokenFactor<g>
  { TokenFactor<&g2>            (. CcEBNF_MakeSequence(&self->lexical->base, *g, g2);
                                   CcGraph_Destruct(g2); .)
  }
  [ "CONTEXT"
    '(' TokenExpr<&g2>          (. CcLexical_SetContextTrans(self->lexical, g2->head);
				   self->lexical->hasCtxMoves = TRUE;
				   CcEBNF_MakeSequence(&self->lexical->base, *g, g2); .)
    ')'
  ]
.

/*------------------------------------------------------------------------------------*/

TokenFactor<CcGraph_t ** g>     (. char * name = NULL; int kind;
		      	 	   CcTransition_t trans;
		      	 	   CcCharClass_t * c; .)
=
                                (. *g = NULL; .)
( Sym<&name, &kind>             (. if (kind == CcsParser_id) {
	                               c = CcLexical_FindCharClassN(self->lexical, name);
                                       if (c == NULL) {
					   CcsParser_SemErrT(self, "undefined name");
					   c = CcLexical_NewCharClass(self->lexical, name, CcCharSet());
				       }
				       CcTransition_FromCharSet(&trans, c->set, trans_normal,
				                                &self->lexical->classes);
				       *g = CcGraphP(CcEBNF_NewNode(&self->lexical->base,
				                                    CcNodeTrans(0, &trans)));
				       CcTransition_Destruct(&trans);
				       if (self->tokenString && self->tokenString != noString)
				           CcFree(self->tokenString);
				       self->tokenString = (char *)noString;
                                   } else { /* CcsParser_str */
	                               *g = CcLexical_StrToGraph(self->lexical, name, self->t);
				       if (self->tokenString == NULL) self->tokenString = CcStrdup(name);
				       else {
				           if (self->tokenString != noString) CcFree(self->tokenString);
					   self->tokenString = (char *)noString;
				       }
                                   }
				   CcFree(name); .)
| '(' TokenExpr<g> ')'
| '[' TokenExpr<g> ']'          (. CcEBNF_MakeOption(&self->lexical->base, *g); .)
| '{' TokenExpr<g> '}'          (. CcEBNF_MakeIteration(&self->lexical->base, *g); .)
)                               (. if (*g == NULL) /* invalid start of TokenFactor */
                                     *g = CcGraphP(CcEBNF_NewNode(&self->lexical->base, CcNodeEps(0))); .)
.

/*------------------------------------------------------------------------------------*/

Sym<char ** name, int * kind>   (. char * cur; .)
=                               (. *name = NULL; .)
( ident                         (. *kind = CcsParser_id; *name = CcStrdup(self->t->val); .)
| (string                       (. *name = CcUnescape(self->t->val); .)
  | char                        (. *name = CcUnescape(self->t->val); .)
  )                             (. *kind = CcsParser_str;
                                   if (self->lexical->ignoreCase) {
				       for (cur = *name; *cur; ++cur) *cur = tolower(*cur);
				   } .)
)                               (. if (!*name) *name = CcStrdup("???"); .)
.

/*------------------------------------------------------------------------------------*/

Attribs<CcNode_t * p>           (. CcsToken_t * beg; .)
=
  '<'                           (. CcsScanner_TokenIncRef(&self->scanner, beg = self->la); .)
  { ANY 
  | badString                   (. CcsParser_SemErrT(self, "bad string in attributes"); .)
  }
  '>'                           (. CcNode_SetPosition(p, CcsScanner_GetPosition(&self->scanner,
                                                                                beg, self->t));
                                   CcsScanner_TokenDecRef(&self->scanner, beg); .)
| "<."                          (. CcsScanner_TokenIncRef(&self->scanner, beg = self->la); .)
  { ANY 
  | badString                   (. CcsParser_SemErrT(self, "bad string in attributes"); .)
  }
  ".>"                          (. CcNode_SetPosition(p, CcsScanner_GetPosition(&self->scanner,
                                                                                beg, self->t));
                                   CcsScanner_TokenDecRef(&self->scanner, beg); .)
.

/*------------------------------------------------------------------------------------*/

SemText<CcsPosition_t ** pos>   (. CcsToken_t * beg; .)
=
  "(."                          (. CcsScanner_TokenIncRef(&self->scanner, beg = self->la); .)
  { ANY
  | badString                   (. CcsParser_SemErrT(self, "bad string in semantic action"); .)
  | "(."                        (. CcsParser_SemErrT(self, "missing end of previous semantic action"); .)
  }
  ".)"                          (. *pos = CcsScanner_GetPosition(&self->scanner, beg, self->t);
                                   CcsScanner_TokenDecRef(&self->scanner, beg); .)
.

/*------------------------------------------------------------------------------------*/
  
END Coco.
