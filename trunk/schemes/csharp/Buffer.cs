/*-------------------------------------------------------------------------
  Author (C) 2008, Charles Wang <charlesw123456@gmail.com>

  This program is free software; you can redistribute it and/or modify it 
  under the terms of the GNU General Public License as published by the 
  Free Software Foundation; either version 2, or (at your option) any 
  later version.

  This program is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
  for more details.

  You should have received a copy of the GNU General Public License along 
  with this program; if not, write to the Free Software Foundation, Inc., 
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than 
  Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
using Debug;

public class CcsBuffer_t {
    const int BUFSTEP = 4096;
    Stream stream;
    long start;
    char[] buf;
    int busyFirst;
    int lockCur;
    int lockNext;
    int cur;
    int next;
    int loaded;
    int last;

    public CcsBuffer_t(Stream s)
    {
	stream = s;
	start = 0;
	buf = new char[BUFSTEP];
	busyFirst = lockCur = -1;
	cur = -1;
	next = loaded = 0;
	last = BUFSTEP;
	Load();
    }

    ~CcsBuffer_t()
    {
	stream.Close();
    }

    public long GetPos(void)
    {
	return cur >= 0 ? start + cur : 0L;
    }

    public int Read(void)
    {
    }

    public string GetString(long start, int size)
    {
	if (size == 0) return null;
	Debug.Assert(start >= this.start && start < this.start + cur);
	Debug.Assert(start + size <= loaded);
	return new String(buf, start - self->start, size);
    }

    public void SetBusy(long startBusy)
    {
	Debug.Assert(startBusy >= start);
	busyFirst = startBusy - start;
	Debug.Assert(busyFirst <= cur);
    }

    public void ClearBusy(void)
    {
	busyFirst = -1;
    }

    public void Lock(void)
    {
	Debug.Assert(lockCur >= 0);
	lockCur = cur;
	lockNext = next;
    }

    public void LockReset(void)
    {
	Debug.Assert(lockCur >= 0);
	cur = lockCur;
	next = lockNext;
	lockCur = -1;
    }

    public void Unlock(void)
    {
	Debug.Assert(lockCur >= 0);
	lockCur = -1;
    }

    private void Load(void)
    {
	loaded += stream.Read(buf, loaded, last - loaded);
    }

    private int ReadByte(out int value)
    {
    }
};

int
CcsBuffer_Read(CcsBuffer_t * self, int * retBytes)
{
    int ch, c1, c2, c3, c4;
    /* self->start might be changed in CcsBuffer_ReadByte */
    long next = self->start + (self->next - self->buf);

    self->cur = self->next;

    if (CcsBuffer_ReadByte(self, &ch) < 0) goto quit;

    if (ch < 128) goto quit;

    if ((ch & 0xC0) != 0xC0) /* Inside UTF-8 character! */
	return ErrorChr;
    if ((ch & 0xF0) == 0xF0) {
	/* 1110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
	c1 = ch & 0x07;
	if (CcsBuffer_ReadByte(self, &ch) < 0) goto quit;
	c2 = ch & 0x3F;
	if (CcsBuffer_ReadByte(self, &ch) < 0) goto quit;
	c3 = ch & 0x3F;
	if (CcsBuffer_ReadByte(self, &ch) < 0) goto quit;
	c4 = ch & 0x3F;
	ch = (((((c1 << 6) | c2) << 6) | c3) << 6) | c4;
    } else if ((ch & 0xE0) == 0xE0) {
	/* 1110xxxx 10xxxxxx 10xxxxxx */
	c1 = ch & 0x0F;
	if (CcsBuffer_ReadByte(self, &ch) < 0) goto quit;
	c2 = ch & 0x3F;
	if (CcsBuffer_ReadByte(self, &ch) < 0) goto quit;
	c3 = ch & 0x3F;
	ch = (((c1 << 6) | c2) << 6) | c3;
    } else {
	/* (ch & 0xC0) == 0xC0 */
	/* 110xxxxx 10xxxxxx */
	c1 = ch & 0x1F;
	if (CcsBuffer_ReadByte(self, &ch) < 0) goto quit;
	c2 = ch & 0x3F;
	ch = (c1 << 6) | c2;
    }
 quit:
    *retBytes = self->start + (self->next - self->buf) - next;
    return ch;
}

static int
CcsBuffer_ReadByte(CcsBuffer_t * self, int * value)
{
    int delta; char * keptFirst, * newbuf;
    while (self->next >= self->loaded) {
	/* Calculate keptFirst */
	keptFirst = self->cur;
	if (self->busyFirst && self->busyFirst < keptFirst)
	    keptFirst = self->busyFirst;
	if (self->lockCur && self->lockCur < keptFirst)
	    keptFirst = self->lockCur;
	if (self->buf < keptFirst) { /* Remove the unprotected data. */
	    delta = keptFirst - self->buf;
	    memmove(self->buf, keptFirst, self->loaded - keptFirst);
	    self->start += delta;
	    if (self->busyFirst) self->busyFirst -= delta;
	    if (self->lockCur) {
		self->lockCur -= delta; self->lockNext -= delta;
	    }
	    self->cur -= delta;
	    self->next -= delta;
	    self->loaded -= delta;
	}
	if (feof(self->fp)) { *value = EoF; return -1; }
	/* Try to extend the storage space */
	while (self->loaded >= self->last) {
	    if (!(newbuf =
		  CcsRealloc(self->buf, self->last - self->buf + BUFSTEP))) {
		*value = ErrorChr;
		return -1;
	    }
	    if (self->busyFirst)
		self->busyFirst = newbuf + (self->busyFirst - self->buf);
	    if (self->lockCur) {
		self->lockCur = newbuf + (self->lockCur - self->buf);
		self->lockNext = newbuf + (self->lockNext - self->buf);
	    }
	    self->cur = newbuf + (self->cur - self->buf);
	    self->next = newbuf + (self->next - self->buf);
	    self->loaded = newbuf + (self->loaded - self->buf);
	    self->last = newbuf + (self->last - self->buf + BUFSTEP);
	    self->buf = newbuf;
	}
	if (CcsBuffer_Load(self) < 0) { *value = ErrorChr; return -1; }
    }
    *value = *self->next++;
    return 0;
}
